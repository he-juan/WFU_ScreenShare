{"version":3,"names":[],"mappings":"","sources":["gsRTC.min.js"],"sourcesContent":["\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.debug = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){},{\r\n\r\n}],2:[function(require,module,exports){\r\n/* global window, exports, define */\r\n    !function() {\r\n            'use strict';\r\n\r\n            var re = {\r\n                not_string: /[^s]/,\r\n                not_bool: /[^t]/,\r\n                not_type: /[^T]/,\r\n                not_primitive: /[^v]/,\r\n                number: /[diefg]/,\r\n                numeric_arg: /[bcdiefguxX]/,\r\n                json: /[j]/,\r\n                not_json: /[^j]/,\r\n                text: /^[^\\x25]+/,\r\n                modulo: /^\\x25{2}/,\r\n                placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\r\n                key: /^([a-z_][a-z_\\d]*)/i,\r\n                key_access: /^\\.([a-z_][a-z_\\d]*)/i,\r\n                index_access: /^\\[(\\d+)\\]/,\r\n                sign: /^[\\+\\-]/\r\n            }\r\n\r\n            function sprintf(key) {\r\n                // `arguments` is not an array, but should be fine for this call\r\n                return sprintf_format(sprintf_parse(key), arguments)\r\n            }\r\n\r\n            function vsprintf(fmt, argv) {\r\n                return sprintf.apply(null, [fmt].concat(argv || []))\r\n            }\r\n\r\n            function sprintf_format(parse_tree, argv) {\r\n                var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign\r\n                for (i = 0; i < tree_length; i++) {\r\n                    if (typeof parse_tree[i] === 'string') {\r\n                        output += parse_tree[i]\r\n                    }\r\n                    else if (Array.isArray(parse_tree[i])) {\r\n                        match = parse_tree[i] // convenience purposes only\r\n                        if (match[2]) { // keyword argument\r\n                            arg = argv[cursor]\r\n                            for (k = 0; k < match[2].length; k++) {\r\n                                if (!arg.hasOwnProperty(match[2][k])) {\r\n                                    throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\r\n                                }\r\n                                arg = arg[match[2][k]]\r\n                            }\r\n                        }\r\n                        else if (match[1]) { // positional argument (explicit)\r\n                            arg = argv[match[1]]\r\n                        }\r\n                        else { // positional argument (implicit)\r\n                            arg = argv[cursor++]\r\n                        }\r\n\r\n                        if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {\r\n                            arg = arg()\r\n                        }\r\n\r\n                        if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {\r\n                            throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\r\n                        }\r\n\r\n                        if (re.number.test(match[8])) {\r\n                            is_positive = arg >= 0\r\n                        }\r\n\r\n                        switch (match[8]) {\r\n                            case 'b':\r\n                                arg = parseInt(arg, 10).toString(2)\r\n                                break\r\n                            case 'c':\r\n                                arg = String.fromCharCode(parseInt(arg, 10))\r\n                                break\r\n                            case 'd':\r\n                            case 'i':\r\n                                arg = parseInt(arg, 10)\r\n                                break\r\n                            case 'j':\r\n                                arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\r\n                                break\r\n                            case 'e':\r\n                                arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\r\n                                break\r\n                            case 'f':\r\n                                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\r\n                                break\r\n                            case 'g':\r\n                                arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)\r\n                                break\r\n                            case 'o':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(8)\r\n                                break\r\n                            case 's':\r\n                                arg = String(arg)\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 't':\r\n                                arg = String(!!arg)\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'T':\r\n                                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'u':\r\n                                arg = parseInt(arg, 10) >>> 0\r\n                                break\r\n                            case 'v':\r\n                                arg = arg.valueOf()\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'x':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(16)\r\n                                break\r\n                            case 'X':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\r\n                                break\r\n                        }\r\n                        if (re.json.test(match[8])) {\r\n                            output += arg\r\n                        }\r\n                        else {\r\n                            if (re.number.test(match[8]) && (!is_positive || match[3])) {\r\n                                sign = is_positive ? '+' : '-'\r\n                                arg = arg.toString().replace(re.sign, '')\r\n                            }\r\n                            else {\r\n                                sign = ''\r\n                            }\r\n                            pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\r\n                            pad_length = match[6] - (sign + arg).length\r\n                            pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\r\n                            output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\r\n                        }\r\n                    }\r\n                }\r\n                return output\r\n            }\r\n\r\n            var sprintf_cache = Object.create(null)\r\n\r\n            function sprintf_parse(fmt) {\r\n                if (sprintf_cache[fmt]) {\r\n                    return sprintf_cache[fmt]\r\n                }\r\n\r\n                var _fmt = fmt, match, parse_tree = [], arg_names = 0\r\n                while (_fmt) {\r\n                    if ((match = re.text.exec(_fmt)) !== null) {\r\n                        parse_tree.push(match[0])\r\n                    }\r\n                    else if ((match = re.modulo.exec(_fmt)) !== null) {\r\n                        parse_tree.push('%')\r\n                    }\r\n                    else if ((match = re.placeholder.exec(_fmt)) !== null) {\r\n                        if (match[2]) {\r\n                            arg_names |= 1\r\n                            var field_list = [], replacement_field = match[2], field_match = []\r\n                            if ((field_match = re.key.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1])\r\n                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\r\n                                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {\r\n                                        field_list.push(field_match[1])\r\n                                    }\r\n                                    else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\r\n                                        field_list.push(field_match[1])\r\n                                    }\r\n                                    else {\r\n                                        throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                            }\r\n                            match[2] = field_list\r\n                        }\r\n                        else {\r\n                            arg_names |= 2\r\n                        }\r\n                        if (arg_names === 3) {\r\n                            throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\r\n                        }\r\n                        parse_tree.push(match)\r\n                    }\r\n                    else {\r\n                        throw new SyntaxError('[sprintf] unexpected placeholder')\r\n                    }\r\n                    _fmt = _fmt.substring(match[0].length)\r\n                }\r\n                return sprintf_cache[fmt] = parse_tree\r\n            }\r\n\r\n            /**\r\n             * export to either browser or node.js\r\n             */\r\n            /* eslint-disable quote-props */\r\n            if (typeof exports !== 'undefined') {\r\n                exports['sprintf'] = sprintf\r\n                exports['vsprintf'] = vsprintf\r\n            }\r\n            if (typeof window !== 'undefined') {\r\n                window['sprintf'] = sprintf\r\n                window['vsprintf'] = vsprintf\r\n\r\n                if (typeof define === 'function' && define['amd']) {\r\n                    define(function() {\r\n                        return {\r\n                            'sprintf': sprintf,\r\n                            'vsprintf': vsprintf\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n            /* eslint-enable quote-props */\r\n        }()\r\n},{}],3:[function(require,module,exports){\r\nvar sprintf = require(\"sprintf-js\").sprintf;\r\n\r\nvar argsToString = function(args) {\r\n            //sprintf-js did not support %o / %O\r\n            args[0] = args[0].replace(/%o/g, \"%s\");\r\n\r\n            switch (args.length) {\r\n                case 1:\r\n                    return args[0];\r\n                case 2:\r\n                    return sprintf(args[0], args[1]);\r\n                case 3:\r\n                    return sprintf(args[0], args[1], args[2]);\r\n                case 4:\r\n                    return sprintf(args[0], args[1], args[2], args[3]);\r\n                case 5:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4]);\r\n                case 6:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n                case 7:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\r\n                case 8:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\r\n                case 9:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\r\n                case 10:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\r\n                case 11:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\r\n                case 12:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\r\n                case 13:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);\r\n                case 14:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);\r\n                case 15:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);\r\n                case 16:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);\r\n                default:\r\n                    return null;\r\n            }\r\n        };\r\n\r\n\r\nfunction beautyDate(date) {\r\n    var yyyy = date.getFullYear();\r\n    var m = date.getMonth() + 1; // getMonth() is zero-based\r\n    var d = date.getDate();\r\n    var h = date.getHours();\r\n    var mi = date.getMinutes();\r\n    var sec = date.getSeconds();\r\n    var msec = date.getMilliseconds();\r\n\r\n    var mm  = m < 10 ? \"0\" + m : m;\r\n    var dd  = d < 10 ? \"0\" + d : d;\r\n    var hh  = h < 10 ? \"0\" + h : h;\r\n    var min = mi < 10 ? \"0\" + mi : mi;\r\n    var ss  = sec < 10 ? \"0\" + sec : sec;\r\n    var mss = msec < 10 ? \"00\" + msec : ( msec < 100 ? \"0\" + msec : msec );\r\n\r\n    return \"\".concat(yyyy).concat(\"-\").concat(mm).concat(\"-\").concat(dd).concat(\"@\").concat(hh).concat(\":\").concat(min).concat(\":\").concat(ss).concat(\".\").concat(mss);\r\n};\r\n\r\n//For catch browser console error events\r\nself.onerror = function(msg, url, lineNo, columnNo, error) {\r\n    var message = [\r\n        'Message: ' + msg,\r\n        'URL: ' + url,\r\n        'Line: ' + lineNo,\r\n        'Column: ' + columnNo,\r\n        'Error object: ' + JSON.stringify(error)\r\n    ].join('\\n');\r\n\r\n    this.debug('Console:ERROR')(message);\r\n    return false;\r\n};\r\n\r\n/***\r\n * indexedDB Class Model\r\n * @type {self.DBmanager}\r\n */\r\nself.DBmanager = class DBmanager {\r\n    constructor(dbName, storeName, version, index) {\r\n        this.dbName = dbName;\r\n        this.storeName = storeName;\r\n        this.version = version || 1;\r\n        this.index = index;\r\n        this.currentDB = null;\r\n    }\r\n\r\n    /***\r\n     * create database\r\n     */\r\n    openDB() {\r\n        var request = self.indexedDB.open(this.dbName, this.version);\r\n        request.onerror = function (e) {\r\n            console.log(e.currentTarget.error.message);\r\n        }.bind(this);\r\n\r\n        request.onsuccess = function (e) {\r\n            this.currentDB = e.target.result;\r\n            console.log(this.currentDB.name + ' database is already opened!');\r\n        }.bind(this);\r\n\r\n        request.onupgradeneeded = function (e) {\r\n            console.log('database version is already upgrade to ' + this.version);\r\n            this.currentDB = e.target.result;\r\n            if (!this.currentDB.objectStoreNames.contains(this.storeName)) {\r\n                var objectStore = this.currentDB.createObjectStore(this.storeName, {keyPath: \"id\", autoIncrement: true});\r\n\r\n                // create index\r\n                if(this.index && this.index.length > 0){\r\n                    this.index.forEach(function (item) {\r\n                        objectStore.createIndex(item, item);\r\n                    })\r\n                }\r\n            }\r\n        }.bind(this);\r\n    }\r\n\r\n    /***\r\n     * get store by storeName\r\n     * @returns {IDBObjectStore}\r\n     */\r\n    getStoreByName() {\r\n        return this.currentDB.transaction(this.storeName, 'readwrite').objectStore(this.storeName);\r\n    }\r\n\r\n    /***\r\n     * add one data\r\n     * data should be an object\r\n     * @param data\r\n     */\r\n    setItem(data) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        store.add(data);\r\n\r\n        store.onsuccess = function (event) {\r\n            console.log('Data write succeeded');\r\n        };\r\n\r\n        store.onerror = function (event) {\r\n            console.log('Data write failed');\r\n        }\r\n    }\r\n\r\n    /***\r\n     * add more than one data\r\n     * data should be array\r\n     * @param items\r\n     */\r\n    setItems(items){\r\n        var store = this.getStoreByName(this.storeName);\r\n        for(var i = 0; i < items.length; i++){\r\n            store.put(items[i]);\r\n        }\r\n    }\r\n\r\n    /***\r\n     * Get a piece of data by key value\r\n     * @param key  Index name\r\n     * @param value\r\n     */\r\n    getItem (key, value) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var index = store.index(key);\r\n        var request = index.get(value);\r\n\r\n        request.onsuccess = function( e) {\r\n            if ( request.result) {\r\n                console.log(request.result);\r\n            } else {\r\n                console.log('未获得数据记录');\r\n            }\r\n        };\r\n    }\r\n\r\n    /***\r\n     * get all items\r\n     */\r\n    getAllItems() {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var request = store.openCursor();\r\n\r\n        request.onsuccess = function (event) {\r\n            var cursor = event.target.result;\r\n\r\n            if (cursor) {\r\n                console.log(cursor.value);\r\n                cursor.continue();\r\n            } else {\r\n                console.log('没有更多数据了！');\r\n            }\r\n        };\r\n    }\r\n\r\n    /***\r\n     * update data\r\n     * @param newItem\r\n     */\r\n    update(newItem) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        store.put(newItem);\r\n\r\n        store.onsuccess = function (event) {\r\n            console.log('data update success');\r\n        };\r\n\r\n        store.onerror = function (event) {\r\n            console.log('data update failed');\r\n        }\r\n    }\r\n\r\n    clear () {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var request = store.clear();\r\n\r\n        request.onsuccess = function (event) {\r\n            console.log('clear Success');\r\n        };\r\n        request.onerror = function (event) {\r\n            console.log('clear Error');\r\n        };\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * This is the common logic for both the Node.js and web browser implementations of `debug()`.\r\n */\r\nmodule.exports = function setup(env) {\r\n    createDebug.debug = createDebug['default'] = createDebug;\r\n    createDebug.coerce = coerce;\r\n    createDebug.disable = disable;\r\n    createDebug.enable = enable;\r\n    createDebug.enabled = enabled;\r\n    createDebug.sessionStorageSave = sessionStorageSave();\r\n    createDebug.enabledLocalLog = enabledLocalLog;\r\n    createDebug.enableLocalLog = enableLocalLog;\r\n    createDebug.disableLocalLog = disableLocalLog;\r\n    createDebug.getLocalLogs = getLocalLogs;\r\n    createDebug.getLocalDBName = getLocalDBName;\r\n    createDebug.exportLog = exportLog;\r\n\r\n    //The currently state of Local Log.\r\n    createDebug.localLogState = true;\r\n    createDebug.createdDBList = false; //marked the DB List is saved.\r\n    createDebug.logBuffer = [];\r\n\r\n    // Function is converted to a function under createDebug, eg useColors、formatArgs ect.\r\n    Object.keys(env).forEach(function(key) {\r\n        createDebug[key] = env[key];\r\n    });\r\n\r\n    // create dataBase\r\n    createDebug.dataBaseListDB = new self.DBmanager('DatabaseLists', \"keyvaluepairs\", 1, [\"dbName\", \"TS\"]);\r\n    createDebug.localLogsDB = new self.DBmanager(env.sessionStorage.dbName, \"localLogs\", 1, [\"cseqNumber\", \"moduleName\", \"logLevel\", \"TS\", \"content\"]);\r\n    createDebug.dataBaseListDB.openDB();\r\n    createDebug.localLogsDB.openDB();\r\n\r\n\r\n   // Active `debug` instances.\r\n    createDebug.instances = [ ];\r\n    // The currently active debug mode names, and names to skip.\r\n    createDebug.names = [ ];\r\n    createDebug.skips = [ ];\r\n\r\n\r\n     // Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n     // Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n    createDebug.formatters = { };\r\n\r\n    /**\r\n     * Select a color.\r\n     * @param {String} namespace\r\n     * @return {Number}\r\n     * @api private\r\n     */\r\n    function selectColor(namespace) {\r\n        var hash = 0, i;\r\n\r\n        for (i in namespace) {\r\n            hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\r\n            hash |= 0; // Convert to 32bit integer\r\n        }\r\n\r\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n    }\r\n    createDebug.selectColor = selectColor;\r\n\r\n    /**\r\n     * Select a background color.\r\n     * @param {String} namespace\r\n     * @return {Number}\r\n     * @api private\r\n     */\r\n\r\n    function selectBGColor(namespace) {\r\n        var hash = 0, i;\r\n\r\n        var level = namespace.match(/:(\\w+)/)[1];\r\n        switch (level) {\r\n        case 'DEBUG':\r\n            i = 0;\r\n            break;\r\n        case 'LOG':\r\n            i = 1;\r\n            break;\r\n        case 'INFO':\r\n            i = 2;\r\n            break;\r\n        case 'WARN':\r\n            i = 3;\r\n            break;\r\n        case 'ERROR':\r\n            i = 4;\r\n            break;\r\n        case 'FATAL':\r\n            i = 5;\r\n            break;\r\n        default:\r\n            i = 2;\r\n            break;\r\n        }\r\n\r\n        return createDebug.bgColors[i];\r\n    }\r\n    createDebug.selectBGColor = selectBGColor;\r\n\r\n    function destroy() {\r\n        var index = createDebug.instances.indexOf(this);\r\n        if (index !== -1) {\r\n            createDebug.instances.splice(index, 1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a debug mode by namespaces. This can include modes\r\n     * separated by a colon and wildcards.\r\n     *\r\n     * @param {String} namespaces\r\n     * @api public\r\n     */\r\n    function enable(namespaces) {\r\n        createDebug.save(namespaces);\r\n\r\n        createDebug.names = [ ];\r\n        createDebug.skips = [ ];\r\n\r\n        var i;\r\n        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n        var len = split.length;\r\n\r\n        for (i = 0; i < len; i++) {\r\n            if (!split[i]) continue; // ignore empty strings\r\n            namespaces = split[i].replace(/\\*/g, '.*?');\r\n            if (namespaces[0] === '-') {\r\n                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\r\n            } else {\r\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < createDebug.instances.length; i++) {\r\n            var instance = createDebug.instances[i];\r\n            instance.enabled = createDebug.enabled(instance.namespace);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable debug output.\r\n     *\r\n     * @api public\r\n     */\r\n\r\n    function disable() {\r\n        createDebug.enable('');\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given mode name is enabled, false otherwise.\r\n     *\r\n     * @param {String} name\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n\r\n    function enabled(name) {\r\n        if (name[name.length - 1] === '*') {\r\n            return true;\r\n        }\r\n        var i, len;\r\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n            if (createDebug.skips[i].test(name)) {\r\n                return false;\r\n            }\r\n        }\r\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\r\n            if (createDebug.names[i].test(name)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Create a debugger with the given `namespace`.\r\n     * @param {String} namespace\r\n     * @return {Function}\r\n     * @api public\r\n     */\r\n    function createDebug(namespace) {\r\n        //var prevTime;\r\n        function debug() {\r\n\r\n            var date = new Date();\r\n            // turn the `arguments` into a proper Array\r\n            var args = new Array(arguments.length);\r\n            for (var i = 0; i < args.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n            args[0] = createDebug.coerce(args[0]);\r\n\r\n            if ('string' !== typeof args[0]) {\r\n                // anything else let's inspect with %O\r\n                args.unshift('%O');\r\n            }\r\n\r\n            if (createDebug.localLogState === true) {\r\n                //Save log into localforage whatever debug is disabled or not.\r\n                var logTime = beautyDate(date);\r\n                var logList = {\r\n                    cseqNumber: createDebug.logIndex,\r\n                    moduleName: namespace.split(\":\")[0],\r\n                    logLevel: namespace.split(\":\")[1],\r\n                    TS: (new Date()).getTime(),\r\n                    content: argsToString(args)\r\n                }\r\n\r\n                createDebug.logBuffer.push(logList);\r\n\r\n                // To avoid writing too often, write data to the database for every 20 data.\r\n                if (createDebug.logBuffer.length >= 20) {\r\n                    createDebug.localLogsDB.setItems(createDebug.logBuffer);\r\n                    createDebug.logBuffer = [ ];\r\n\r\n                    // save the databaseName into DatabaseLists database if not exist\r\n                    if (!createDebug.createdDBList) {\r\n                        var key = env.sessionStorage.dbName;\r\n                        var store = createDebug.dataBaseListDB.getStoreByName();\r\n                        var request = store.index('dbName').get(key);\r\n                        var infoJson = {};\r\n\r\n                        request.onsuccess = function( e) {\r\n                            if ( !request.result) {\r\n                                infoJson = {\r\n                                    TS: [ (new Date()).getTime() ],\r\n                                    dbName: env.sessionStorage.dbName,\r\n                                    data: {\r\n                                        confID: env.sessionStorage.confID,\r\n                                        userName: self.localStorage.userName,\r\n                                        email: self.localStorage.email\r\n                                    }\r\n                                };\r\n                            } else {\r\n                                infoJson = request.result;\r\n                                var ts = request.result.TS;\r\n                                if (ts) {\r\n                                    infoJson.TS.push((new Date()).getTime());\r\n                                }\r\n                            }\r\n                            createDebug.dataBaseListDB.update(infoJson);\r\n                            createDebug.createdDBList = true;\r\n                        };\r\n                    }\r\n                }\r\n                createDebug.logIndex++;\r\n\r\n                self.logIndex = createDebug.logIndex;\r\n                self.sessionStorage.dbIndex = self.logIndex;\r\n            }\r\n\r\n            // apply env-specific formatting (colors, etc.)\r\n            if (debug.enabled){\r\n            createDebug.logFormatters(args, debug)\r\n            }\r\n        }\r\n\r\n        debug.namespace = namespace;\r\n        debug.enabled = createDebug.enabled(namespace);\r\n        debug.useColors = createDebug.useColors();\r\n        debug.color = selectColor(namespace);\r\n        debug.bgColor = selectBGColor(namespace);\r\n        debug.destroy = destroy;\r\n\r\n        // env-specific initialization logic for debug instances\r\n        if ('function' === typeof createDebug.init) {\r\n            createDebug.init(debug);\r\n        }\r\n\r\n        createDebug.instances.push(debug);\r\n        return debug;\r\n    }\r\n\r\n    /**\r\n     * Log formatted output, add color, etc.\r\n     * @param args\r\n     * @param debug\r\n     */\r\n    function logFormatters(args, debug) {\r\n        var self = debug;\r\n        var index = 0;\r\n\r\n        args[0] = args[0].replace(/%[a-zA-Z%]/g,function(match, format) {\r\n            // if we encounter an escaped % then don't increase the array index\r\n            if (match === '%%') return match;\r\n            index++;\r\n            var formatter = createDebug.formatters[format];\r\n            if ('function' === typeof formatter) {\r\n                var val = args[index];\r\n                match = formatter.call(self, val);\r\n\r\n                // now we need to remove `args[index]` since it's inlined in the `format`\r\n                args.splice(index, 1);\r\n                index--;\r\n            }\r\n            return match;\r\n        });\r\n\r\n        // apply env-specific formatting (colors, etc.)\r\n        createDebug.formatArgs.call(self, args);\r\n\r\n        var logFn = self.log || createDebug.log;\r\n        logFn.apply(self, args);\r\n    }\r\n    createDebug.logFormatters = logFormatters;\r\n\r\n    /***\r\n     * 本地会话存储\r\n     */\r\n    function sessionStorageSave() {\r\n        var tabID = (env.sessionStorage.tabID && env.sessionStorage.closedLastTab !== '2') ? env.sessionStorage.tabID : (env.sessionStorage.tabID = Math.random().toString(36).substr(2));\r\n\r\n        env.sessionStorage.closedLastTab = '2';\r\n        self.onunload = self.onbeforeunload = function() {\r\n            env.sessionStorage.closedLastTab = '1';\r\n        };\r\n\r\n        if (!env.sessionStorage.dbName || !env.sessionStorage.dbName.match(tabID) ) {\r\n            console.log(\"Create dbName !!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n            // env.sessionStorage.setItem(\"dbName\", \"db_\" + tabID);\r\n            env.sessionStorage.setItem(\"dbName\", tabID + \"_db\");\r\n            env.sessionStorage.setItem(\"dbIndex\", \"0\");\r\n        }\r\n\r\n        if (!env.sessionStorage.dbIndex) {\r\n            createDebug.logIndex = 0;\r\n        } else {\r\n            createDebug.logIndex = env.sessionStorage.dbIndex;\r\n        }\r\n        self.logIndex = createDebug.logIndex;\r\n    }\r\n\r\n    /**\r\n   * Enable LocalLog\r\n   *\r\n   * @api public\r\n   */\r\n    function enableLocalLog() {\r\n        createDebug.saveLocalLogState(true);\r\n        createDebug.localLogState = true;\r\n    }\r\n\r\n    /**\r\n     * Disable LocalLog.\r\n     *\r\n     * @api public\r\n     */\r\n\r\n    function disableLocalLog() {\r\n        createDebug.saveLocalLogState(false);\r\n        createDebug.localLogState = false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the LocalLog is enabled, false otherwise.\r\n     *\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n\r\n    function enabledLocalLog() {\r\n        return createDebug.localLogState;\r\n    }\r\n\r\n    /**\r\n     * Get the local log\r\n     *\r\n     * @param dbName\r\n     * @param {String} filter  {String} dbName (null means current\r\n     *        DB) {function} callback(logs)\r\n     * @param callback\r\n     * @return {Array} logs self.logs =\r\n     *         self.logs.filter(function(x){return (x !==\r\n     *         (undefined || null || ''));});\r\n     * @api public\r\n     */\r\n\r\n    function getLocalLogs(dbName, filter, callback) {\r\n        var localLogs = [];\r\n        var skips = [ ];\r\n        var names = [ ];\r\n        var db;\r\n\r\n        function enabled(name, skips, names) {\r\n            if (name[name.length - 1] === '*') {\r\n                return true;\r\n            }\r\n            var i, len;\r\n\r\n            for (i = 0, len = skips.length; i < len; i++) {\r\n                if (skips[i].test(name)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            for (i = 0, len = names.length; i < len; i++) {\r\n                if (names[i].test(name)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (dbName && dbName !== createDebug.sessionStorage.dbName) {\r\n            db = new self.DBmanager(dbName, \"localLogs\", 1, [\"cseqNumber\", \"moduleName\", \"logLevel\", \"TS\", \"content\"]);\r\n        } else {\r\n            db = createDebug.localLogsDB;\r\n        }\r\n        db.openDB();\r\n\r\n        if (filter !== '*') {\r\n            //Process filter\r\n            var i = 0;\r\n            var split = (typeof filter === 'string' ? filter : '').split(/[\\s,]+/);\r\n            var len = split.length;\r\n\r\n            for (i = 0; i < len; i++) {\r\n                if (!split[i]) continue; // ignore empty strings\r\n                filter = split[i].replace(/\\*/g, '.*?');\r\n                if (filter[0] === '-') {\r\n                    skips.push(new RegExp('^' + filter.substr(1) + '$'));\r\n                } else {\r\n                    names.push(new RegExp('^' + filter + '$'));\r\n                }\r\n            }\r\n\r\n            //Filter all keys\r\n            db.keys().then(function(keys) {\r\n                    for (var i = 0; i < keys.length; i++) {\r\n\r\n                        //Remove the logIndex first \"index-REALKEY\"\r\n                        var index = parseInt(keys[i]);\r\n                        var key = keys[i].substr(index.toString().length + 1);\r\n\r\n                        if (enabled(key, skips, names)) {\r\n                            db.getItem(keys[i]).then(function(log) {\r\n                                    var index = parseInt(log);\r\n                                    localLogs[index] = '[' + index + ']' + log.substr(index.toString().length) + \"\\r\\n\";\r\n                                }).catch(function(err) {})\r\n                        }\r\n                    }\r\n                }).catch(function(err) {});\r\n\r\n        } else {\r\n            var request = self.indexedDB.open(db.dbName);\r\n\r\n            request.onsuccess = function (e) {\r\n                var transaction = db.currentDB.transaction(db.storeName, 'readwrite');\r\n                var store = transaction.objectStore(db.storeName);\r\n\r\n                store.openCursor().onsuccess = function (event) {\r\n                    var cursor = event.target.result;\r\n\r\n                    if (cursor) {\r\n                        var string =  JSON.stringify(cursor.value);\r\n                        var cseqNumber  = cursor.value.cseqNumber;\r\n                        localLogs[cseqNumber] = '[' + cseqNumber + ']' + string + \"\\r\\n\";\r\n                        cursor.continue();\r\n                    } else {\r\n                        callback(localLogs);\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all Database name list\r\n     * @api public\r\n     */\r\n\r\n    function getLocalDBName(callback) {\r\n        var localDBs = [];\r\n        var request = self.indexedDB.open(createDebug.dataBaseListDB.dbName);\r\n\r\n        request.onsuccess = function (e) {\r\n            var dbName = createDebug.dataBaseListDB.storeName;\r\n            var transaction = createDebug.dataBaseListDB.currentDB.transaction(dbName, 'readwrite');\r\n            var objectStore = transaction.objectStore(dbName);\r\n            objectStore.openCursor().onsuccess = function (event) {\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    localDBs.push(cursor.value);\r\n                    cursor.continue();\r\n                } else {\r\n                    console.log('no more data!');\r\n                    callback(localDBs);\r\n                }\r\n            };\r\n            objectStore.openCursor().onerror = function (error) {\r\n                console.error(error)\r\n            }\r\n        }.bind(this);\r\n\r\n        request.onerror = function (e) {\r\n            console.log(e.currentTarget.error.message);\r\n        }.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Update the sipID and confSEQ in dbInformation in database\r\n     * \"DatabaseList\" .\r\n     * info should be { sipID: XXX, confSEQ: xxx, userName: aaa,\r\n     * email: bbb }\r\n     *\r\n     */\r\n    function updateConfInfo(confInfo) {\r\n        try {\r\n            var store = createDebug.dataBaseListDB.getStoreByName(createDebug.sessionStorage.dbName);\r\n            var index = store.index(\"dbName\");\r\n            var request = index.get(createDebug.sessionStorage.dbName);\r\n            var infoJson;\r\n\r\n            request.onsuccess = function( e) {\r\n                if ( request.result) {\r\n                    if (request.result != null && request.result !== \"[object Object]\") { //Todo: figure out why info is [object Object], when dbName is not exisit.\r\n                        infoJson = request.result;\r\n                        infoJson.data.confID = createDebug.sessionStorage.confID;\r\n                    } else {\r\n                        infoJson = {\r\n                            TS: [ (new Date()).getTime() ],\r\n                            dbName: createDebug.sessionStorage.dbName,\r\n                            data: {\r\n                                confID: createDebug.sessionStorage.confID,\r\n                                userName: self.localStorage.userName,\r\n                                email: self.localStorage.email\r\n                            }\r\n                        };\r\n                    }\r\n\r\n                    if (confInfo.sipID) {\r\n                        if (!infoJson.sipID) {\r\n                            infoJson.data.sipID = [ ];\r\n                        }\r\n                        infoJson.data.sipID.push(confInfo.sipID);\r\n                    }\r\n\r\n                    if (confInfo.confSEQ) {\r\n                        if (!infoJson.data.confSEQ) {\r\n                            infoJson.data.confSEQ = [ ];\r\n                        }\r\n                        infoJson.data.confSEQ.push(confInfo.confSEQ);\r\n                    }\r\n\r\n                    if (confInfo.userName) {\r\n                        infoJson.data.userName = confInfo.userName;\r\n                    }\r\n\r\n                    if (confInfo.email) {\r\n                        infoJson.data.email = confInfo.email;\r\n                    }\r\n\r\n                    if (confInfo.confTitle) {\r\n                        infoJson.data.confTitle = confInfo.confTitle;\r\n                    }\r\n\r\n                    createDebug.dataBaseListDB.update(infoJson);\r\n                    createDebug.createdDBList = true;\r\n                }\r\n            };\r\n        } catch (e) {}\r\n    }\r\n    createDebug.updateConfInfo = updateConfInfo;\r\n\r\n    /**\r\n     * Flush buffer into DB\r\n     *将缓冲区刷新到database里\r\n     */\r\n    function flushLogBuffer() {\r\n        try {\r\n            if (createDebug.logBuffer.length > 0) {\r\n                createDebug.logBuffer.push( createDebug.logBuffer);\r\n                createDebug.logBuffer = [ ];\r\n            }\r\n\r\n        } catch (e) {}\r\n    }\r\n    createDebug.flushLogBuffer = flushLogBuffer;\r\n\r\n    /**\r\n     * Coerce `val`.\r\n     *\r\n     * @param {Mixed} val\r\n     * @return {Mixed}\r\n     * @api private\r\n     */\r\n\r\n    function coerce(val) {\r\n        if (val instanceof Error) return val.stack || val.message;\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Export the local log\r\n     * 导出日志文件\r\n     * @api public\r\n     */\r\n\r\n    function exportLog() {\r\n\r\n        var fileName = 'meetingLog.txt';\r\n\r\n        debug.getLocalLogs(null, \"*\",\r\n           function(logs) {\r\n               if ( navigator.userAgent.match('(rv:11.0|Edge)') ) {\r\n                   /*IE 11 or Edge*/\r\n\r\n                   var log_file;\r\n                   try {\r\n                       log_file = new Blob(logs, { type: 'text/plain' });\r\n                   } catch (e) {\r\n                       // Old browser, need to use blob builder\r\n                       self.BlobBuilder = self.BlobBuilder || self.MSBlobBuilder;\r\n                       if (self.BlobBuilder) {\r\n                           var tmp = new BlobBuilder('text/plain');\r\n                           tmp.append(logs);\r\n                           log_file = tmp.getBlob();\r\n                       }\r\n\r\n                   }\r\n\r\n                   if (self.navigator && self.navigator.msSaveBlob) {\r\n                       self.navigator.msSaveBlob(log_file, fileName);\r\n                   }\r\n\r\n                   delete log_file;\r\n\r\n               } else {\r\n\r\n                   var log_file = new Blob(logs, { type: 'text/plain' });\r\n                   var b = document.createElement('a');\r\n                   var ev = document.createEvent('MouseEvents');\r\n                   ev.initEvent(\"click\", false, false);\r\n                   b.href = URL.createObjectURL(log_file);\r\n                   b.download = fileName;\r\n                   b.dispatchEvent(ev)\r\n\r\n                   delete b;\r\n                   delete log_file;\r\n               }\r\n           });\r\n    }\r\n\r\n    createDebug.enable(createDebug.load());\r\n\r\n    createDebug.localLogState = createDebug.loadLocalLogState() !== \"false\" ;\r\n\r\n    return createDebug;\r\n}\r\n\r\n},{\"sprintf-js\":2}],4:[function(require,module,exports){\r\n/**\r\n * This is the web browser implementation of `debug()`.   这是`debug()`的Web浏览器实现。\r\n */\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = 'undefined' != typeof chrome\r\n               && 'undefined' != typeof chrome.storage\r\n                  ? chrome.storage.local\r\n                  : localstorage();\r\nexports.log = log;\r\nexports.saveLocalLogState = saveLocalLogState;\r\nexports.loadLocalLogState = loadLocalLogState;\r\nexports.sessionStorage = self.sessionStorage;\r\n/*-------------------------------------------*/\r\n\r\nexports.colors = [\r\n    '#295288'\r\n   //'#46A7C9'\r\n    ];\r\n\r\n/**\r\n * Background Colors\r\n */\r\nexports.bgColors = [\r\n  'inherit', //DEBUG\r\n  'inherit', //LOG\r\n  '#46A7C9', //INFO\r\n  '#D08005;font-size:14px', //WARN\r\n  '#F64863;font-size:16px', //ERROR\r\n  '#F64863;font-size:18px'  //FATAL\r\n];\r\n\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n\r\nfunction useColors() {\r\n  // NB: In an Electron preload script, document will be defined but not fully\r\n  // initialized. Since we know we're in Chrome, we'll just detect this case\r\n  // explicitly\r\n  if (typeof window !== 'undefined' && self.process && self.process.type === 'renderer') {\r\n    return true;\r\n  }\r\n\r\n  // Internet Explorer do not support colors.\r\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/trident\\/(\\d+)/)) {\r\n      return false;\r\n  }\r\n\r\n  // Rzhang: Edge supports colors since 16215\r\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/edge\\/(\\d+)/)\r\n      && (parseInt(navigator.userAgent.toLowerCase().match(/edge\\/\\d+.(\\d+)/)[1]) < 16215)) {\r\n      return false;\r\n  }\r\n\r\n  // is webkit? http://stackoverflow.com/a/16459606/376773\r\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\r\n    // is firebug? http://stackoverflow.com/a/398120/376773\r\n    (typeof window !== 'undefined' && self.console && (self.console.firebug || (self.console.exception && self.console.table))) ||\r\n    // is firefox >= v31?\r\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\r\n    // double check webkit in userAgent just in case we are in a worker\r\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\r\n}\r\n\r\n/**\r\n * Colorize log arguments if enabled.\r\n * @api public\r\n */\r\n\r\nfunction formatArgs(args) {\r\n  var useColors = this.useColors;\r\n\r\n  args[0] = (useColors ? '%c' : '')\r\n    + this.namespace\r\n    + (useColors ? ' %c' : ' ')\r\n    + args[0]\r\n    + (useColors ? '%c ' : ' ');\r\n    //+ '+' + module.exports.humanize(this.diff);\r\n\r\n  if (!useColors) return;\r\n\r\n  var c = 'color: ' + this.color;\r\n  args.splice(1, 0, c, 'color: ' + this.bgColor)\r\n\r\n  // the final \"%c\" is somewhat tricky, because there could be other\r\n  // arguments passed either before or after the %c, so we need to\r\n  // figure out the correct index to insert the CSS into\r\n  var index = 0;\r\n  var lastC = 0;\r\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\r\n    if ('%%' === match) return;\r\n    index++;\r\n    if ('%c' === match) {\r\n      // we only are interested in the *last* %c\r\n      // (the user may have provided their own)\r\n      lastC = index;\r\n    }\r\n  });\r\n\r\n  args.splice(lastC, 0, c);\r\n}\r\n\r\n/**\r\n * Invokes `console.log()` when available.\r\n * No-op when `console.log` is not a \"function\".\r\n *\r\n * @api public\r\n */\r\n\r\nfunction log() {\r\n  // this hackery is required for IE8/9, where\r\n  // the `console.log` function doesn't have 'apply'\r\n  if (this.bgColor !== debug.bgColors[4]) {\r\n    return 'object' === typeof console\r\n    && console.log\r\n    && Function.prototype.apply.call(console.log, console, arguments);\r\n  } else {\r\n    return 'object' === typeof console\r\n           && console.error\r\n           && Function.prototype.apply.call(console.error, console, arguments);\r\n\r\n  }\r\n}\r\n\r\n/**\r\n * Save `namespaces`.\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\n\r\nfunction save(namespaces) {\r\n  try {\r\n    if (null == namespaces) {\r\n      exports.storage.removeItem('debug');\r\n    } else {\r\n      exports.storage.debug = namespaces;\r\n    }\r\n  } catch(e) {}\r\n}\r\n\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\n\r\nfunction load() {\r\n  var r;\r\n  try {\r\n    r = exports.storage.debug;\r\n  } catch(e) {}\r\n\r\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n  //if (!r && typeof process !== 'undefined' && 'env' in process) {\r\n  //  r = process.env.DEBUG;\r\n  //}\r\n\r\n  if ( !r ) {\r\n      //Set default namespaces\r\n      r = '*:INFO,*:WARN,*:ERROR';\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/**\r\n * Save LocalLog enable state.\r\n * @param {Bool} state\r\n * @api private\r\n */\r\nfunction saveLocalLogState(state) {\r\n  try {\r\n    if (null == state || state != false) {\r\n      exports.storage.setItem('localLog', true);\r\n    } else {\r\n      exports.storage.setItem('localLog', false);\r\n    }\r\n  } catch (e) {\r\n  }\r\n}\r\n\r\n/**\r\n * Load `localLog` setting.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\n\r\nfunction loadLocalLogState() {\r\n  var r = true;\r\n  try {\r\n      r = exports.storage.localLog;\r\n  } catch (e) {\r\n  }\r\n\r\n  // If debug isn't set in LS\r\n  if (!r ) {\r\n    r = true;\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\nfunction localstorage() {\r\n  try {\r\n    return self.localStorage;\r\n  } catch (e) {}\r\n}\r\n\r\nmodule.exports = require('./common')(exports);\r\n\r\nvar formatters = module.exports.formatters;\r\n\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function(v) {\r\n  try {\r\n    return JSON.stringify(v);\r\n  } catch (err) {\r\n    return '[UnexpectedJSONParseError]: ' + err.message;\r\n  }\r\n};\r\n\r\n},{\"./common\":3}]},{},[4])(4)\r\n});\n/***\r\n * Function that get the version of each browser that uses replaceTrack\r\n * @returns\r\n */\r\nfunction isReplaceTrackSupport() {\r\n    var version = adapter.browserDetails.version\r\n    var result = false\r\n\r\n    switch (adapter.browserDetails.browser) {\r\n        case 'chrome':\r\n            result = version >= 72\r\n            break\r\n        case 'opera':\r\n            result = version >= 59\r\n            break\r\n        case 'firefox':\r\n            result = version >= 59\r\n            break\r\n        case 'safari':\r\n            version = adapter.browserDetails.UIVersion\r\n            result = version >= '12.1.1'\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    return result\r\n}\r\n\r\nfunction closeStream(stream) {\r\n    if(!stream){\r\n        return\r\n    }\r\n    try {\r\n        var tracks = stream.getTracks();\r\n        for (var track in tracks) {\r\n            tracks[track].onended = null;\r\n            log.info(\"close stream\");\r\n            tracks[track].stop();\r\n        }\r\n    }\r\n    catch (error) {\r\n        log.info('closeStream: Failed to close stream');\r\n        log.error(error);\r\n    }\r\n}\r\n\r\n/***\r\n * JS 数据类型判断\r\n * @param data\r\n * @returns {string}\r\n */\r\nfunction typeJudgement(data) {\r\n    let type = Object.prototype.toString.call(data)\r\n    let endIndex = type.indexOf(']')\r\n    let result = type.substring(8, endIndex).toLocaleLowerCase()\r\n    console.log(\"current match case: \", result)\r\n    return result\r\n}\r\n\r\n/***\r\n * 判断字符串是否为Json\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nfunction isJsonString(str) {\r\n    try {\r\n        if (typeof JSON.parse(str) == \"object\") {\r\n            return true;\r\n        }\r\n    } catch(e) {\r\n    }\r\n    return false;\r\n}\r\n\r\n/***\r\n * 页面内内容输出\r\n * @param message\r\n */\r\nfunction writeToScreen(message) {\r\n    let parent = document.getElementById('output');\r\n    let newChild = document.createElement(\"div\");\r\n    newChild.innerHTML = message;\r\n    parent.appendChild(newChild);\r\n}\r\n\r\n/***\r\n * 当前时间格式化处理\r\n */\r\nfunction formatDate(now) {\r\n    let year = now.getFullYear();\r\n    let month = now.getMonth() + 1;\r\n    let date = now.getDate();\r\n    let hour = now.getHours();\r\n    let minute = now.getMinutes();\r\n    let second = now.getSeconds();\r\n    return year + \"-\" + (month = month < 10 ? (\"0\" + month) : month) + \"-\" + (date = date < 10 ? (\"0\" + date) : date) + \" \" + (hour = hour < 10 ? (\"0\" + hour) : hour) + \":\" + (minute = minute < 10 ? (\"0\" + minute) : minute) + \":\" + (second = second < 10 ? (\"0\" + second) : second);\r\n}\nconst grammar = {\r\n    v: [ {\r\n        name: 'version',\r\n        reg: /^(\\d*)$/\r\n    } ],\r\n    o: [ {\r\n        // o=- 20518 0 IN IP4 203.0.113.1\r\n        // NB: sessionId will be a String in most cases because it is huge\r\n        name: 'origin',\r\n        reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\r\n        names: [ 'username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address' ],\r\n        format: '%s %s %d %s IP%d %s'\r\n    } ],\r\n    // default parsing of these only (though some of these feel outdated)\r\n    s: [ { name: 'name' } ],\r\n    i: [ { name: 'description' } ],\r\n    u: [ { name: 'uri' } ],\r\n    e: [ { name: 'email' } ],\r\n    p: [ { name: 'phone' } ],\r\n    z: [ { name: 'timezones' } ], // TODO: this one can actually be parsed properly...\r\n    r: [ { name: 'repeats' } ],   // TODO: this one can also be parsed properly\r\n    // k: [{}], // outdated thing ignored\r\n    t: [ {\r\n        // t=0 0\r\n        name: 'timing',\r\n        reg: /^(\\d*) (\\d*)/,\r\n        names: [ 'start', 'stop' ],\r\n        format: '%d %d'\r\n    } ],\r\n    c: [ {\r\n        // c=IN IP4 10.47.197.26\r\n        name: 'connection',\r\n        reg: /^IN IP(\\d) (\\S*)/,\r\n        names: [ 'version', 'ip' ],\r\n        format: 'IN IP%d %s'\r\n    } ],\r\n    b: [ {\r\n        // b=AS:4000\r\n        push: 'bandwidth',\r\n        reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\r\n        names: [ 'type', 'limit' ],\r\n        format: '%s:%s'\r\n    } ],\r\n    m: [ {\r\n        // m=video 51744 RTP/AVP 126 97 98 34 31\r\n        // NB: special - pushes to session\r\n        // TODO: rtp/fmtp should be filtered by the payloads found here?\r\n        reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\r\n        names: [ 'type', 'port', 'protocol', 'payloads' ],\r\n        format: '%s %d %s %s'\r\n    } ],\r\n    a: [\r\n    {\r\n        // a=rtpmap:110 opus/48000/2\r\n        push: 'rtp',\r\n        reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\r\n        names: [ 'payload', 'codec', 'rate', 'encoding' ],\r\n        format: function(o) {\r\n            return (o.encoding)\r\n                   ? 'rtpmap:%d %s/%s/%s'\r\n                   : o.rate\r\n                   ? 'rtpmap:%d %s/%s'\r\n                   : 'rtpmap:%d %s';\r\n        }\r\n    },\r\n    {\r\n        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\r\n        // a=fmtp:111 minptime=10; useinbandfec=1\r\n        push: 'fmtp',\r\n        reg: /^fmtp:(\\d*) ([\\S| ]*)/,\r\n        names: [ 'payload', 'config' ],\r\n        format: 'fmtp:%d %s'\r\n    },\r\n    {\r\n        // a=control:streamid=0\r\n        name: 'control',\r\n        reg: /^control:(.*)/,\r\n        format: 'control:%s'\r\n    },\r\n    {\r\n        // a=rtcp:65179 IN IP4 193.84.77.194\r\n        name: 'rtcp',\r\n        reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\r\n        names: [ 'port', 'netType', 'ipVer', 'address' ],\r\n        format: function(o) {\r\n            return (o.address != null)\r\n                   ? 'rtcp:%d %s IP%d %s'\r\n                   : 'rtcp:%d';\r\n        }\r\n    },\r\n    {\r\n        // a=rtcp-fb:98 trr-int 100\r\n        push: 'rtcpFbTrrInt',\r\n        reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\r\n        names: [ 'payload', 'value' ],\r\n        format: 'rtcp-fb:%d trr-int %d'\r\n    },\r\n    {\r\n        // a=rtcp-fb:98 nack rpsi\r\n        push: 'rtcpFb',\r\n        reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\r\n        names: [ 'payload', 'type', 'subtype' ],\r\n        format: function(o) {\r\n            return (o.subtype != null)\r\n                   ? 'rtcp-fb:%s %s %s'\r\n                   : 'rtcp-fb:%s %s';\r\n        }\r\n    },\r\n    {\r\n        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n        // a=extmap:1/recvonly URI-gps-string\r\n        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\r\n        push: 'ext',\r\n        reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\r\n        names: [ 'value', 'direction', 'encrypt-uri', 'uri', 'config' ],\r\n        format: function(o) {\r\n            return (\r\n                'extmap:%d' +\r\n                (o.direction ? '/%s' : '%v') +\r\n                (o['encrypt-uri'] ? ' %s' : '%v') +\r\n                ' %s' +\r\n                (o.config ? ' %s' : '')\r\n                );\r\n        }\r\n    },\r\n    {\r\n        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\r\n        push: 'crypto',\r\n        reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\r\n        names: [ 'id', 'suite', 'config', 'sessionConfig' ],\r\n        format: function(o) {\r\n            return (o.sessionConfig != null)\r\n                   ? 'crypto:%d %s %s %s'\r\n                   : 'crypto:%d %s %s';\r\n        }\r\n    },\r\n    {\r\n        // a=setup:actpass\r\n        name: 'setup',\r\n        reg: /^setup:(\\w*)/,\r\n        format: 'setup:%s'\r\n    },\r\n    {\r\n        // a=connection:new\r\n        name: 'connectionType',\r\n        reg: /^connection:(new|existing)/,\r\n        format: 'connection:%s'\r\n    },\r\n    {\r\n        // a=mid:1\r\n        name: 'mid',\r\n        reg: /^mid:([^\\s]*)/,\r\n        format: 'mid:%s'\r\n    },\r\n    {\r\n        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\r\n        name: 'msid',\r\n        reg: /^msid:(\\S*) (\\S*)/,\r\n        names: [ 'msid', 'trackid' ],\r\n        format: 'msid:%s %s'\r\n    },\r\n    {\r\n        // a=ptime:20\r\n        name: 'ptime',\r\n        reg: /^ptime:(\\d*)/,\r\n        format: 'ptime:%d'\r\n    },\r\n    {\r\n        // a=maxptime:60\r\n        name: 'maxptime',\r\n        reg: /^maxptime:(\\d*)/,\r\n        format: 'maxptime:%d'\r\n    },\r\n    {\r\n        // a=sendrecv\r\n        name: 'direction',\r\n        reg: /^(sendrecv|recvonly|sendonly|inactive)/\r\n    },\r\n    {\r\n        // a=ice-lite\r\n        name: 'icelite',\r\n        reg: /^(ice-lite)/\r\n    },\r\n    {\r\n        // a=ice-ufrag:F7gI\r\n        name: 'iceUfrag',\r\n        reg: /^ice-ufrag:(\\S*)/,\r\n        format: 'ice-ufrag:%s'\r\n    },\r\n    {\r\n        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\r\n        name: 'icePwd',\r\n        reg: /^ice-pwd:(\\S*)/,\r\n        format: 'ice-pwd:%s'\r\n    },\r\n    {\r\n        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\r\n        name: 'fingerprint',\r\n        reg: /^fingerprint:(\\S*) (\\S*)/,\r\n        names: [ 'type', 'hash' ],\r\n        format: 'fingerprint:%s %s'\r\n    },\r\n    {\r\n        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\r\n        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\r\n        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\r\n        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\r\n        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\r\n        push: 'candidates',\r\n        reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\r\n        names: [ 'foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost' ],\r\n        format: function(o) {\r\n            var str = 'candidate:%s %d %s %d %s %d typ %s';\r\n\r\n            str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\r\n\r\n            // NB: candidate has three optional chunks, so %void middles one if it's missing\r\n            str += (o.tcptype != null) ? ' tcptype %s' : '%v';\r\n\r\n            if ( o.generation != null ) {\r\n                str += ' generation %d';\r\n            }\r\n\r\n            str += (o['network-id'] != null) ? ' network-id %d' : '%v';\r\n            str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\r\n            return str;\r\n        }\r\n    },\r\n    {\r\n        // a=end-of-candidates (keep after the candidates line for readability)\r\n        name: 'endOfCandidates',\r\n        reg: /^(end-of-candidates)/\r\n    },\r\n    {\r\n        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\r\n        name: 'remoteCandidates',\r\n        reg: /^remote-candidates:(.*)/,\r\n        format: 'remote-candidates:%s'\r\n    },\r\n    {\r\n        // a=ice-options:google-ice\r\n        name: 'iceOptions',\r\n        reg: /^ice-options:(\\S*)/,\r\n        format: 'ice-options:%s'\r\n    },\r\n    {\r\n        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\r\n        push: 'ssrcs',\r\n        reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\r\n        names: [ 'id', 'attribute', 'value' ],\r\n        format: function(o) {\r\n            var str = 'ssrc:%d';\r\n            if ( o.attribute != null ) {\r\n                str += ' %s';\r\n                if ( o.value != null ) {\r\n                    str += ':%s';\r\n                }\r\n            }\r\n            return str;\r\n        }\r\n    },\r\n    {\r\n        // a=ssrc-group:FEC 1 2\r\n        // a=ssrc-group:FEC-FR 3004364195 1080772241\r\n        push: 'ssrcGroups',\r\n        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\r\n        reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\r\n        names: [ 'semantics', 'ssrcs' ],\r\n        format: 'ssrc-group:%s %s'\r\n    },\r\n    {\r\n        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\r\n        push: 'msidSemantics', /*Modified by rzhang, for merge/split SDP*/\r\n        //name: 'msidSemantic',\r\n        reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\r\n        names: [ 'semantic', 'token' ],\r\n        format: 'msid-semantic: %s %s' // space after ':' is not accidental\r\n    },\r\n    {\r\n        // a=group:BUNDLE audio video\r\n        push: 'groups',\r\n        reg: /^group:(\\w*) (.*)/,\r\n        names: [ 'type', 'mids' ],\r\n        format: 'group:%s %s'\r\n    },\r\n    {\r\n        // a=rtcp-mux\r\n        name: 'rtcpMux',\r\n        reg: /^(rtcp-mux)/\r\n    },\r\n    {\r\n        // a=rtcp-rsize\r\n        name: 'rtcpRsize',\r\n        reg: /^(rtcp-rsize)/\r\n    },\r\n    {\r\n        // a=sctpmap:5000 webrtc-datachannel 1024\r\n        name: 'sctpmap',\r\n        reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\r\n        names: [ 'sctpmapNumber', 'app', 'maxMessageSize' ],\r\n        format: function(o) {\r\n            return (o.maxMessageSize != null)\r\n                   ? 'sctpmap:%s %s %s'\r\n                   : 'sctpmap:%s %s';\r\n        }\r\n    },\r\n    {\r\n        // a=x-google-flag:conference\r\n        name: 'xGoogleFlag',\r\n        reg: /^x-google-flag:([^\\s]*)/,\r\n        format: 'x-google-flag:%s'\r\n    },\r\n    {\r\n        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\r\n        push: 'rids',\r\n        reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\r\n        names: [ 'id', 'direction', 'params' ],\r\n        format: function(o) {\r\n            return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\r\n        }\r\n    },\r\n    {\r\n        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\r\n        // a=imageattr:* send [x=800,y=640] recv *\r\n        // a=imageattr:100 recv [x=320,y=240]\r\n        push: 'imageattrs',\r\n        reg: new RegExp(\r\n            // a=imageattr:97\r\n            '^imageattr:(\\\\d+|\\\\*)' +\r\n            // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\r\n            '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\r\n            // recv [x=330,y=250]\r\n            '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\r\n            ),\r\n        names: [ 'pt', 'dir1', 'attrs1', 'dir2', 'attrs2' ],\r\n        format: function(o) {\r\n            return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\r\n        }\r\n    },\r\n    {\r\n        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\r\n        // a=simulcast:recv 1;4,5 send 6;7\r\n        name: 'simulcast',\r\n        reg: new RegExp(\r\n            // a=simulcast:\r\n            '^simulcast:' +\r\n            // send 1,2,3;~4,~5\r\n            '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\r\n            // space + recv 6;~7,~8\r\n            '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\r\n            // end\r\n            '$'\r\n            ),\r\n        names: [ 'dir1', 'list1', 'dir2', 'list2' ],\r\n        format: function(o) {\r\n            return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\r\n        }\r\n    },\r\n    {\r\n        // old simulcast draft 03 (implemented by Firefox)\r\n        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\r\n        // a=simulcast: recv pt=97;98 send pt=97\r\n        // a=simulcast: send rid=5;6;7 paused=6,7\r\n        name: 'simulcast_03',\r\n        reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\r\n        names: [ 'value' ],\r\n        format: 'simulcast: %s'\r\n    },\r\n    {\r\n        // a=framerate:25\r\n        // a=framerate:29.97\r\n        name: 'framerate',\r\n        reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\r\n        format: 'framerate:%s'\r\n    },\r\n    {\r\n        // RFC4570\r\n        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\r\n        name: 'sourceFilter',\r\n        reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\r\n        names: [ 'filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList' ],\r\n        format: 'source-filter: %s %s %s %s %s'\r\n    },\r\n    {\r\n        // a=bundle-only\r\n        name: 'bundleOnly',\r\n        reg: /^(bundle-only)/\r\n    },\r\n    {\r\n        // a=label:1\r\n        name: 'label',\r\n        reg: /^label:(.+)/,\r\n        format: 'label:%s'\r\n    },\r\n    {\r\n        // RFC version 26 for SCTP over DTLS\r\n        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\r\n        name: 'sctpPort',\r\n        reg: /^sctp-port:(\\d+)$/,\r\n        format: 'sctp-port:%s'\r\n    },\r\n    {\r\n        // RFC version 26 for SCTP over DTLS\r\n        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\r\n        name: 'maxMessageSize',\r\n        reg: /^max-message-size:(\\d+)$/,\r\n        format: 'max-message-size:%s'\r\n    },\r\n    {\r\n        // a=keywds:keywords\r\n        name: 'keywords',\r\n        reg: /^keywds:(.+)$/,\r\n        format: 'keywds:%s'\r\n    },\r\n    {\r\n        // RFC4796 The Content Attribute\r\n        // a=content:slides,main,sl,speaker\r\n        name: 'content',\r\n        reg: /^content:(.+)$/,\r\n        format: 'content:%s'\r\n    },\r\n    {\r\n        // any a= that we don't understand is kept verbatim on media.invalid\r\n        push: 'invalid',\r\n        names: [ 'value' ]\r\n    }\r\n        ]\r\n};\r\n// set sensible defaults to avoid polluting the grammar with boring details\r\nObject.keys(grammar).forEach(function(key) {\r\n        var objs = grammar[key];\r\n        objs.forEach(function(obj) {\r\n                if ( !obj.reg ) {\r\n                    obj.reg = /(.*)/;\r\n                }\r\n                if ( !obj.format ) {\r\n                    obj.format = '%s';\r\n                }\r\n            });\r\n    });\r\n\r\n// customized util.format - discards excess arguments and can void middle ones\r\nvar formatRegExp = /%[sdv%]/g;\r\nvar format = function(formatStr) {\r\n    var i = 1;\r\n    var args = arguments;\r\n    var len = args.length;\r\n    return formatStr.replace(formatRegExp, function(x) {\r\n            if ( i >= len ) {\r\n                return x; // missing argument\r\n            }\r\n            var arg = args[i];\r\n            i += 1;\r\n            switch ( x ) {\r\n                case '%%':\r\n                    return '%';\r\n                case '%s':\r\n                    return String(arg);\r\n                case '%d':\r\n                    return Number(arg);\r\n                case '%v':\r\n                    return '';\r\n            }\r\n        });\r\n    // NB: we discard excess arguments - they are typically undefined from makeLine\r\n};\r\n\r\nfunction getType(obj) {\r\n    if ( Object.prototype.toString.call(obj) == '[object Object]' ) {\r\n        return 'Object';\r\n    } else if ( Object.prototype.toString.call(obj) == '[object Array]' ) {\r\n        return 'Array';\r\n    } else {\r\n        return 'nomal';\r\n    }\r\n}\r\n\r\nfunction deepCopy(obj) {\r\n    if ( getType(obj) == 'nomal' ) {\r\n        return obj;\r\n    } else {\r\n        var newObj = getType(obj) == 'Object' ? { }\r\n            : [ ];\r\n        for ( var key in obj ) {\r\n            if ( obj.hasOwnProperty(key) ) {\r\n                newObj[key] = deepCopy(obj[key]);\r\n            }\r\n        }\r\n    }\r\n    return newObj;\r\n}\r\n\r\nvar makeLine = function(type, obj, location) {\r\n    var str = obj.format instanceof Function ?\r\n              (obj.format(obj.push ? location : location[obj.name])) :\r\n              obj.format;\r\n\r\n    var args = [ type + '=' + str ];\r\n    if ( obj.names ) {\r\n        for ( var i = 0; i < obj.names.length; i += 1 ) {\r\n            var n = obj.names[i];\r\n            if ( obj.name ) {\r\n                args.push(location[obj.name][n]);\r\n            } else { // for mLine and push attributes\r\n                args.push(location[obj.names[i]]);\r\n            }\r\n        }\r\n    } else {\r\n        args.push(location[obj.name]);\r\n    }\r\n    return format.apply(null, args);\r\n};\r\n\r\n// RFC specified order\r\n// TODO: extend this with all the rest\r\nvar defaultOuterOrder = [\r\n                        'v', 'o', 's', 'i',\r\n                        'u', 'e', 'p', 'c',\r\n                        'b', 't', 'r', 'z', 'a'\r\n                        ];\r\nvar defaultInnerOrder = [ 'i', 'c', 'b', 'a' ];\r\n\r\n\r\nvar toIntIfInt = function(v) {\r\n    return String(Number(v)) === v ? Number(v) : v;\r\n};\r\n\r\nvar attachProperties = function(match, location, names, rawName) {\r\n    if ( rawName && !names ) {\r\n        location[rawName] = toIntIfInt(match[1]);\r\n    } else {\r\n        for ( var i = 0; i < names.length; i += 1 ) {\r\n            if ( match[i + 1] != null ) {\r\n                location[names[i]] = toIntIfInt(match[i + 1]);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar parseReg = function(obj, location, content) {\r\n    var needsBlank = obj.name && obj.names;\r\n    if ( obj.push && !location[obj.push] ) {\r\n        location[obj.push] = [ ];\r\n    } else if ( needsBlank && !location[obj.name] ) {\r\n        location[obj.name] = { };\r\n    }\r\n    var keyLocation = obj.push ?\r\n    { }\r\n        :  // blank object that will be pushed\r\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\r\n\r\n    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\r\n\r\n    if ( obj.push ) {\r\n        location[obj.push].push(keyLocation);\r\n    }\r\n};\r\n\r\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\r\n\r\nvar paramReducer = function(acc, expr) {\r\n    var s = expr.split(/=(.+)/, 2);\r\n    if ( s.length === 2 ) {\r\n        acc[s[0]] = toIntIfInt(s[1]);\r\n    } else if ( s.length === 1 && expr.length > 1 ) {\r\n        acc[s[0]] = undefined;\r\n    }\r\n    return acc;\r\n};\r\n\r\nvar SDPTools = {\r\n\r\n    midMap: new Array(), /*Save SDP mid mapping: msid:xxx(The original msid), mid:xx(The original mid), mappedMID:XX(The mapped mid)*/\r\n    msidMap: new Array(), /*Save SDP msid mapping: msid:xxx(The original msid), pcName:XXX(The mapped msid) */\r\n    sessionVersion: 0, /*SDP o line session version*/\r\n\r\n    writeSDP: function(session, opts) {\r\n        opts = opts || { };\r\n        // ensure certain properties exist\r\n        if ( session.version == null ) {\r\n            session.version = 0; // 'v=0' must be there (only defined version atm)\r\n        }\r\n        if ( session.name == null ) {\r\n            session.name = ' '; // 's= ' must be there if no meaningful name set\r\n        }\r\n        session.media.forEach(function(mLine) {\r\n                if ( mLine.payloads == null ) {\r\n                    mLine.payloads = '';\r\n                }\r\n            });\r\n\r\n        var outerOrder = opts.outerOrder || defaultOuterOrder;\r\n        var innerOrder = opts.innerOrder || defaultInnerOrder;\r\n        var sdp = [ ];\r\n\r\n        // loop through outerOrder for matching properties on session\r\n        outerOrder.forEach(function(type) {\r\n                grammar[type].forEach(function(obj) {\r\n                        if ( obj.name in session && session[obj.name] != null ) {\r\n                            sdp.push(makeLine(type, obj, session));\r\n                        } else if ( obj.push in session && session[obj.push] != null ) {\r\n                            session[obj.push].forEach(function(el) {\r\n                                    sdp.push(makeLine(type, obj, el));\r\n                                });\r\n                        }\r\n                    });\r\n            });\r\n\r\n        // then for each media line, follow the innerOrder\r\n        session.media.forEach(function(mLine) {\r\n                sdp.push(makeLine('m', grammar.m[0], mLine));\r\n\r\n                innerOrder.forEach(function(type) {\r\n                        grammar[type].forEach(function(obj) {\r\n                                if ( obj.name in mLine && mLine[obj.name] != null ) {\r\n                                    sdp.push(makeLine(type, obj, mLine));\r\n                                } else if ( obj.push in mLine && mLine[obj.push] != null ) {\r\n                                    mLine[obj.push].forEach(function(el) {\r\n                                            sdp.push(makeLine(type, obj, el));\r\n                                        });\r\n                                }\r\n                            });\r\n                    });\r\n            });\r\n\r\n        return sdp.join('\\r\\n') + '\\r\\n';\r\n    },\r\n\r\n    parseSDP: function(sdp) {\r\n        var session = { }, media = [ ]\r\n        , location = session; // points at where properties go under (one of the above)\r\n\r\n        // parse lines we understand\r\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\r\n                var type = l[0];\r\n                var content = l.slice(2);\r\n                if ( type === 'm' ) {\r\n                    media.push({ rtp: [ ], fmtp: [ ] });\r\n                    location = media[media.length - 1]; // point at latest media line\r\n                }\r\n\r\n                for ( var j = 0; j < (grammar[type] || [ ]).length; j += 1 ) {\r\n                    var obj = grammar[type][j];\r\n                    if ( obj.reg.test(content) ) {\r\n                        return parseReg(obj, location, content);\r\n                    }\r\n                }\r\n            });\r\n\r\n        session.media = media; // link it up\r\n        if ( this.sessionVersion <= 0 ) {\r\n            this.sessionVersion = session['origin']['sessionVersion'];\r\n        }\r\n        return session;\r\n    },\r\n\r\n    parseFmtpConfig: function(str) {\r\n        return str.split(/;\\s?/).reduce(paramReducer, { });\r\n    },\r\n\r\n    parsePayloads: function(str) {\r\n        return str.toString().split(' ').map(Number);\r\n    },\r\n\r\n    parseRemoteCandidates: function(str) {\r\n        var candidates = [ ];\r\n        var parts = str.split(' ').map(toIntIfInt);\r\n        for ( var i = 0; i < parts.length; i += 3 ) {\r\n            candidates.push({\r\n                component: parts[i],\r\n                ip: parts[i + 1],\r\n                port: parts[i + 2]\r\n            });\r\n        }\r\n        return candidates;\r\n    },\r\n\r\n    parseImageAttributes: function(str) {\r\n        return str.split(' ').map(function(item) {\r\n                return item.substring(1, item.length - 1).split(',').reduce(paramReducer, { });\r\n            });\r\n    },\r\n\r\n    parseSimulcastStreamList: function(str) {\r\n        return str.split(';').map(function(stream) {\r\n                return stream.split(',').map(function(format) {\r\n                        var scid, paused = false;\r\n\r\n                        if ( format[0] !== '~' ) {\r\n                            scid = toIntIfInt(format);\r\n                        } else {\r\n                            scid = toIntIfInt(format.substring(1, format.length));\r\n                            paused = true;\r\n                        }\r\n\r\n                        return {\r\n                            scid: scid,\r\n                            paused: paused\r\n                        };\r\n                    });\r\n            });\r\n    },\r\n\r\n    /*Set Media content type*/\r\n    setMediaContentType: function(session, index, contentType) {\r\n        if ( index < session.media.length ) {\r\n            session.media[index]['content'] = contentType;\r\n        } else {\r\n            log.log(\"Error index\");\r\n        }\r\n    },\r\n\r\n    /*Process bandwidth relative: b line and x-google-start-bitrate*/\r\n    setMediaBandwidth: function(session, index, bandwidth) {\r\n    },\r\n\r\n    /*Increase SDP Session version*/\r\n    increaseSessionVersion: function(session) {\r\n        if ( this.sessionVersion <= 0 ) {\r\n            this.sessionVersion = session['origin']['sessionVersion'];\r\n        }\r\n        this.sessionVersion += 1;\r\n        session['origin']['sessionVersion'] = this.sessionVersion;\r\n    },\r\n\r\n    /*payloads must be a array of NUMBERS*/\r\n    removeCodecByPayload: function(session, index, payloads) {\r\n        if ( index >= session.media.length ) {\r\n            log.log(\"Error index\");\r\n            return;\r\n        }\r\n\r\n        var mediaSession = session.media[index];\r\n\r\n        /*Check relative fmtp payload*/\r\n        for ( var i = 0; i < payloads.length; i += 1 ) {\r\n            for ( var j = 0; j < mediaSession.fmtp.length; j += 1 ) {\r\n\r\n                if ( mediaSession.fmtp[j].config.match(\"apt=\" + payloads[i]) != null ) {\r\n\r\n                    if ( payloads.indexOf(mediaSession.fmtp[j].payload) === -1 ) {\r\n                        /*Added relative payload which also need to be removed*/\r\n                        payloads.push(mediaSession.fmtp[j].payload);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        payloads.forEach(pt => {\r\n\r\n            /*Process payloads*/\r\n            if ( typeof(mediaSession.payloads) === 'string' ) {\r\n                mediaSession.payloads = mediaSession.payloads.replace(pt, \"\");\r\n            }\r\n\r\n            if ( mediaSession.rtp != undefined ) {\r\n                /*Process rtp*/\r\n                for ( var i = 0; i < mediaSession.rtp.length;) {\r\n\r\n                    if ( mediaSession.rtp[i].payload == pt ) {\r\n                        mediaSession.rtp.splice(i, 1);\r\n                        break;\r\n                    } else {\r\n                        i += 1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if ( mediaSession.fmtp != undefined ) {\r\n                /*Process fmtp*/\r\n                for ( var i = 0; i < mediaSession.fmtp.length;) {\r\n\r\n                    if ( mediaSession.fmtp[i].payload == pt ) {\r\n                        mediaSession.fmtp.splice(i, 1);\r\n                        //break; maybe there more than one fmtp for some payload.\r\n                    } else {\r\n                        i += 1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if ( mediaSession.rtcpFb != undefined ) {\r\n                /*Process rtcpFb*/\r\n                for ( var i = 0; i < mediaSession.rtcpFb.length;) {\r\n\r\n                    if ( mediaSession.rtcpFb[i].payload == pt ) {\r\n                        mediaSession.rtcpFb.splice(i, 1);\r\n                        //break; more than one rtcpFb for some payload.\r\n                    } else {\r\n                        i += 1;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        /*Process payloads blanks*/\r\n        if ( typeof(mediaSession.payloads) === 'string' ) {\r\n            mediaSession.payloads = mediaSession.payloads.replace(/[ ]+/g, \" \");\r\n        }\r\n    },\r\n\r\n    /*payloads must be a array of STRING, case sensive*/\r\n    removeCodecByName: function(session, index, names) {\r\n        if ( index >= session.media.length ) {\r\n            log.log(\"Error index\");\r\n            return;\r\n        }\r\n\r\n        var mediaSession = session.media[index];\r\n\r\n        /*Get payloads by names*/\r\n        var payloads = new Array();\r\n        mediaSession.rtp.forEach(item => names.forEach(codec => {\r\n            if ( item.codec === codec ) {\r\n                payloads.push(item.payload);\r\n            }\r\n        }));\r\n\r\n        this.removeCodecByPayload(session, index, payloads);\r\n    },\r\n\r\n    /*Merge SDP, SDPs must be a SDP STRING array*/\r\n    mergeSDP: function(SDPs) {\r\n        let mergedSDP;\r\n        let mergedSession;\r\n        let sessions = new Array();\r\n\r\n        for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n            sessions[i] = this.parseSDP(SDPs[i]);\r\n        }\r\n\r\n        /***Process msid mapping***/\r\n        //for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n        //    sessions[i].media.msid\r\n        //}\r\n\r\n        /***Process mid mapping***/\r\n        let id = 0;\r\n        for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n            for(let j = 0; j < sessions[i].media.length; j += 1 ){\r\n                let item = { };\r\n                item['msid'] = sessions[i].media[j].msid;\r\n                item['mid']  = sessions[i].media[j].mid;\r\n                item['mappedMID'] = id;\r\n                this.midMap.push(item);\r\n\r\n                /*Modified the group a line*/\r\n                if ( typeof(sessions[i].groups[0].mids) === 'string' ) {\r\n                    sessions[i].groups[0].mids = sessions[i].groups[0].mids.replace(sessions[i].media[j].mid, id);\r\n                } else if ( typeof(sessions[i].groups[0].mids) === 'number' ) {\r\n                    sessions[i].groups[0].mids = id;\r\n                } else {\r\n                    log.log(\"ERROR on Process mid mapping\");\r\n                }\r\n\r\n                /*Modified the mid*/\r\n                sessions[i].media[j].mid = id;\r\n\r\n                id += 1;\r\n            }\r\n        }\r\n\r\n        /***Merge session level part***/\r\n        if ( sessions[0].groups === undefined ) {\r\n            sessions[0].groups = new Array();\r\n        }\r\n\r\n        if ( sessions[0].msidSemantics === undefined ) {\r\n            sessions[0].msidSemantics = new Array();\r\n        }\r\n\r\n        for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n            log.log(\"Session \" + i + \"th:\\n\" + sessions[i]);\r\n            /*Process ssesion fingerprint a line*/\r\n            if ( sessions[i].fingerprint !== undefined ) {\r\n                sessions[i].media.forEach(\r\n                    function(m) {\r\n                        m['fingerprint'] = deepCopy(sessions[i].fingerprint);\r\n                    });\r\n\r\n                delete sessions[i].fingerprint;\r\n            }\r\n\r\n            /*Process copy all groups a line*/\r\n            if ( sessions[i].groups !== undefined ) {\r\n                if ( i > 0 ) {\r\n                    sessions[i].groups.forEach(\r\n                        function(g) {\r\n                            sessions[0].groups.push(deepCopy(g));\r\n                        });\r\n                }\r\n            }\r\n\r\n            /*Process MSID a line*/\r\n            if ( sessions[i].msidSemantics !== undefined ) {\r\n                if ( i > 0 ) {\r\n                    sessions[i].msidSemantics.forEach(\r\n                        function(msid) {\r\n                            sessions[0].msidSemantics.push(deepCopy(msid));\r\n                        });\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n\r\n        /***Merge media level part***/\r\n        for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n            if ( sessions[i].media !== undefined ) {\r\n                if ( i > 0 ) {\r\n                    sessions[i].media.forEach(\r\n                        function(m) {\r\n                            sessions[0].media.push(deepCopy(m));\r\n                        });\r\n                }\r\n            }\r\n        }\r\n\r\n        /***Process C line and port of M line, if has ICE candidate***/\r\n\r\n\r\n        mergedSDP = this.writeSDP(sessions[0]);\r\n\r\n        return mergedSDP;\r\n    },\r\n\r\n    /*Split SDP, return SDP STRING array*/\r\n    splitSDP: function(SDP) {\r\n        let sdpArray = new Array();\r\n        let session = this.parseSDP(SDP);\r\n\r\n        if ( session.groups === undefined ) {\r\n            log.log(\"No GROUP information, need to split m lines to each pc\");\r\n\r\n            session.groups = new Array();\r\n            this.midMap = new Array();\r\n            for ( let i = 0; i < session.media.length; i += 1 ) {\r\n                /*Make fake groups*/\r\n                session.groups.push({ type: \"BUNDLE\", mids: session.media[i].mid });\r\n                let item = { };\r\n                item['msid'] = session.media[i].msid;\r\n                item['mid'] = 0;\r\n                item['mappedMID'] = session.media[i].mid;\r\n                this.midMap.push(item);\r\n            }\r\n        }\r\n\r\n        for ( let i = 0; i < session.groups.length; i += 1 ) {\r\n            let sdp;\r\n            let sess = deepCopy(session);\r\n\r\n            sess.groups = new Array(sess.groups[i]);\r\n            if ( sess.msidSemantics !== undefined ) {\r\n                sess.msidSemantics = new Array(sess.msidSemantics[i]);\r\n            } else {\r\n                delete sess.msidSemantics;\r\n            }\r\n            let media = new Array();\r\n\r\n            if ( typeof( sess.groups[0].mids ) === 'number' ) {\r\n                for (let j = 0; j < sess.media.length; j +=1 ) {\r\n                    if ( sess.media[j].mid === sess.groups[0].mids ) {\r\n                        media.push(sess.media[j]);\r\n                        break;\r\n                    }\r\n                }\r\n            } else if ( typeof(sess.groups[0].mids) === 'string' ) {\r\n\r\n                sess.groups[0].mids.split(' ').forEach( mid => {\r\n                    for ( let j = 0; j < sess.media.length; j += 1 ) {\r\n                        if ( sess.media[j].mid === mid ) {\r\n                            media.push(sess.media[j]);\r\n                            break;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            sess.media = media;\r\n\r\n            /***Revert the mid mapping***/\r\n            for (let k = 0; k < sess.media.length; k += 1) {\r\n                for(let l = 0; l < this.midMap.length; l +=1 ){\r\n                    if ( sess.media[k].mid === this.midMap[l].mappedMID ) {\r\n                        sess.media[k].mid = this.midMap[l].mid;\r\n\r\n                        if ( typeof(sess.groups[0].mids) === 'string' ) {\r\n                            sess.groups[0].mids = sess.groups[0].mids.replace(sess.media[k].mid, this.midMap[l].mid);\r\n                        } else if ( typeof(sess.groups[0].mids) === 'number' ) {\r\n                            sess.groups[0].mids = this.midMap[l].mid;\r\n                        } else {\r\n                            log.log(\"ERROR on Process mid mapping\");\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            /***Revert the msid mapping***/\r\n\r\n            sdp = this.writeSDP(sess);\r\n            sdpArray.push(sdp);\r\n        }\r\n\r\n\r\n\r\n        return sdpArray;\r\n    }\r\n\r\n};\r\n\r\n\n/**\r\n * AMD, CommonJS, Global compatible Script Wrapper\r\n * https://github.com/umdjs/umd\r\n */\r\n(function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n        define([], factory);\r\n        /* istanbul ignore next */\r\n    } else if (typeof exports === 'object') {\r\n        // Node. Does not work with strict CommonJS, but\r\n        // only CommonJS-like environments that support module.exports,\r\n        // like Node.\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals (root is window)\r\n        root.MediaDevice = factory();\r\n    }\r\n}(this, function () {\r\n\r\n\r\n    function MediaDevice() {\r\n        this.deviceCheckTimer = null\r\n    }\r\n\r\n    /***\r\n     * 获取分辨率扫描列表\r\n     */\r\n    MediaDevice.prototype.getQuickScanList = function () {\r\n        return [\r\n            {\r\n                \"label\": \"4K(UHD)\",\r\n                \"width\": 3840,\r\n                \"height\": 2160,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"4K(UHD)\",\r\n                \"width\": 3840,\r\n                \"height\": 2160,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"1080p(FHD)\",\r\n                \"width\": 1920,\r\n                \"height\": 1080,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"1080p(FHD)\",\r\n                \"width\": 1920,\r\n                \"height\": 1080,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"UXGA\",\r\n                \"width\": 1600,\r\n                \"height\": 1200,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"UXGA\",\r\n                \"width\": 1600,\r\n                \"height\": 1200,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"720p(HD)\",\r\n                \"width\": 1280,\r\n                \"height\": 720,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"720p(HD)\",\r\n                \"width\": 1280,\r\n                \"height\": 720,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"SVGA\",\r\n                \"width\": 800,\r\n                \"height\": 600,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"SVGA\",\r\n                \"width\": 800,\r\n                \"height\": 600,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"VGA\",\r\n                \"width\": 640,\r\n                \"height\": 480,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"VGA\",\r\n                \"width\": 640,\r\n                \"height\": 480,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"360p(nHD)\",\r\n                \"width\": 640,\r\n                \"height\": 360,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"360p(nHD)\",\r\n                \"width\": 640,\r\n                \"height\": 360,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"CIF\",\r\n                \"width\": 352,\r\n                \"height\": 288,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"CIF\",\r\n                \"width\": 352,\r\n                \"height\": 288,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QVGA\",\r\n                \"width\": 320,\r\n                \"height\": 240,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QVGA\",\r\n                \"width\": 320,\r\n                \"height\": 240,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"180p?\",\r\n                \"width\": 320,\r\n                \"height\": 180,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"180p?\",\r\n                \"width\": 320,\r\n                \"height\": 180,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QCIF\",\r\n                \"width\": 176,\r\n                \"height\": 144,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QCIF\",\r\n                \"width\": 176,\r\n                \"height\": 144,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QQVGA\",\r\n                \"width\": 160,\r\n                \"height\": 120,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QQVGA\",\r\n                \"width\": 160,\r\n                \"height\": 120,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            }\r\n        ];\r\n    }\r\n\r\n    /***\r\n     * 获取音视频设备并进行分类\r\n     * @param deviceInfoCallback\r\n     * @param error\r\n     */\r\n    MediaDevice.prototype.enumDevices = function (deviceInfoCallback, error) {\r\n        if (navigator.mediaDevices === undefined || navigator.mediaDevices.enumerateDevices === undefined) {\r\n            if (error) {\r\n                error(\"browser don't support enumerate devices\")\r\n            }\r\n            return\r\n        }\r\n        navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {\r\n            var microphone = []\r\n            var speaker = []\r\n            var camera = []\r\n            var screenResolution = []\r\n            var isConstraintsKeywordSupport = true\r\n            for (var i = 0; i < deviceInfos.length; i++) {\r\n                var deviceInfo = deviceInfos[i]\r\n                if(deviceInfo.deviceId === 'default' || deviceInfo.deviceId === 'communications'){\r\n                    continue\r\n                }\r\n                if (deviceInfo.kind === 'audioinput') {\r\n                    microphone.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                    })\r\n                }\r\n                if (deviceInfo.kind === 'audiooutput') {\r\n                    speaker.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                    })\r\n                }\r\n                if (deviceInfo.kind === 'videoinput') {\r\n                    camera.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                        capability: []\r\n                    })\r\n                }\r\n            }\r\n\r\n            screenResolution.push({\r\n                width: window.screen.width,\r\n                height: window.screen.height,\r\n            })\r\n\r\n            if (deviceInfoCallback) {\r\n                deviceInfoCallback({\r\n                    microphones: microphone,\r\n                    speakers: speaker,\r\n                    cameras: camera,\r\n                    screenResolution: screenResolution,\r\n                    isConstraintsKeywordSupport: isConstraintsKeywordSupport\r\n                })\r\n            } else {\r\n                return {\r\n                    microphones: microphone,\r\n                    speakers: speaker,\r\n                    cameras: camera,\r\n                    screenResolution: screenResolution,\r\n                    isConstraintsKeywordSupport: isConstraintsKeywordSupport\r\n                }\r\n            }\r\n        }).catch(function (err) {\r\n            if (error) {\r\n                error(err)\r\n            }\r\n        })\r\n    }\r\n\r\n    /***\r\n     * 更新localStorage存储\r\n     * @param deviceInfos 所有的媒体数据\r\n     * @param type ： cameras / microphones / speakers， 更新的类型\r\n     */\r\n    MediaDevice.prototype.updateDeviceInfo = function (deviceInfos, type) {\r\n        var localStorageDeviceInfo = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var deviceInfoList = []\r\n        var storageInfoList = []\r\n\r\n        switch (type) {\r\n            case 'cameras':\r\n                deviceInfoList = deviceInfos.cameras\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.cameras ? localStorageDeviceInfo.cameras : [] : []\r\n                break\r\n            case 'microphones':\r\n                deviceInfoList = deviceInfos.microphones\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.microphones ? localStorageDeviceInfo.microphones : [] : []\r\n                break\r\n            case 'speakers':\r\n                deviceInfoList = deviceInfos.speakers\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.speakers ? localStorageDeviceInfo.speakers : [] : []\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        /***\r\n         * 判断localStorage中的设备是否有还存在，不存在则设置状态为 unavailable，还存在的置为available\r\n         * @param deviceInfoList\r\n         * @param storageInfoList\r\n         */\r\n        function setDeviceStatus(deviceInfoList, storageInfoList) {\r\n            for (var i = 0; i < storageInfoList.length; i++) {\r\n                for (var j = 0; j < deviceInfoList.length; j++) {\r\n                    if (storageInfoList[i].label === deviceInfoList[j].label) {\r\n                        if (storageInfoList[i].status === 'unavailable') {\r\n                            log.log('set device unavailable to available!')\r\n                            storageInfoList[i].status = 'available'\r\n                        }\r\n                        storageInfoList[i].deviceId = deviceInfoList[j].deviceId\r\n                        storageInfoList[i].groupId = deviceInfoList[j].groupId\r\n                        break\r\n                    }\r\n                    if (storageInfoList[i].label !== deviceInfoList[j].label && j === deviceInfoList.length - 1 && storageInfoList[i].status !== 'unavailable') {\r\n                        log.warn(storageInfoList[i].label + \"   device is unavailable\")\r\n                        storageInfoList[i].status = 'unavailable'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /***\r\n         * 判断设备是否是新设备，是的话，添加到localStorage中\r\n         * @param deviceInfoList\r\n         * @param storageInfoList\r\n         */\r\n        function addInsertDevice(deviceInfoList, storageInfoList) {\r\n            for (var i = 0; i < deviceInfoList.length; i++) {\r\n                for (var j = 0; j < storageInfoList.length; j++) {\r\n                    if (deviceInfoList[i].label === storageInfoList[j].label) {\r\n                        storageInfoList[j].deviceId = deviceInfoList[i].deviceId\r\n                        storageInfoList[j].groupId = deviceInfoList[i].groupId\r\n                        break\r\n                    }\r\n                    if (deviceInfoList[i].label !== storageInfoList[j].label && j === storageInfoList.length - 1) {\r\n                        log.warn(\"new device has been insert!\")\r\n                        storageInfoList.push(deviceInfoList[i])\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 本地存储没有任何值，直接设置获取的设备列表到localStorage中\r\n        if (deviceInfoList.length && !storageInfoList.length) {\r\n            log.warn(\"set new device info list\")\r\n            localStorage.setItem('mediaDevice', JSON.stringify(deviceInfos, null, '    '))\r\n            return\r\n        }\r\n\r\n        // 未获取当任何有效的设备列表，localStorage保存的设备全部设置为不可用\r\n        if (!deviceInfoList.length && storageInfoList.length) {\r\n            log.warn('set all device to unavailable');\r\n            for (var i = 0; i < storageInfoList.length; i++) {\r\n                storageInfoList[i].status = 'unavailable'\r\n            }\r\n            localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))\r\n            return\r\n        }\r\n\r\n        // 获取到设备列表，且localStorage中有设备存储信息\r\n        setDeviceStatus(deviceInfoList, storageInfoList)\r\n        addInsertDevice(deviceInfoList, storageInfoList)\r\n        log.log('update modified device info into localStorage!')\r\n        localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))\r\n    }\r\n\r\n    /***\r\n     * 清除流\r\n     * @param stream\r\n     */\r\n    MediaDevice.prototype.closeStream = function (stream) {\r\n        try {\r\n            var tracks = stream.getTracks();\r\n            for (var track in tracks) {\r\n                tracks[track].onended = null;\r\n                log.log(\"close stream\");\r\n                tracks[track].stop();\r\n            }\r\n        } catch (e) {\r\n            log.error(e)\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 判断取流是否支持关键字：min/max/exact/ideal\r\n     * 常见：测试一体机不支持关键字\r\n     * @returns {Promise<boolean>}\r\n     */\r\n    MediaDevice.prototype.isConstraintsKeywordSupport = async function () {\r\n        var This = this\r\n        var result = true\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var isKeywordSupport = mediaDevice ? mediaDevice.isConstraintsKeywordSupport : null\r\n\r\n        if (isKeywordSupport !== null) {\r\n            result = isKeywordSupport\r\n        } else {\r\n            var constraints = {\r\n                audio: false,\r\n                video: {\r\n                    width: {ideal: 640},\r\n                    height: {ideal: 360}\r\n                }\r\n            }\r\n\r\n            function onGetUserMediaSuccess(stream){\r\n                log.log('constraints keyWords support')\r\n                result = true\r\n                This.closeStream(stream)\r\n            }\r\n\r\n            function onGetUserMediaFailed(error){\r\n                console.error(error)\r\n                log.log('ideal is not support' + error.message)\r\n                result = false\r\n            }\r\n\r\n            log.log(\"isConstraintsKeywordSupport test constraints: \\n\" + JSON.stringify(constraints, null, '    '));\r\n            try {\r\n                var stream = await navigator.mediaDevices.getUserMedia(constraints)\r\n                onGetUserMediaSuccess(stream)\r\n            }catch(error){\r\n                onGetUserMediaFailed(error)\r\n            }\r\n        }\r\n\r\n        log.info('is constraints Keyword support: ', result)\r\n        return result\r\n    }\r\n\r\n    /***\r\n     * 使用exact关键字取流\r\n     * @returns {Promise<void>}\r\n     */\r\n    MediaDevice.prototype.getStreamWithExactConstraints = async function () {\r\n        var This = this\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var quickScanList = This.getQuickScanList()\r\n        var localStream\r\n        var constraints\r\n\r\n        function onGetUserMediaSuccess(stream) {\r\n            // log.info('applyConstraints success' + JSON.stringify(constraints, null, '    '))\r\n            log.info(\"get Stream Success : \" + quickScanList[i].width + \" x \" + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);\r\n            if(stream){\r\n                localStream = stream\r\n            }\r\n\r\n            capability.push({\r\n                width: quickScanList[i].width,\r\n                height: quickScanList[i].height,\r\n                frameRate: quickScanList[i].frameRate,\r\n                aspectRatio: quickScanList[i].ratio\r\n            })\r\n\r\n            if (j === mediaDevice.cameras.length - 1 && i === quickScanList.length - 1) {\r\n                log.log(\"Resolution scan completed, clear stream.\")\r\n                This.closeStream(localStream)\r\n            }\r\n        }\r\n\r\n        function onGetUserMediaFailed(error) {\r\n            if (error.name === 'ConstraintNotSatisfiedError') {\r\n                log.info('The resolution ' + quickScanList[i].width + 'x' +\r\n                  quickScanList[i].height + ' px and frameRate with ' +  quickScanList[i].frameRate + ' is not supported by your device.');\r\n            } else if (error.name === 'PermissionDeniedError') {\r\n                log.info('Permissions have not been granted to use your camera and ' +\r\n                  'microphone, you need to allow the page access to your devices in ' +\r\n                  'order for the demo to work.');\r\n            }\r\n            // log.error('getUserMedia error: ' + error.name, error);\r\n            log.info(\"fail: mismatch : \" + quickScanList[i].width + \" x \" + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);\r\n        }\r\n\r\n        for (var j = 0; j < mediaDevice.cameras.length; j++) {\r\n            // 换摄像头时需要重新取流，避免使用applyConstraints时不换摄像头的场景\r\n            if (localStream) {\r\n                This.closeStream(localStream)\r\n            }\r\n            // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描\r\n            if (mediaDevice.cameras[j].capability && mediaDevice.cameras[j].capability.length > 0) {\r\n                log.warn(\"this device has already get resolution before: \" + mediaDevice.cameras[j].label)\r\n                continue\r\n            }\r\n\r\n            log.warn(\"Current scan device：\", mediaDevice.cameras[j].label)\r\n            var deviceId = mediaDevice.cameras[j].deviceId\r\n            var capability = mediaDevice.cameras[j].capability\r\n\r\n\r\n            // 存在问题：不使用关键字时，applyConstraints和getUserMedia取流都存在不准确问题，比如1920*1080，摄像头不支持该分辨率也能取流成功，因为取的是别的分辨率\r\n            for (var i = 0; i < quickScanList.length; i++) {\r\n                var videoTrack = localStream ? localStream.getVideoTracks()[0] : null\r\n                if (localStream && localStream.active === true && localStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {\r\n                    constraints = {\r\n                        frameRate: {exact: quickScanList[i].frameRate},\r\n                        aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                        width: {exact: quickScanList[i].width},\r\n                        height: {exact: quickScanList[i].height}\r\n                    }\r\n                    try {\r\n                        await videoTrack.applyConstraints(constraints)\r\n                        onGetUserMediaSuccess()\r\n                    }catch (error) {\r\n                        onGetUserMediaFailed(error)\r\n                    }\r\n                } else {\r\n                    constraints = {\r\n                        audio: false,\r\n                        video: {\r\n                            frameRate: {exact: quickScanList[i].frameRate},\r\n                            aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                            width: {\r\n                                max: quickScanList[i].width,\r\n                                exact: quickScanList[i].width\r\n                            },\r\n                            height: {\r\n                                max: quickScanList[i].height,\r\n                                exact: quickScanList[i].height\r\n                            },\r\n                        }\r\n                    }\r\n                    if(deviceId){\r\n                        constraints.video.deviceId = { exact: deviceId}\r\n                    }\r\n\r\n                    try {\r\n                        let stream = await navigator.mediaDevices.getUserMedia(constraints)\r\n                        onGetUserMediaSuccess(stream)\r\n                    }catch (error) {\r\n                        onGetUserMediaFailed(error)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))\r\n    }\r\n\r\n    // 创建video标签\r\n    var cameraPrevVideo = document.createElement('video')\r\n    cameraPrevVideo.onloadedmetadata = MediaDevice.prototype.displayVideoDimensions;\r\n    /***\r\n     * video 元数据加载完成后触发，用于判断取流后的分辨率与实际要求是否一致\r\n     * @param scanListIndex 当前扫描的分辨率列表的索引值\r\n     * @param cameraIndex 当前扫描的摄像头列表值\r\n     */\r\n    MediaDevice.prototype.displayVideoDimensions = function (scanListIndex, cameraIndex) {\r\n        var This = this\r\n        var i = scanListIndex\r\n        var j = cameraIndex\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var capability = mediaDevice.cameras[j].capability\r\n        var quickScanList = This.getQuickScanList()\r\n        log.log(\"Video onloadedmetadata call~~~\");\r\n\r\n        function captureResults(data) {\r\n            if (data.result === true) {\r\n                log.log(\"pass\")\r\n                capability.push({\r\n                    width: quickScanList[i].width,\r\n                    height: quickScanList[i].height,\r\n                    frameRate: quickScanList[i].frameRate,\r\n                    aspectRatio: quickScanList[i].ratio\r\n                })\r\n                localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))\r\n            } else {\r\n                log.log(\"fail: mismatch\")\r\n            }\r\n\r\n            i++\r\n            if (i < quickScanList.length) {\r\n                log.log('Scan the next resolution')\r\n                window.isScanCameraChange = false\r\n                This.getStreamWithoutConstraintsKeyWords(i, j)\r\n            } else if (j < mediaDevice.cameras.length - 1) {\r\n                log.log('Scan the next camera')\r\n                window.isScanCameraChange = true\r\n                This.closeStream(stream)\r\n                j++;\r\n                i = 0;\r\n                This.getStreamWithoutConstraintsKeyWords(i, j)\r\n            } else {\r\n                This.closeStream(stream)\r\n                log.log(\"All camera capabilities are End of scan ~~\")\r\n                cameraPrevVideo = null\r\n            }\r\n        }\r\n\r\n        if (!cameraPrevVideo.videoWidth) {\r\n            setTimeout(function () {\r\n                This.displayVideoDimensions(scanListIndex, cameraIndex)\r\n            }, 500);  //was 500\r\n        }\r\n\r\n        if (cameraPrevVideo.videoWidth * cameraPrevVideo.videoHeight > 0) {\r\n            log.info(\"Display size for : \" + quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height);\r\n            log.info(\"Stream dimensions for :\" + cameraPrevVideo.videoWidth + \"x\" + cameraPrevVideo.videoHeight);\r\n            if (quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height !== cameraPrevVideo.videoWidth + \"x\" + cameraPrevVideo.videoHeight) {\r\n                log.info(\"fail: mismatch\")\r\n                captureResults({result: false})\r\n            } else {\r\n                log.info(\"pass :\" + quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height)\r\n                captureResults({result: true})\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /***\r\n     * 兼容不支持min/max/ideal/exact的情况，使用{audio:false, video: { width: 1280, height: 720}} 格式取流\r\n     * 通过取流后的video实际尺寸判断取流是否成功\r\n     * @param scanListIndex 当前扫描的分辨率列表的索引值\r\n     * @param cameraIndex 当前扫描的摄像头列表值\r\n     * @returns {Promise<void>}\r\n     */\r\n    MediaDevice.prototype.getStreamWithoutConstraintsKeyWords = async function (scanListIndex, cameraIndex) {\r\n        var This = this\r\n        var quickScanList = This.getQuickScanList()\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var i = scanListIndex\r\n        var j = cameraIndex\r\n        var mediaStream = window.stream\r\n        var deviceId = mediaDevice.cameras[j].deviceId\r\n        var capability = mediaDevice.cameras[j].capability\r\n        var constraints;\r\n\r\n        // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描\r\n        if (window.isScanCameraChange === true && capability && capability.length > 0) {\r\n            log.warn(\"this device has already get resolution before: \" + mediaDevice.cameras[j].label)\r\n            cameraIndex++\r\n            if (cameraIndex < mediaDevice.cameras.length) {\r\n                log.warn('Scan the next device')\r\n                This.getStreamWithoutConstraintsKeyWords(scanListIndex, cameraIndex)\r\n            }\r\n            return\r\n        }\r\n        window.isScanCameraChange = false\r\n\r\n        function onGetUserMediaSuccess(stream) {\r\n            log.log('applyConstraints success' + JSON.stringify(constraints, null, '    '))\r\n            log.log(\"Display size for \" + quickScanList[i].label + \": \" + quickScanList[i].width + \"x\" + quickScanList[i].height);\r\n\r\n            if(stream){\r\n                window.stream = stream\r\n                cameraPrevVideo.srcObject = stream\r\n            }\r\n\r\n            setTimeout(function () {\r\n                This.displayVideoDimensions(scanListIndex, cameraIndex)\r\n            }, 2000);\r\n        }\r\n\r\n        function onGetUserMediaFailed(error){\r\n            log.warn('applyConstraints error: ', error.name)\r\n        }\r\n\r\n        log.warn(\"Current scan device：\", mediaDevice.cameras[j].label)\r\n        var videoTrack = mediaStream ? mediaStream.getVideoTracks()[0] : null\r\n        if (mediaStream && mediaStream.active === true && mediaStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {\r\n            constraints = {\r\n                frameRate: quickScanList[i].frameRate,\r\n                width: quickScanList[i].width,\r\n                height: quickScanList[i].height,\r\n                aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n            }\r\n\r\n           try {\r\n               await videoTrack.applyConstraints(constraints)\r\n               onGetUserMediaSuccess()\r\n           }catch (error) {\r\n               onGetUserMediaFailed(error)\r\n           }\r\n        } else {\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    deviceId: deviceId,\r\n                    frameRate: quickScanList[i].frameRate,\r\n                    width: quickScanList[i].width,\r\n                    height: quickScanList[i].height,\r\n                    aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                }\r\n            }\r\n\r\n           try {\r\n               await navigator.mediaDevices.getUserMedia(constraints)\r\n               onGetUserMediaSuccess(stream)\r\n           }catch (error) {\r\n               onGetUserMediaFailed(error)\r\n           }\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 设置设备所支持的取流能力：frameRate, width, height\r\n     */\r\n    MediaDevice.prototype.setDeviceCapability = async function () {\r\n        log.warn('device capability scanning')\r\n        var This = this\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        // 判断取流是否支持关键字设置\r\n        var isKeywordSupport = await This.isConstraintsKeywordSupport()\r\n        mediaDevice.isConstraintsKeywordSupport = isKeywordSupport\r\n\r\n        if (mediaDevice && mediaDevice.cameras.length > 0) {\r\n            if (isKeywordSupport === true) {\r\n                log.info(\"min/max/ideal/exact keyWord is support\")\r\n                await This.getStreamWithExactConstraints()\r\n            } else {\r\n                log.info(\"min/max/ideal/exact keyWord is  NOT support\")\r\n                window.isScanCameraChange = true\r\n                await This.getStreamWithoutConstraintsKeyWords(0, 0)\r\n            }\r\n        } else {\r\n            log.warn('no cameras need to resolution scan!')\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 检查可用设备列表\r\n     */\r\n    MediaDevice.prototype.checkAvailableDev = function () {\r\n        var This = this\r\n\r\n        This.enumDevices(function (deviceInfo) {\r\n            // log.log(\"get device info success: \\n\", JSON.stringify(deviceInfo))\r\n            function setLabel(devices, type) {\r\n                for (var key = 0; key < devices.length; key++) {\r\n                    if (!devices[key].label) {\r\n                        devices[key].label = type + key\r\n                    }\r\n                    log.log(type + \" \" + devices[key].label)\r\n                }\r\n                return devices\r\n            }\r\n\r\n            if (deviceInfo) {\r\n                if (deviceInfo.cameras) {\r\n                    setLabel(deviceInfo.cameras, 'cameras')\r\n                }\r\n                if (deviceInfo.microphones) {\r\n                    setLabel(deviceInfo.microphones, 'microphones')\r\n                }\r\n                if (deviceInfo.speakers) {\r\n                    setLabel(deviceInfo.speakers, 'speakers')\r\n                }\r\n\r\n                This.updateDeviceInfo(deviceInfo, \"cameras\")\r\n                This.updateDeviceInfo(deviceInfo, \"microphones\")\r\n                This.updateDeviceInfo(deviceInfo, \"speakers\")\r\n            } else {\r\n                log.warn(\"deviceInfo is null\")\r\n            }\r\n\r\n        }, function (error) {\r\n            log.error('enum device error: ' + error.toString())\r\n        })\r\n    }\r\n\r\n    /***\r\n     * 设备定时检查开关\r\n     * @param switchOn: true 开启定时器；  false 关闭定时器\r\n     */\r\n    MediaDevice.prototype.setDeviceCheckInterval = function (switchOn) {\r\n        var This = this\r\n        if (switchOn) {\r\n            clearInterval(This.deviceCheckTimer)\r\n            This.deviceCheckTimer = setInterval(function () {\r\n                This.checkAvailableDev()\r\n            }, 1000)\r\n        } else {\r\n            clearInterval(This.deviceCheckTimer);\r\n            This.deviceCheckTimer = null\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取最接近，最合适的设备支持的分辨率\r\n     * @param expectRes 当前希望获取的分辨率，eg {\r\n     *   deviceId: 4b5305afd805f2d8439eac80dc94b14846799929d44d18c7dd8fc97eda75c046\r\n     *   frameRate: 15,\r\n     *   width: 1080,\r\n     *   height: 720\r\n     * }\r\n     */\r\n    MediaDevice.prototype.getSuitableResolution = function (expectRes) {\r\n        if (!expectRes.deviceId || !expectRes.width || !expectRes.height || !expectRes.frameRate) {\r\n            log.warn('Invalid parameter');\r\n            return\r\n        }\r\n\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var capability = []\r\n        var sameWidthList = []\r\n        var matchRes = {}\r\n\r\n        if (mediaDevice && mediaDevice.cameras.length > 0) {\r\n            // 获取给定设备支持的取流能力列表\r\n            for (var i = 0; i < mediaDevice.cameras.length; i++) {\r\n                if (mediaDevice.cameras[i].deviceId === expectRes.deviceId) {\r\n                    capability = mediaDevice.cameras[i].capability\r\n                    log.warn(\"capability: \", capability)\r\n                    break\r\n                }\r\n            }\r\n\r\n            // 过滤出相同width的分辨率\r\n            if (capability.length > 0) {\r\n                for (var j = 0; j < capability.length; j++) {\r\n                    if (capability[j].width === expectRes.width) {\r\n                        sameWidthList.push(capability[j])\r\n                    }\r\n                }\r\n                log.warn(\"sameWidthList: \", sameWidthList)\r\n            }\r\n\r\n            // 获取最合适的分辨率\r\n            if (sameWidthList.length > 0) {\r\n                for (var k = 0; k < sameWidthList.length; k++) {\r\n                    // 返回width height frameRate 都相同的分辨率\r\n                    if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {\r\n                        log.warn('Returns the resolution of width height frameRate', sameWidthList[k])\r\n                        matchRes = sameWidthList[k]\r\n                        break\r\n                    }\r\n                }\r\n\r\n                if (JSON.stringify(matchRes) === \"{}\") {\r\n                    for (var k = 0; k < sameWidthList.length; k++) {\r\n                        // 返回width height相同， frameRate 小于期望值的的分辨率\r\n                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate < expectRes.frameRate) {\r\n                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])\r\n                            matchRes = sameWidthList[k]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (JSON.stringify(matchRes) === \"{}\") {\r\n                    for (var k = 0; k < sameWidthList.length; k++) {\r\n                        // 返回width frameRate 相同， height 小于期望值的的分辨率\r\n                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height < expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {\r\n                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])\r\n                            matchRes = sameWidthList[k]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                log.warn(\"no same with resolution exist, get other resolution;\")\r\n                // 返回设备支持的最大的、width比期望值小的分辨率\r\n                for (var j = 0; j < capability.length; j++) {\r\n                    if (capability[j].width < expectRes.width) {\r\n                        log.log('Returns the maximum resolution supported by the device with a smaller width than expected')\r\n                        matchRes = capability[j]\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            return matchRes\r\n        }\r\n        return matchRes\r\n    }\r\n\r\n    /******************************************************************************************************************/\r\n    /******************************************************* 取流 *****************************************************/\r\n    /******************************************************************************************************************/\r\n    /***\r\n     * 取流： audio/video/screenShare\r\n     * @param data {\r\n     *      callback: callback,\r\n        streamType: \"video\",\r\n        constraintsKeyWord: \"exact\",\r\n        constraints: {\r\n            aspectRatio: {min: 1.777, max: 1.778},\r\n            frameRate: 30,\r\n            width: 1280,\r\n            height: 720,\r\n            deviceId: deviceId,\r\n        }\r\n     * }\r\n     * @param constraints\r\n     */\r\n    MediaDevice.prototype.getMedia = async function (data, constraints) {\r\n        log.warn(\"getMedia\")\r\n        var This = this\r\n        if (!constraints) {\r\n            constraints = This.getConstraints(data, true)\r\n        }\r\n\r\n        function onGetStreamSuccess(stream) {\r\n            data.callback({stream: stream})\r\n        }\r\n\r\n        function onGetStreamFailed(error) {\r\n            data.settings = constraints\r\n            data.error = error\r\n            log.error(\"onGetStreamFailed: \", error.name, error.message)\r\n            if(error.name === \"OverconstrainedError\" || error.name === \"ConstraintNotSatisfiedError\"){\r\n                // constraints can not be satisfied by avb.device\r\n                log.warn('constraints can not be satisfied by avb.device')\r\n                This.getMedia(data)\r\n            }else {\r\n                if(error.name === \"NotFoundError\" || error.name === \"DeviceNotFoundError\"){\r\n                    // require track is missing\r\n                    log.warn('require track is missing')\r\n                }else if(error.name === \"NotReadableError\" || error.name === \"TrackStartError\"){\r\n                    // webcam or mic are already in use\r\n                    log.warn('webcam or mic are already in use')\r\n                }else if(error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\" || error.name === \"PermissionDismissedError\"){\r\n                    // permission denied in browser\r\n                    log.warn('permission denied in browser')\r\n                }else if(error.name === \"TypeError\"){\r\n                    // empty constraints object\r\n                    log.warn('empty constraints object')\r\n                }else {\r\n                    // other errors\r\n                    log.warn('other errors ' + error.name)\r\n                }\r\n                data.callback({error: error})\r\n            }\r\n        }\r\n\r\n        if (data.streamType === 'audio' || data.streamType === 'video') {\r\n            let stream = data.stream\r\n            let videoTrack = null\r\n            if (data.streamType === 'video' && stream && stream.getVideoTracks().length && stream.active === true) {\r\n                videoTrack = stream.getVideoTracks()[0]\r\n                var constraintsOfApply = constraints.video\r\n                if (videoTrack && videoTrack.applyConstraints) {\r\n                    log.warn(\"applyConstraints constraints: \", JSON.stringify(constraintsOfApply, null, '    '))\r\n                    await videoTrack.applyConstraints(constraintsOfApply).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n                }\r\n            } else {\r\n                // audio and video not\r\n                log.warn(\"getUserMedia constraints: \", JSON.stringify(constraints, null, '    '))\r\n                navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            }\r\n        } else if (data.streamType === 'screenShare') {\r\n            if (navigator.getDisplayMedia) {\r\n                navigator.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            } else if (navigator.mediaDevices.getDisplayMedia) {\r\n                navigator.mediaDevices.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            } else {\r\n                log.info('getDisplayMedia is not supported by current browser')\r\n                // 使用插件共享桌面\r\n                window.getScreenId('all', function(error, sourceId, screen_constraints) {\r\n                    navigator.getUserMedia(screen_constraints, onGetStreamSuccess, onGetStreamFailed)\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取分辨率\r\n     * @param data, eg.{\r\n        constraintsKeyWord: \"exact\"\r\n        deviceId: \"8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03\"\r\n        frameRate: 30s\r\n        height: 720\r\n        streamType: \"video\"\r\n        width: 1280\r\n     * }\r\n     * @param reTry: true 取流失败后重新取流， false 第一次取流\r\n     */\r\n    MediaDevice.prototype.getConstraints = function (data, reTry) {\r\n        let This = this\r\n        let constraints = {}\r\n        switch (data.streamType) {\r\n            case 'audio':\r\n                constraints = {\r\n                    audio: data.deviceId ? {deviceId: data.deviceId} : true,\r\n                    video: false\r\n                }\r\n                break;\r\n            case 'video':\r\n                constraints = This.getVideoConstraints(data, reTry)\r\n                break\r\n            case 'screenShare':\r\n                constraints = This.getScreenShareConstraints(data)\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        return constraints\r\n    }\r\n\r\n    /***\r\n     * 获取video 分辨率\r\n     * @param data 需要得参数\r\n     constraintsKeyWord: \"exact\"\r\n     deviceId: \"8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03\"\r\n     frameRate: 15\r\n     height: 720\r\n     streamType: \"video\"\r\n     width: 1280\r\n     * @param reTry 需要得参数 : true 取流失败重新取流, false 第一次取流\r\n     * @returns {{audio: boolean, video: {frameRate: {exact: number}, width: {exact: number}, aspectRatio: {exact: number}, height: {exact: number}}}}\r\n     */\r\n    MediaDevice.prototype.getVideoConstraints = function (data, reTry) {\r\n        let This = this\r\n        let matchResolution = {}\r\n        let currentLimit = {}\r\n        let deviceId\r\n\r\n        if (reTry) {\r\n            // 这种方式不需要重复获取匹配了\r\n            currentLimit = This.getNextConstraints(data)\r\n            deviceId = currentLimit.deviceId\r\n            matchResolution = currentLimit\r\n        } else {\r\n            // 默认首次取流都使用exact\r\n            deviceId = data.deviceId\r\n            currentLimit = data\r\n            log.info(\"deviceId: \", deviceId)\r\n            if (deviceId) {\r\n                matchResolution = This.getSuitableResolution({\r\n                    frameRate: currentLimit.frameRate ? currentLimit.frameRate : 30,\r\n                    width: currentLimit.width ? currentLimit.width : 640,\r\n                    height: currentLimit.height ? currentLimit.height : 360,\r\n                    deviceId: currentLimit.deviceId\r\n                })\r\n                log.log(\"match constraints: \", matchResolution)\r\n            }\r\n        }\r\n\r\n        log.info(\"currentLimit: \", currentLimit)\r\n        let constraints = {\r\n            audio: false,\r\n            video: {\r\n                frameRate: {\r\n                    exact: matchResolution.frameRate ? matchResolution.frameRate : currentLimit.frameRate ? currentLimit.frameRate : 30\r\n                },\r\n                aspectRatio: {\r\n                    exact: matchResolution.width ? (matchResolution.width / matchResolution.height) : (currentLimit.width / currentLimit.height)\r\n                },\r\n                width: {\r\n                    exact: matchResolution.width ? matchResolution.width : currentLimit.width ? currentLimit.width : 640\r\n                },\r\n                height: {\r\n                    exact: matchResolution.height ? matchResolution.height : currentLimit.height ? currentLimit.height : 360\r\n                }\r\n            }\r\n        }\r\n\r\n        if (deviceId) {\r\n            constraints.video.deviceId = {\r\n                exact: deviceId\r\n            }\r\n        }\r\n\r\n        log.log(\"data.constraintsKeyWord: \", data.constraintsKeyWord)\r\n        if (!data.constraintsKeyWord) {\r\n            log.warn(\"Do not use keyWord limit\")\r\n            constraints.video.frameRate = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio = constraints.video.aspectRatio.exact\r\n            constraints.video.width = constraints.video.width.exact\r\n            constraints.video.height = constraints.video.height.exact\r\n            if (constraints.video.deviceId.exact || constraints.video.deviceId.ideal) {\r\n                constraints.video.deviceId = constraints.video.deviceId.exact ? constraints.video.deviceId.exact : constraints.video.deviceId.ideal\r\n            }\r\n        } else if (data.constraintsKeyWord === 'ideal') {\r\n            log.warn(\"Use ideal limit\")\r\n            constraints.video.frameRate.ideal = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio.ideal = constraints.video.aspectRatio.exact\r\n            constraints.video.width.ideal = constraints.video.width.exact\r\n            constraints.video.height.ideal = constraints.video.height.exact\r\n            // 使用max限制来避免超出要求的能力\r\n            constraints.video.frameRate.max = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio.max = constraints.video.aspectRatio.exact\r\n            constraints.video.width.max = constraints.video.width.exact\r\n            constraints.video.height.max = constraints.video.height.exact\r\n            if (constraints.video.deviceId.exact) {\r\n                constraints.video.deviceId.ideal = constraints.video.deviceId.exact\r\n            }\r\n            // 删除exact属性\r\n            delete constraints.video.frameRate.exact\r\n            delete constraints.video.aspectRatio.exact\r\n            delete constraints.video.width.exact\r\n            delete constraints.video.height.exact\r\n            delete constraints.video.deviceId.exact\r\n        } else if (data.constraintsKeyWord === 'exact') {\r\n            log.warn(\"Use exact limit\")\r\n        }\r\n\r\n        log.warn(\"get new Video Constraints: \", JSON.stringify(constraints, null, '   '))\r\n        return constraints\r\n    }\r\n\r\n    /***\r\n     * 取流失败后根据设备支持的能力列表获取下一个分辨率\r\n     * @param data = {\r\n     *      callback: ƒ (message)\r\n        constraints: {aspectRatio: {…}, frameRate: 30, width: 1280, height: 720, deviceId: \"5e3722883e2e9337040a4f1ababf85a5bd2f6a36afc815fd391424ac05a84ab0\"}\r\n        constraintsKeyWord: \"ideal\"\r\n        error: OverconstrainedError {name: \"OverconstrainedError\", message: null, constraint: \"frameRate\"}\r\n        settings: {audio: false, video: {…}}\r\n        streamType: \"video\"\r\n     * }\r\n     * @returns {{frameRate: number, streamType: string, width: number, deviceId: (*|number|boolean|string|string[]|ConstrainDOMStringParameters|\"user\"|\"environment\"|\"left\"|\"right\"|VideoFacingModeEnum[]), constraintsKeyWord: (string), height: number}}\r\n     */\r\n    MediaDevice.prototype.getNextConstraints = function (data) {\r\n        let This = this\r\n        // 获取上一次取流失败的分辨率限制\r\n        let lastSettings = data.settings\r\n        let settings = {\r\n            frameRate: lastSettings.video.frameRate.exact ? lastSettings.video.frameRate.exact : lastSettings.video.frameRate.ideal ? lastSettings.video.frameRate.ideal : lastSettings.video.frameRate,\r\n            width: lastSettings.video.width.exact ? lastSettings.video.width.exact : lastSettings.video.width.ideal ? lastSettings.video.width.ideal : lastSettings.video.width,\r\n            height: lastSettings.video.height.exact ? lastSettings.video.height.exact : lastSettings.video.height.ideal ? lastSettings.video.height.ideal : lastSettings.video.height,\r\n            deviceId: lastSettings.video.deviceId.exact ? lastSettings.video.deviceId.exact : lastSettings.video.deviceId.ideal ? lastSettings.video.deviceId.ideal : lastSettings.video.deviceId,\r\n        }\r\n\r\n        // 获取下一个分辨率\r\n        let deviceId = settings.deviceId ? settings.deviceId : data.deviceId\r\n        let capability = This.getCapability(deviceId)\r\n        let nextConstraints\r\n        for (let j = 0; j < capability.length; j++) {\r\n            if (capability[j].width === settings.width && capability[j].height === settings.height && capability[j].frameRate === settings.frameRate) {\r\n                nextConstraints = capability[j + 1]\r\n                break\r\n            }\r\n        }\r\n\r\n        log.log(\"nextConstraints: \", nextConstraints)\r\n        // 如果nextConstraints不存在，说明能力列表全部扫描完成，换其他的限制尝试（exact/ideal/不使用）\r\n        if (!nextConstraints) {\r\n            log.warn(\"Change the restriction condition.\")\r\n            if (data.constraintsKeyWord === 'exact') {\r\n                log.warn(\"Exact has been scanned, using ideals\")\r\n                data.constraintsKeyWord = 'ideal'\r\n            } else if (data.constraintsKeyWord === 'ideal') {\r\n                log.warn(\"The ideal has been scanned. Do not use keywords\")\r\n                data.constraintsKeyWord = ''\r\n            } else {\r\n                // 取流彻底失败，调用回调返回\r\n                log.warn(\"The flow failed completely, and the flow was not taken.\")\r\n                data.callback({error: data.error})\r\n            }\r\n        }\r\n\r\n        return {\r\n            constraintsKeyWord: data.constraintsKeyWord,\r\n            streamType: data.streamType,\r\n            deviceId: settings.deviceId ? settings.deviceId : data.deviceId,\r\n            frameRate: nextConstraints ? nextConstraints.frameRate ? nextConstraints.frameRate : data.constraints.frameRate : data.constraints.frameRate,\r\n            width: nextConstraints ? nextConstraints.width ? nextConstraints.width : data.constraints.width : data.constraints.width,\r\n            height: nextConstraints ? nextConstraints.height ? nextConstraints.height : data.constraints.height : data.constraints.height,\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取屏幕共享分辨率\r\n     * @param data\r\n     * @returns {{audio: boolean, video: {frameRate: {max: string}, width: {max: string}, height: {max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, mozMediaSource: *, width: {min: string, max: string}, mediaSource: *, height: {min: string, max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, width: {min: string, max: string}, logicalSurface: boolean, displaySurface: string, height: {min: string, max: string}}}|{audio: boolean, video: {optional: {sourceId: string}[], mandatory: {minFrameRate: number, maxFrameRate: number}}}}\r\n     */\r\n    MediaDevice.prototype.getScreenShareConstraints = function (data) {\r\n        let screenConstraints\r\n        /***\r\n         * for all supported getDisplayMedia browser versions\r\n         */\r\n        if (navigator.mediaDevices.getDisplayMedia) {\r\n            screenConstraints = {\r\n                audio: false,\r\n                video: {\r\n                    width: {max: '1920'},\r\n                    height: {max: '1080'},\r\n                    frameRate: {max: '5'}\r\n                }\r\n            };\r\n        }\r\n\r\n        /***\r\n         * for Firefox\r\n         */\r\n        if (!!navigator.mozGetUserMedia) {\r\n            screenConstraints = {\r\n                audio: false,\r\n                video: {\r\n                    mozMediaSource: source,\r\n                    mediaSource: source,\r\n                    width: {min: '10', max: '1920'},\r\n                    height: {min: '10', max: '1080'},\r\n                    frameRate: {min: '1', max: '5'}\r\n                }\r\n            };\r\n        }\r\n\r\n        /***\r\n         * for Edge\r\n         */\r\n        if (adapter.browserDetails.browser === \"edge\") {\r\n            if (adapter.browserDetails.version >= 17134 && !!navigator.getDisplayMedia) {\r\n                screenConstraints = {\r\n                    audio: false,\r\n                    video: {\r\n                        displaySurface: 'window',\r\n                        logicalSurface: true,\r\n                        width: {min: '10', max: '1920'},\r\n                        height: {min: '10', max: '1080'},\r\n                        frameRate: {min: '1', max: '5'}\r\n                    }\r\n                };\r\n            } else {\r\n                log.warn(\"This version of Edge does not support screen capture feature\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        /***\r\n         * For IE / Safari which is installed webrtc-everywhere\r\n         */\r\n        if ((adapter.browserDetails.browser === \"ie\" || adapter.browserDetails.browser === \"safari\") && adapter.browserDetails.isWebRTCPluginInstalled === true) {\r\n            screenConstraints = {\r\n                audio: false,\r\n                video: {\r\n                    optional: [{sourceId: \"X978GrandstreamScreenCapturer785\"}],\r\n                    mandatory: {\r\n                        minFrameRate: 1,\r\n                        maxFrameRate: 5\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        return screenConstraints\r\n    }\r\n\r\n    /***\r\n     * 根据deviceId 获取当前设备的设备支持能力\r\n     * 设备信息定时更新的，所以deviceId不会存在不匹配问题\r\n     * @param deviceId\r\n     * @returns {Array}\r\n     */\r\n    MediaDevice.prototype.getCapability = function (deviceId) {\r\n        let This = this\r\n        let mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        let capability = []\r\n        let cameras = mediaDevice.cameras\r\n        if (cameras && cameras.length) {\r\n            for (let i = 0; i < cameras.length; i++) {\r\n                if (cameras[i].deviceId === deviceId) {\r\n                    capability = cameras[i].capability\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!capability.length) {\r\n            capability = This.getQuickScanList()\r\n        }\r\n        log.info(\"capability: \", capability)\r\n\r\n        return capability\r\n    }\r\n\r\n    return MediaDevice;\r\n\r\n}));\n/*Log Debug Start*/\r\nvar log = { };\r\nlog.debug = window.debug(\"sipWebRTC:DEBUG\");\r\nlog.log   = window.debug(\"sipWebRTC:LOG\");\r\nlog.info  = window.debug(\"sipWebRTC:INFO\");\r\nlog.warn  = window.debug(\"sipWebRTC:WARN\");\r\nlog.error = window.debug(\"sipWebRTC:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * WebRTC API Instance\r\n * @constructor\r\n */\r\nlet GsRTC = function (options) {\r\n    this.device = null\r\n    this.sipStack = null\r\n    this.sokect = null\r\n    this.RTCSession = null\r\n\r\n    this.EVENTS = []\r\n    // 上层注册事件\r\n    this.handlerFuns = []\r\n    this.conf = options;\r\n    this.sessionVersion = 0\r\n    this.enableMultiStream = false\r\n    this.action = null\r\n\r\n    this.transaction = null\r\n    this.isRecvRequest = false    // true => recv request\r\n    this.isSendReInvite = false\r\n    this.inviteProcessing = false\r\n    this.sendInviteQueue = []\r\n\r\n    // if(options){\r\n    //     this.loadStorageConfiguration();\r\n    // }\r\n    //\r\n    // this.deviceInit()\r\n    // this.eventBindings()\r\n}\r\n\r\n/**\r\n * set storage settings\r\n */\r\nGsRTC.prototype.loadStorageConfiguration = function () {\r\n    log.info('local storage configuration')\r\n    /* 这里设置fec的开关控制阀 */\r\n    if (this.getBrowserDetail().browser === 'chrome'&& this.getBrowserDetail().version >= 69 || this.getBrowserDetail().browser === 'safari'){\r\n        log.info('set test_red_ulpfec_enabled false')\r\n        localStorage.setItem(\"test_red_ulpfec_enabled\", 'false');\r\n    }else{\r\n        if(localStorage.test_red_ulpfec_enabled === undefined){\r\n            log.info('set test_red_ulpfec_enabled true')\r\n            localStorage.setItem(\"test_red_ulpfec_enabled\", 'true');\r\n        }\r\n    }\r\n\r\n    /* set switch of trickle_ice */\r\n    if(localStorage.trickle_ice === undefined){\r\n        log.info('set trickle_ice false')\r\n        localStorage.setItem(\"trickle_ice\", 'false');\r\n    }\r\n}\r\n\r\n/**\r\n * available device scan and capability scan\r\n */\r\nGsRTC.prototype.deviceInit = function () {\r\n    log.info('device init')\r\n    let This = this\r\n    if(window.MediaDevice){\r\n        This.device =  new MediaDevice()\r\n        This.device.enumDevices(deviceInfo => {\r\n            log.log('enumDevices' + JSON.stringify(deviceInfo))\r\n            This.device.availableDev = {}\r\n            This.device.availableDev.videoInputList = deviceInfo.cameras\r\n            This.device.availableDev.audioOutputList = deviceInfo.speakers\r\n            This.device.availableDev.audioInputList = deviceInfo.microphones\r\n            This.device.checkAvailableDev()\r\n            setTimeout(function () {\r\n                This.device.setDeviceCapability()\r\n            }, 1000)\r\n        }, function (error) {\r\n            log.error('enum device error: ' + error)\r\n        })\r\n    }else {\r\n        log.info('MediaDevice is not exist!')\r\n    }\r\n}\r\n\r\n\r\n\n\r\nwindow.onload = function () {\r\n    var oReadyStateTimer = setInterval(function () {\r\n            if (document.readyState === \"complete\") {\r\n                if(!GsRTC){\r\n                    log.warn(\"ERR_NOT_LOADED: GsRTC not loaded yet.\")\r\n                    return\r\n                }\r\n                clearInterval(oReadyStateTimer);\r\n                // initialize gsRTC\r\n                GsRTC.prototype.preInit()\r\n            }\r\n        },\r\n        500);\r\n}\r\n\r\n/**\r\n * gsRTC init\r\n */\r\nGsRTC.prototype.preInit = function() {\r\n    log.info('create new GsRTC object');\r\n    try {\r\n        let options = {}\r\n        window.gsRTC = new GsRTC(options);\r\n        /* Listen for postMessage messages thrown on webWorker*/\r\n        window.onmessage = function(event){\r\n            gsRTC.onmessage(event)\r\n        }\r\n    }catch (e) {\r\n        log.error(e.toString())\r\n    }\r\n}\r\n\r\n/**\r\n * Binding page media elements\r\n * @param args\r\n */\r\nGsRTC.prototype.setHtmlMediaElement = function(args){\r\n    try {\r\n        this.HTML_MEDIA_ELEMENT.localAudio = args.localAudio\r\n        this.HTML_MEDIA_ELEMENT.localVideo = args.localVideo\r\n        this.HTML_MEDIA_ELEMENT.localPresentVideo = args.localPresentVideo\r\n        this.HTML_MEDIA_ELEMENT.localVideoShare = args.localVideoShare\r\n        this.HTML_MEDIA_ELEMENT.remoteAudio = args.remoteAudio\r\n        this.HTML_MEDIA_ELEMENT.remoteVideo = args.remoteVideo\r\n        this.HTML_MEDIA_ELEMENT.remotePresentVideo = args.remotePresentVideo\r\n        this.HTML_MEDIA_ELEMENT.remoteVideoShare = args.remoteVideoShare\r\n    }catch (e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Open to upper-level event registration interface\r\n * eventType：Event type\r\n * handerFun：User-defined processing functions\r\n */\r\nGsRTC.prototype.addSipEventHandler = function(eventType,handlerFun){\r\n    this.preInit();\r\n    if (window.gsRTC){\r\n        window.gsRTC.on(eventType,handlerFun);\r\n        window.gsRTC.handlerFuns[eventType] = handlerFun;\r\n    }else {\r\n        log.error(\"ERR_NOT_INITIALIZED: Engine not initialized yet. Please create gsRTC first\");\r\n    }\r\n}\r\n\r\n/**\r\n * Sip registration information\r\n *\r\n * sipRegisterInfo：Sip Required fields for registration\r\n * sipRegisterInfo：Sip:{\r\n * \t\tp_realm : \"dsf\",\r\n\t\tp_impi : \"f\",\r\n\t\tp_passwd : \"\",\r\n\t\tp_displayname : \"\",\r\n\t\tp_websocketurl : \"\",\r\n\t\tp_iceservers : \"\"\r\n * }\r\n *\r\n * cb_register：Registration result callback function\r\n * cb_register：function(err:undefined|ErrorObject)\r\n */\r\nGsRTC.prototype.sipRegister = function(sipRegisterInfo,registerCb) {\r\n    if(!sipRegisterInfo){\r\n        log.error(\"sipRegister failed!\");\r\n        registerCb(\"RegisterSipError:ArgumentInvalid\");\r\n        return;\r\n    }\r\n\r\n    if(this.device){\r\n        log.info('set device check interval')\r\n        this.device.setDeviceCheckInterval(true)\r\n    }\r\n\r\n    if(this.conf){\r\n        this.conf.sipRealm = sipRegisterInfo.sipRealm;\r\n        this.conf.sipImpi = sipRegisterInfo.sipImpi;\r\n        this.conf.sipPasswd = sipRegisterInfo.sipPasswd;\r\n        this.conf.sipDispalyName = sipRegisterInfo.sipDispalyName;\r\n\r\n        // Grandstream gsmeeting/webrtc_chrome 74.0.3729.108\r\n        this.conf.userAgent= sipRegisterInfo.userAgent ? sipRegisterInfo.userAgent :  \"Grandstream gsmeeting/webrtc_\" + this.getBrowserDetail().browser + ' ' + this.detectBrowser().UIVersion\r\n        this.conf.host = sipRegisterInfo.host    // df7jal23ls0d.invalid\r\n        this.conf.organization = sipRegisterInfo.organization ? sipRegisterInfo.organization : 'Grandstream'\r\n\r\n        this.conf.protocol = sipRegisterInfo.protocol\r\n        this.conf.websocketUrl = sipRegisterInfo.websocketUrl;\r\n\r\n        this.conf.iceServer = sipRegisterInfo.iceServers;\r\n        this.conf.iceTransportPolicy = sipRegisterInfo.iceTransportPolicy;\r\n        this.conf.RTCpeerConnectionOptional = sipRegisterInfo.RTCpeerConnectionOptional;\r\n    }\r\n    this.action = 'onRegister'\r\n    this.on('onRegister', registerCb)\r\n\r\n    this.sokect = new WebSocketInstance(sipRegisterInfo.websocketUrl, sipRegisterInfo.protocol || 'sip')\r\n    this.sipStack = new SipStack(sipRegisterInfo, registerCb, this)\r\n    this.sipStack.jsSipSendRegister(3600)\r\n}\r\n\r\n/**\r\n * call and send invite\r\n * @param sipCallInfo\r\n * @param callback\r\n */\r\nGsRTC.prototype.call = function (sipCallInfo, callback) {\r\n    if(!sipCallInfo){\r\n        throw new Error('ERR_INVALID_PARAMETER_VALUE');\r\n    }\r\n\r\n    if(this.conf){\r\n        this.conf.sessionsConfig = sipCallInfo.sessionsConfig;\r\n        this.conf.to = sipCallInfo.to\r\n        this.conf.initialResolution = sipCallInfo.initialResolution\r\n    }\r\n    if (this.sipStack.conf){\r\n        this.sipStack.conf.allocate = 'sip:'+ sipCallInfo.to + '@' + this.conf.sipRealm\r\n    }\r\n\r\n    this.action = 'onCall'\r\n    this.on('onCall', callback)\r\n    this.RTCSession = new PeerConnection(sipCallInfo, this)\r\n\r\n    if(sipCallInfo.enableMultiStream){\r\n        log.info('set enableMultiStream true')\r\n        localStorage.setItem(\"enableMultiStream\", 'true');\r\n        this.enableMultiStream = true\r\n        this.RTCSession.createMultiStreamRTCSession(this.conf)\r\n    }else {\r\n        log.info('set enableMultiStream false')\r\n        localStorage.setItem(\"enableMultiStream\", 'false');\r\n        this.enableMultiStream = false\r\n        this.RTCSession.createRTCSession(this.conf)\r\n    }\r\n}\r\n\r\n/**\r\n * Leave the meeting\r\n */\r\nGsRTC.prototype.hangup = function () {\r\n    if(!this.sipStack){\r\n        log.error('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if(!this.RTCSession){\r\n        log.error(\"RTCSession is not initialized\")\r\n        return\r\n    }\r\n    try {\r\n        this.sipStack.jsSipSendBye()\r\n        for (let key in this.RTCSession.peerConnections) {\r\n            let pc = this.RTCSession.peerConnections[key];\r\n            // close stream\r\n            let type = this.RTCSession.getStreamType(pc.type, true)\r\n            this.RTCSession.closeStream(this.MEDIA_STREAMS[type])\r\n\r\n            // close peerConnection\r\n            pc.getSenders().forEach(sender => {\r\n                delete sender.track\r\n                sender.replaceTrack(null)\r\n            })\r\n            pc.close()\r\n        }\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n/**\r\n * share local audio\r\n * @param data\r\n * data.stream\r\n * data.deviceId: given deviceId\r\n */\r\nGsRTC.prototype.shareAudio = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('invalid RTCSession parameters! can not share audio')\r\n        return\r\n    }\r\n\r\n    log.info('share local audio: ' + data.deviceId)\r\n    let This = this\r\n    let type = 'audio'\r\n    let stream = this.RTCSession.getStream(type, true)\r\n    if(stream){\r\n        this.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: false})\r\n    }else {\r\n        log.info('getting new stream')\r\n        async function getMediaCallBack(args){\r\n            if(args.stream){\r\n                let stream = args.stream\r\n                log.info('get stream: ' +  stream ? stream.id : null)\r\n                This.RTCSession.setStream(stream, type, true)\r\n                let pc\r\n                if(This.enableMultiStream){\r\n                    pc = This.RTCSession.peerConnections['multiStreamPeer']\r\n                }else {\r\n                    pc = This.RTCSession.peerConnections[type]\r\n                }\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                await This.RTCSession.doOffer(pc)\r\n            }else if(args.error){\r\n                log.error('Get audio stream failed: ' + args.error)\r\n                data.callback({error: args.error})\r\n            }\r\n        }\r\n\r\n        let conf = { streamType: type, callback: getMediaCallBack }\r\n        let constraints = {\r\n            audio: data.deviceId ? { deviceId: data.deviceId }: true,\r\n            video: false\r\n        }\r\n\r\n        this.action = 'audioRefresh'\r\n        this.on('audioRefresh', data.callback)\r\n        this.sendInviteQueue.push({ action: 'audioRefresh', sdp: null })\r\n        this.device.getMedia(conf, constraints)\r\n    }\r\n}\r\n\r\n/**\r\n * 切换音频源\r\n * @param data\r\n * data.callback\r\n * data.deviceId\r\n */\r\nGsRTC.prototype.switchAudioSource = function(data) {\r\n    log.info('switch audio source: ' + data.deviceId)\r\n    if(!this.RTCSession){\r\n        log.error('switchAudioSource: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    let This = this\r\n    let type = data.type\r\n    let previousStream = this.RTCSession.getStream(type, true)\r\n    let pc\r\n    if(This.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    async function getMediaCallBack(event){\r\n        if(event.stream){\r\n            let stream = event.stream\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                data.callback({codeType: 200})\r\n            }else {\r\n                log.info('clear previous stream')\r\n                This.sendInviteQueue.push({ action: 'switchAudioSource', sdp: null })\r\n                This.RTCSession.processRemoveStream(previousStream, pc, type)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                await This.RTCSession.doOffer(pc)\r\n            }\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n        }else {\r\n            log.error(event.error)\r\n            data.callback({error:event.error})\r\n        }\r\n    }\r\n\r\n    let conf = { streamType: type, callback: getMediaCallBack }\r\n    let  constraints = {\r\n        audio: data.deviceId ? { deviceId: data.deviceId } : true,\r\n        video: false\r\n    }\r\n\r\n    this.action = 'switchAudioSource'\r\n    this.on('switchAudioSource', data.callback)\r\n    this.device.getMedia(conf, constraints)\r\n}\r\n\r\n/**\r\n * stop share local audio\r\n * @param data: callback\r\n */\r\nGsRTC.prototype.stopShareAudio = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('stopShareAudio: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    try {\r\n        let type = data.type\r\n        let stream = this.RTCSession.getStream(type, true)\r\n        if(stream){\r\n            this.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: true})\r\n        }else {\r\n            log.info('Audio stream: null')\r\n        }\r\n    }catch (e) {\r\n        log.error(e.toString())\r\n        data.callback({error: e})\r\n    }\r\n}\r\n\r\n/**\r\n * 开启本地视频\r\n * @param data\r\n * data.stream\r\n * data.type\r\n * data.deviceId\r\n */\r\nGsRTC.prototype.shareVideo = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('shareVideo: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let This = this\r\n    let type = 'main'\r\n    let previousStream = This.RTCSession.getStream(type, true)\r\n    let pc\r\n    if(This.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n    let param = {\r\n        streamType: 'video',\r\n        constraintsKeyWord: 'exact',\r\n        deviceId: data.deviceId,\r\n        frameRate: 30,\r\n        width: 640,\r\n        height: 360,\r\n    }\r\n    let constraints = this.device.getConstraints(param)\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            log.info('get stream success')\r\n            let stream = event.stream\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                if(data.callback){\r\n                    data.callback({codeType: 200})\r\n                }\r\n            }else {\r\n                log.info('clear previous stream')\r\n                This.sendInviteQueue.push({ action: 'shareVideo', sdp: null })\r\n                This.RTCSession.processRemoveStream(previousStream, pc, type)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                This.RTCSession.doOffer(pc)\r\n            }\r\n\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n\r\n            This.RTCSession.deviceId = data.deviceId  // save deviceId\r\n            This.setVideoResolution({width: param.width, height: param.height}, 'CURRENT_UP_RESOLUTION')\r\n        }else {\r\n            log.info('get stream failed')\r\n            data.callback({error: event.error})\r\n            log.error(event.error)\r\n        }\r\n    }\r\n\r\n    let gumData = { streamType: 'video', callback: getMediaCallBack }\r\n    this.action = 'shareVideo'\r\n    this.on('shareVideo', data.callback)\r\n    this.device.getMedia(gumData, constraints)\r\n}\r\n\r\n/**\r\n * 关闭本地视频\r\n * @param data 回调函数\r\n */\r\nGsRTC.prototype.stopShareVideo = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('stopShareVideo: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'main'\r\n    let stream = this.RTCSession.getStream(type, true)\r\n    let pc\r\n    if(this.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    if(stream){\r\n        this.action = 'stopShareVideo'\r\n        this.on('stopShareVideo', data.callback)\r\n        this.sendInviteQueue.push({ action: 'stopShareVideo', sdp: null })\r\n\r\n        log.info('clear previous stream')\r\n        this.RTCSession.deviceId = null\r\n        this.RTCSession.processRemoveStream(stream, pc, type)\r\n        this.RTCSession.closeStream(stream)\r\n        this.RTCSession.setStream(null, type, true)\r\n        this.RTCSession.doOffer(pc)\r\n    }else {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: VIDEO STREAM IS NULL\");\r\n    }\r\n}\r\n\r\n/**\r\n * to be host\r\n * @param data\r\n */\r\nGsRTC.prototype.hostMeeting = function (data) {\r\n    if(!data.contentType || !data.body){\r\n        log.error('invalid parameters!')\r\n        return\r\n    }\r\n\r\n    this.action = 'onHostMeeting'\r\n    this.on('onHostMeeting', data.callback)\r\n    this.sipStack.jsSipSendInfo(data.contentType, data.body)\r\n}\r\n\r\n/**\r\n * 开启桌面演示\r\n * @param data\r\n * data.stream: 要共享的视频流\r\n * data.callback\r\n */\r\nGsRTC.prototype.shareScreen = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('shareScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let This = this\r\n    let type = 'slides'\r\n    let pc\r\n    if(This.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    this.action = 'shareScreen'\r\n    this.on('shareScreen', data.callback)\r\n    this.sendInviteQueue.push({ action: 'shareScreen', sdp: null })\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            log.info('get stream success, ' + event.stream.id)\r\n            let stream = event.stream\r\n            stream.oninactive = function () {\r\n                log.warn(\"user clicks the bottom share bar to stop sharing\")\r\n                let stream = This.RTCSession.getStream(\"slides\", true)\r\n                This.RTCSession.closeStream(stream);\r\n                This.stopShareScreen({\r\n                    type: 'slides',\r\n                    callback: data.callback\r\n                })\r\n            }\r\n\r\n            This.RTCSession.setStream(stream, type, true)\r\n            This.RTCSession.processAddStream(stream, pc, type)\r\n            This.RTCSession.doOffer(pc)\r\n        }else {\r\n            log.warn('Get present stream failed: ' + event.error)\r\n            data.callback({error: event.error})\r\n        }\r\n    }\r\n\r\n    let gumData = {\r\n        streamType: 'screenShare',\r\n        callback: getMediaCallBack\r\n    }\r\n    this.device.getMedia(gumData, data.constraints)\r\n}\r\n\r\n/**\r\n * 切换桌面共享源\r\n * @param data.type 类型：\"window\"/\"screen\"/\"whiteboard\"/\"tab\"\r\n * @param data.callback 回调函数\r\n */\r\nGsRTC.prototype.switchScreenSource = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('switchScreenSource: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let This = this\r\n    let type = 'slides'\r\n    let previousStream = This.RTCSession.getStream(type, true)\r\n    let pc\r\n    if(This.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    this.action = 'switchScreenSource'\r\n    this.on('switchScreenSource', data.callback)\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            let stream = event.stream\r\n            stream.oninactive = function () {\r\n                log.warn(\"user clicks the bottom share bar to stop sharing\")\r\n                let stream = This.RTCSession.getStream(\"slides\", true)\r\n                This.RTCSession.closeStream(stream);\r\n                This.stopShareScreen({\r\n                    type: 'slides',\r\n                    callback: data.callback\r\n                })\r\n            }\r\n\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                log.info('use replace track to switch presentation stream')\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                data.callback({codeType: This.CODE_TYPE.ACTION_SUCCESS})\r\n            }else {\r\n                This.sendInviteQueue.push({ action: 'switchScreenSource', sdp: null })\r\n                This.RTCSession.processRemoveStream(previousStream, pc)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                This.RTCSession.doOffer(pc)\r\n            }\r\n\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n        }else {\r\n            log.error(event.error.toString())\r\n            data.callback({error: event.error})\r\n        }\r\n    }\r\n\r\n    let gumData = {\r\n        streamType: 'screenShare',\r\n        callback: getMediaCallBack\r\n    }\r\n    this.device.getMedia(gumData, data.constraints)\r\n}\r\n\r\n/**\r\n * 关闭桌面演示\r\n * @param data\r\n */\r\nGsRTC.prototype.stopShareScreen = function(data) {\r\n    if(!this.RTCSession){\r\n        log.error('stopShareScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'slides'\r\n    let stream = this.RTCSession.getStream(type, true)\r\n    let pc\r\n    if(this.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    if(stream){\r\n        this.action = 'stopShareScreen'\r\n        this.on('stopShareScreen', data.callback)\r\n        this.sendInviteQueue.push({ action: 'stopShareScreen', sdp: null })\r\n\r\n        log.info('clear previous stream')\r\n        this.RTCSession.processRemoveStream(stream, pc, type)\r\n        this.RTCSession.closeStream(stream)\r\n        this.RTCSession.setStream(null, type, true)\r\n        this.RTCSession.doOffer(pc)\r\n    }\r\n}\r\n\r\n/**\r\n * 发送DTMF\r\n * @param data.digit 发送的内容\r\n * @param data.callback 回调函数\r\n */\r\nGsRTC.prototype.sendDtmf = function(data){\r\n    log.info('send dtmf digit:  ' + data.digit)\r\n    if(!this.RTCSession){\r\n        log.error('sendDtmf: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    let type = 'audio'\r\n    let pc\r\n    if(this.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    let dtmfSender\r\n    if(pc.getSenders){\r\n        let senders = pc.getSenders();\r\n        let audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');\r\n        if (!audioSender) {\r\n            log.warn('No local audio track to send DTMF with');\r\n            return\r\n        }else {\r\n            dtmfSender = audioSender.dtmf;\r\n        }\r\n\r\n        if (dtmfSender && dtmfSender.canInsertDTMF) {\r\n            log.info(\"prepare send digit: \"+ data.digit);\r\n            dtmfSender.insertDTMF(data.digit);\r\n        }else {\r\n            log.warn(\"DTMF function not available\");\r\n        }\r\n    }else {\r\n        log.warn('getSenders is not available by current browser version')\r\n    }\r\n}\r\n\r\n/***\r\n * 调整下行分辨率\r\n * @param data\r\n */\r\nGsRTC.prototype.adjustResolution = function(data){\r\n    if(!this.RTCSession){\r\n        log.error('adjustResolution: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    if(!data || !data.height){\r\n        log.error('adjustResolution: ERR_INVALID_PARAMETER_VALUE')\r\n        return\r\n    }\r\n    log.info('adjust down resolution:  ' + data.height)\r\n\r\n    let type = 'main'\r\n    let pc\r\n    if(this.enableMultiStream){\r\n        pc = this.RTCSession.peerConnections['multiStreamPeer']\r\n    }else {\r\n        pc = this.RTCSession.peerConnections[type]\r\n    }\r\n\r\n    this.action = 'adjustResolution'\r\n    this.on('adjustResolution', data.callback)\r\n    this.setVideoResolution(this.getResolutionByHeight(data.height), 'EXPECT_RECV_RESOLUTION')\r\n\r\n    this.sendInviteQueue.push({ action: 'adjustResolution', sdp: null })\r\n    this.RTCSession.doOffer(pc)\r\n}\r\n\r\n\r\n\nGsRTC.prototype.CODE_TYPE = {\r\n    // sip信令错误码 200- 699\r\n    REGISTER_ERROR: 200,\r\n    INVITE_ERROR: 201,\r\n\r\n    //success code\r\n    ACTION_SUCCESS: 999\r\n}\n/**\r\n * Function that subscribes a listener to an event.\r\n * @method on\r\n * @param {String} eventName The event.\r\n * @param {Function} callback The listener.\r\n */\r\nGsRTC.prototype.on = function(eventName, callback) {\r\n    if ('function' === typeof callback) {\r\n        this.EVENTS[eventName] = this.EVENTS[eventName] || [];\r\n        this.EVENTS[eventName].push(callback);\r\n    } else {\r\n        throw 'Provided parameter is not a function'\r\n    }\r\n};\r\n\r\n/**\r\n * Function that unsubscribes listeners from an event.\r\n * @method off\r\n * @param {String} [eventName] The event.\r\n * - When not provided, all listeners to all events will be unsubscribed.\r\n * @param {Function} [callback] The listener to unsubscribe.\r\n * - When not provided, all listeners associated to the event will be unsubscribed.\r\n */\r\nGsRTC.prototype.off = function(eventName, callback) {\r\n    if (!(eventName && typeof eventName === 'string')) {\r\n        this.EVENTS = {};\r\n    } else {\r\n        if (callback === undefined) {\r\n            this.EVENTS[eventName] = [];\r\n            return;\r\n        }\r\n        let arr = this.EVENTS[eventName] || [];\r\n\r\n        // unsubscribe events that is triggered always\r\n        for (let i = 0; i < arr.length; i++) {\r\n            if (arr[i] === callback) {\r\n                arr.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Function that triggers an event.\r\n * The rest of the parameters after the <code>eventName</code> parameter is considered as the event parameter payloads.\r\n * @method trigger\r\n */\r\nGsRTC.prototype.trigger = function(eventName) {\r\n    //convert the arguments into an array\r\n    let args = Array.prototype.slice.call(arguments);\r\n    let arr = this.EVENTS[eventName];\r\n    args.shift(); //Omit the first argument since it's the event name\r\n    if (arr) {\r\n        // for events subscribed forever\r\n        for (let i = 0; i < arr.length; i++) {\r\n            try {\r\n                if(arr[i].apply(this, args) === false) {\r\n                    break;\r\n                }\r\n            } catch(error) {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Function that Determine whether it is nxx corresponding, such as: isResponseNxx(2, 200) ==> true\r\n * @param i\r\n * @param code Received status code, such 200\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isNxx= function(i, code) {\r\n    return ((i * 100) <= code && code <= ((i * 100) + 99));\r\n}\r\n\r\n/***\r\n * Function that Generate a UUID as the unique identifier of the peer ID\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.generateUUID = function() {\r\n    let d = new Date().getTime();\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        let r = (d + Math.random() * 16) % 16 | 0;\r\n        d = Math.floor(d / 16);\r\n        return (c === 'x' ? r : (r && 0x7 | 0x8)).toString(16);\r\n    });\r\n};\r\n\r\n/***\r\n * get file url\r\n * @param file\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getObjectURL = function(file) {\r\n    let url = null;\r\n    if (window.createObjectURL !== undefined) { // basic\r\n        url = window.createObjectURL(file);\r\n    } else if (window.URL !== undefined) { // mozilla(firefox)\r\n        url = window.URL.createObjectURL(file);\r\n    } else if (window.webkitURL !== undefined) { // webkit or chrome\r\n        url = window.webkitURL.createObjectURL(file);\r\n    }\r\n    return url;\r\n}\r\n\r\n/***\r\n * Function that deep clone an object.\r\n * @param obj\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.objectDeepClone = function(obj) {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    let copy = function (data) {\r\n        let copy = data.constructor();\r\n        for (let attr in data) {\r\n            if (data.hasOwnProperty(attr)) {\r\n                copy[attr] = data[attr];\r\n            }\r\n        }\r\n        return copy;\r\n    };\r\n\r\n    if (typeof obj === 'object' && !Array.isArray(obj)) {\r\n        try {\r\n            return JSON.parse( JSON.stringify(obj) );\r\n        } catch (err) {\r\n            return copy(obj);\r\n        }\r\n    }\r\n\r\n    return copy(obj);\r\n};\r\n\r\n/***\r\n * Function that Depth comparison of two objects is completely equal\r\n * @param x\r\n * @param y\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isObjectXExactlyEqualToY = function(x, y) {\r\n    let i, l, leftChain, rightChain;\r\n\r\n    function compare2Objects(x, y) {\r\n        let p;\r\n\r\n        // remember that NaN === NaN returns false\r\n        // and isNaN(undefined) returns true\r\n        if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\r\n            return true;\r\n        }\r\n\r\n        // Compare primitives and functions.\r\n        // Check if both arguments link to the same object.\r\n        // Especially useful on the step where we compare prototypes\r\n        if (x === y) {\r\n            return true;\r\n        }\r\n\r\n        // Works in case when functions are created in constructor.\r\n        // Comparing dates is a common scenario. Another built-ins?\r\n        // We can even handle functions passed across iframes\r\n        if ((typeof x === 'function' && typeof y === 'function') ||\r\n            (x instanceof Date && y instanceof Date) ||\r\n            (x instanceof RegExp && y instanceof RegExp) ||\r\n            (x instanceof String && y instanceof String) ||\r\n            (x instanceof Number && y instanceof Number)) {\r\n            return x.toString() === y.toString();\r\n        }\r\n\r\n        // At last checking prototypes as good as we can\r\n        if (!(x instanceof Object && y instanceof Object)) {\r\n            return false;\r\n        }\r\n\r\n        if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\r\n            return false;\r\n        }\r\n\r\n        if (x.constructor !== y.constructor) {\r\n            return false;\r\n        }\r\n\r\n        if (x.prototype !== y.prototype) {\r\n            return false;\r\n        }\r\n\r\n        // Check for infinitive linking loops\r\n        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\r\n            return false;\r\n        }\r\n\r\n        // Quick checking of one object being a subset of another.\r\n        // todo: cache the structure of arguments[0] for performance\r\n        for (p in y) {\r\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n                return false;\r\n            } else if (typeof y[p] !== typeof x[p]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (p in x) {\r\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n                return false;\r\n            } else if (typeof y[p] !== typeof x[p]) {\r\n                return false;\r\n            }\r\n\r\n            switch (typeof(x[p])) {\r\n                case 'object':\r\n                case 'function':\r\n\r\n                    leftChain.push(x);\r\n                    rightChain.push(y);\r\n\r\n                    if (!compare2Objects(x[p], y[p])) {\r\n                        return false;\r\n                    }\r\n\r\n                    leftChain.pop();\r\n                    rightChain.pop();\r\n                    break;\r\n\r\n                default:\r\n                    if (x[p] !== y[p]) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    if (arguments.length < 1) {\r\n        log.warn('Need two or more arguments to compare')\r\n        return true;\r\n    }\r\n\r\n    for (i = 1, l = arguments.length; i < l; i++) {\r\n        leftChain = [];\r\n        rightChain = [];\r\n\r\n        if (!compare2Objects(arguments[0], arguments[i])) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Determine if the browser supports ReplaceTrack\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isReplaceTrackSupport = function() {\r\n    let browserDetails = this.getBrowserDetail()\r\n    let result = false\r\n\r\n    switch (browserDetails.browser) {\r\n        case 'chrome':\r\n            result = browserDetails.version >= 72\r\n            break\r\n        case 'opera':\r\n            result = browserDetails.version >= 59\r\n            break\r\n        case 'firefox':\r\n            result = browserDetails.version >= 59\r\n            break\r\n        case 'safari':\r\n            result = browserDetails.version >= '12.1.1'\r\n            break\r\n        default:\r\n            break\r\n    }\r\n\r\n    log.info(browserDetails.browser + ' ' + browserDetails.version +' version support replaceTrack : ' + result)\r\n    return result\r\n}\r\n\r\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\r\nGsRTC.prototype.getBrowserDetail = function () {\r\n    function extractVersion(uastring, expr, pos) {\r\n        let match = uastring.match(expr);\r\n        return match && match.length >= pos && parseInt(match[pos], 10);\r\n    }\r\n\r\n    var navigator = window && window.navigator;\r\n\r\n    // Returned result object.\r\n    var result = {};\r\n    result.browser = null;\r\n    result.version = null;\r\n    result.UIVersion = null;\r\n    result.chromeVersion = null;\r\n\r\n    // Fail early if it's not a browser\r\n    if (typeof window === 'undefined' || !window.navigator) {\r\n        result.browser = 'Not a browser.';\r\n        return result;\r\n    }\r\n\r\n    // Edge.\r\n    if (navigator.mediaDevices &&\r\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\r\n        result.browser = 'edge';\r\n        result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\r\n        result.UIVersion = navigator.userAgent.match(/Edge\\/([\\d.]+)/)[1]; //Edge/16.17017\r\n\r\n    } // IE\r\n    else if (!navigator.mediaDevices && (!!window.ActiveXObject || 'ActiveXObject' in window || navigator.userAgent.match(/MSIE (\\d+)/) || navigator.userAgent.match(/rv:(\\d+)/))) {\r\n        result.browser = 'ie';\r\n        if (navigator.userAgent.match(/MSIE (\\d+)/)) {\r\n            result.version = extractVersion(navigator.userAgent, /MSIE (\\d+).(\\d+)/, 1);\r\n            result.UIVersion = navigator.userAgent.match(/MSIE ([\\d.]+)/)[1]; //MSIE 10.6\r\n\r\n        } else if (navigator.userAgent.match(/rv:(\\d+)/)) {\r\n            /*For IE 11*/\r\n            result.version = extractVersion(navigator.userAgent, /rv:(\\d+).(\\d+)/, 1);\r\n            result.UIVersion = navigator.userAgent.match(/rv:([\\d.]+)/)[1]; //rv:11.0\r\n        }\r\n\r\n        // Firefox.\r\n    } else if (navigator.mozGetUserMedia) {\r\n        result.browser = 'firefox';\r\n        result.version = extractVersion(navigator.userAgent,\r\n            /Firefox\\/(\\d+)\\./, 1);\r\n        result.UIVersion = navigator.userAgent.match(/Firefox\\/([\\d.]+)/)[1]; //Firefox/56.0\r\n\r\n        // all webkit-based browsers\r\n    } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {\r\n        // Chrome, Chromium, Webview, Opera, Vivaldi all use the chrome shim for now\r\n        var isOpera = navigator.userAgent.match(/(OPR|Opera).([\\d.]+)/) ? true : false;\r\n        //var isVivaldi = navigator.userAgent.match(/(Vivaldi).([\\d.]+)/) ? true : false;\r\n        if (isOpera) {\r\n            result.browser = 'opera';\r\n            result.version = extractVersion(navigator.userAgent, /O(PR|pera)\\/(\\d+)\\./, 2);\r\n            result.UIVersion = navigator.userAgent.match(/O(PR|pera)\\/([\\d.]+)/)[2]; //OPR/48.0.2685.39\r\n            if (navigator.userAgent.match(/Chrom(e|ium)\\/([\\d.]+)/)[2]) {\r\n                result.chromeVersion = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n            }\r\n        }/* else if (isVivaldi) {\r\n          result.browser = 'vivaldi';\r\n          result.version = extractVersion(navigator.userAgent,\r\n                                            /(Vivaldi)\\/(\\d+)\\./, 2);\r\n          result.UIVersion = navigator.userAgent.match(/Vivaldi\\/([\\d.]+)/)[1]; //Vivaldi/1.93.955.38\r\n     }*/ else {\r\n            result.browser = 'chrome';\r\n            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n            result.UIVersion = navigator.userAgent.match(/Chrom(e|ium)\\/([\\d.]+)/)[2]; //Chrome/61.0.3163.100\r\n        }\r\n\r\n        // Safari or unknown webkit-based\r\n        // for the time being Safari has support for MediaStreams but not webRTC\r\n        //Safari without webRTC and with partly webRTC support\r\n    } else if ((!navigator.webkitGetUserMedia && navigator.userAgent.match(/AppleWebKit\\/([0-9]+)\\./)) || (navigator.webkitGetUserMedia && !navigator.webkitRTCPeerConnection)) {\r\n        // Safari UA substrings of interest for reference:\r\n        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)\r\n        // - safari UI version:        Version/9.0.3 (unique to Safari)\r\n        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)\r\n        //\r\n        // if the webkit version and safari UI webkit versions are equals,\r\n        // ... this is a stable version.\r\n        //\r\n        // only the internal webkit version is important today to know if\r\n        // media streams are supported\r\n        //\r\n        if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\r\n            result.browser = 'safari';\r\n            result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\r\n            result.UIVersion = navigator.userAgent.match(/Version\\/([\\d.]+)/)[1]; //Version/11.0.1\r\n\r\n        } else { // unknown webkit-based browser.\r\n            result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.';\r\n            return result;\r\n        }\r\n        // Default fallthrough: not supported.\r\n    } else {\r\n        result.browser = 'Not a supported browser.';\r\n        return result;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Determine if the input string is empty or all spaces\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.tskStringIsNullOrEmpty = function (str) {\r\n    let result\r\n    if(!str || str === \"\"){\r\n        result = true\r\n    }else {\r\n        let regu = \"^[ ]+$\";\r\n        let re = new RegExp(regu);\r\n        result = re.test(str)\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * is string or not\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.tskStringIsString = function(str) {\r\n    return (str instanceof String || typeof str == \"string\");\r\n}\n/*Log Debug Start*/\r\nvar log = { };\r\nlog.debug = window.debug(\"SipStack:DEBUG\");\r\nlog.log   = window.debug(\"SipStack:LOG\");\r\nlog.info  = window.debug(\"SipStack:INFO\");\r\nlog.warn  = window.debug(\"SipStack:WARN\");\r\nlog.error = window.debug(\"SipStack:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * Define the SipStack class\r\n * @param conf\r\n * @param callback\r\n * @param gsRTC\r\n * @returns {SipStack|*}\r\n * @constructor\r\n */\r\nlet SipStack = function (conf, callback, gsRTC) {\r\n    if(this instanceof SipStack){\r\n        this.initialized = false\r\n        this.conf = {}\r\n        this.gsRTC = gsRTC\r\n\r\n        this.jsSipParser = jsSipParser\r\n        this.jsSipInit = jsSipInit\r\n        this.setLogLevel = setLogLevel\r\n        this.jsSipSetConfig = jsSipSetConfig\r\n        this.jsSipStart = jsSipStart\r\n        this.jsSipSendRegister = jsSipSendRegister\r\n        this.jsSipSendInvite = jsSipSendInvite\r\n        this.jsSipSendReInvite = jsSipSendReInvite\r\n        this.jsSipSendRsp = jsSipSendRsp\r\n        this.jsSipSendAck = jsSipSendAck\r\n        this.addHeaderList = addHeaderList\r\n        this.jsSipSendBye = jsSipSendBye\r\n\r\n        this.jsSipSendInfo = function (contentType, body) {\r\n            // add header list info first\r\n            addHeaderList(contentType, body);\r\n            jsSipSendInfo()\r\n        }\r\n\r\n        this.init(conf, callback)\r\n    }else {\r\n        return new SipStack(conf, callback)\r\n    }\r\n}\r\n\r\n/**\r\n * sip init\r\n * @param conf: {\r\n *  userId: userId,\r\n *  password: password,\r\n *  proxyuri: proxyuri,\r\n *  websocketUrl: websocketUrl,\r\n *  host: host,\r\n *  userAgent: userAgent,\r\n *  displayName: displayName,\r\n *  organization: organization,\r\n *  allocate: allocate,\r\n * }\r\n */\r\nSipStack.prototype.init = function (conf, callback) {\r\n    // Parameter check\r\n    log.info('start sip init!')\r\n    let data = Object.keys(conf);\r\n    if(!data.length){\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: null configuration value\");\r\n    }\r\n\r\n    if (conf.sipRealm && !GsRTC.prototype.tskStringIsString(conf.sipRealm)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_TYPE: '\" + typeof conf.sipRealm + \"' not a valid type for sipRealm. String is expected\");\r\n    }\r\n    if (conf.sipImpi && !GsRTC.prototype.tskStringIsString(conf.sipImpi)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_TYPE: '\" + typeof conf.sipImpi + \"' not a valid type for sipImpi. String is expected\");\r\n    }\r\n    if (conf.sipPasswd && !GsRTC.prototype.tskStringIsString(conf.sipPasswd)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_TYPE: '\" + typeof conf.sipPasswd + \"' not a valid type for sipPasswd. String is expected\");\r\n    }\r\n    if (conf.sipDispalyName && !GsRTC.prototype.tskStringIsString(conf.sipDispalyName)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_TYPE: '\" + typeof conf.sipDispalyName + \"' not a valid type for sipDispalyName. String is expected\");\r\n    }\r\n    if (conf.userAgent && !GsRTC.prototype.tskStringIsString(conf.userAgent)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_TYPE: '\" + typeof conf.userAgent + \"' not a valid type for userAgent. String is expected\");\r\n    }\r\n    if (conf.organization && !GsRTC.prototype.tskStringIsString(conf.organization)) {\r\n        log.info(typeof conf.organization + \"' not a valid type for organization. set default 'Grandstream' value\");\r\n        conf.organization = 'Grandstream'\r\n    }\r\n    if (conf.host && !GsRTC.prototype.tskStringIsString(conf.host)) {\r\n        log.info(typeof conf.host + \" not a valid type for host. set default df7jal23ls0d.invalid value\")\r\n        conf.host = 'df7jal23ls0d.invalid'\r\n    }\r\n\r\n    try {\r\n        /* 初始化 */\r\n        this.jsSipInit()\r\n        /* 设置日志级别 */\r\n        this.setLogLevel(2)\r\n        /* 配置WebSocket URL */\r\n        this.jsSipSetConfig(0, '1')\r\n        /* 配置用户名 */\r\n        this.jsSipSetConfig(1, conf.sipImpi)\r\n        /* 配置密码 */\r\n        this.jsSipSetConfig(2, conf.sipPasswd)\r\n        /* 配置proxy URL */\r\n        this.jsSipSetConfig(3, conf.sipRealm)\r\n        /* 配置host */\r\n        this.jsSipSetConfig(5, conf.host)\r\n        /* 配置User-Agent */\r\n        this.jsSipSetConfig(6, conf.userAgent)\r\n        /* 配置displayName */\r\n        this.jsSipSetConfig(7, conf.sipDispalyName)\r\n        /* 配置organization */\r\n        this.jsSipSetConfig(8, conf.organization)\r\n        /* 开始sip */\r\n        this.jsSipStart()\r\n\r\n        this.conf = conf\r\n        this.initialized = true\r\n    }catch (e) {\r\n        callback(e)\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * send sip message\r\n * @param message content such as sdp\r\n * @param contentType  default 'application/sdp'\r\n */\r\nSipStack.prototype.sendSipMessage = function (message, contentType) {\r\n    if(!this.initialized){\r\n        throw new Error(\"SIP Stack not initialized yet. Please init first\");\r\n    }\r\n\r\n    contentType = contentType || 'application/sdp'\r\n    if(this.gsRTC.isRecvRequest){\r\n        log.info('send response')\r\n        this.jsSipSendRsp(this.gsRTC.transaction, 200, contentType, message)\r\n        this.gsRTC.isRecvRequest = false\r\n    }else {\r\n        log.info('send request')\r\n        this.gsRTC.inviteProcessing = true\r\n        if(this.gsRTC.isSendReInvite){\r\n            log.warn('send re-invite')\r\n            this.jsSipSendReInvite(contentType, message)\r\n        }else {\r\n            log.warn('send invite')\r\n            this.jsSipSendInvite(this.conf.allocate , contentType, message);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n/*Log Debug Start*/\r\nvar log = {};\r\nlog.debug = window.debug(\"JSEP:DEBUG\");\r\nlog.log = window.debug(\"JSEP:LOG\");\r\nlog.info = window.debug(\"JSEP:INFO\");\r\nlog.warn = window.debug(\"JSEP:WARN\");\r\nlog.error = window.debug(\"JSEP:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * create PeerConnection instance\r\n * @param config\r\n * @param gsRTC\r\n * @constructor\r\n */\r\nlet PeerConnection = function (config, gsRTC) {\r\n    this.gsRTC = gsRTC\r\n    this.conf = config\r\n    this.deviceId = null\r\n    this.peerConnections = []\r\n}\r\n\r\n/**\r\n * create PeerConnection instance\r\n */\r\nPeerConnection.prototype.createRTCSession = async function (conf) {\r\n    log.info('Get lo: create webRTC session')\r\n    let This = this\r\n    try {\r\n        let sessionsConfig = conf.sessionsConfig ? conf.sessionsConfig : {}\r\n        if (sessionsConfig) {\r\n            if (!this.peerConnections) {\r\n                this.peerConnections = []\r\n            }\r\n            for (let i = 0; i < sessionsConfig.length; i++) {\r\n                let type = sessionsConfig[i]\r\n                this.peerConnections[type] = this.createPeerConnection(type, conf)\r\n                // for wfu add stream\r\n                // let pc = this.peerConnections[type]\r\n                // let stream\r\n                // if(type === 'audio'){\r\n                //     stream = await navigator.mediaDevices.getUserMedia({audio: true, video: false})\r\n                //     console.warn(pc.type + \" add stream: \", stream.id)\r\n                // }else if(type === 'main'){\r\n                //     stream = await navigator.mediaDevices.getUserMedia({audio: false, video: {width: 640, height: 360}})\r\n                //     console.warn(pc.type + \" add stream: \", stream.id)\r\n                //\r\n                // }else if(type === 'video1'){\r\n                //     // stream = await navigator.mediaDevices.getUserMedia({audio: false, video: {width: 1280, height: 720}})\r\n                //     // console.warn(pc.type + \" add stream: \", stream.id)\r\n                // }else if(type === 'slides'){\r\n                //     let constraints = {\r\n                //         audio: false,\r\n                //         video: {\r\n                //             width: { max: 1920, },\r\n                //             height: { max: 1080,},\r\n                //             frameRate: { max: 15,}\r\n                //         }\r\n                //     };\r\n                //\r\n                //     if('getDisplayMedia' in window.navigator){\r\n                //         stream = await navigator.getDisplayMedia(constraints)\r\n                //     }else if('getDisplayMedia' in window.navigator.mediaDevices){\r\n                //         stream = await navigator.mediaDevices.getDisplayMedia(constraints)\r\n                //     }else {\r\n                //         log.warn(\"The browser does not support the getDisplayMedia interface.\");\r\n                //     }\r\n                //\r\n                // }\r\n                //\r\n                // if(stream){\r\n                //     console.warn(pc.type + ' add stream')\r\n                //     This.setMediaElementStream(stream, type, true)\r\n                //     pc.addStream(stream)\r\n                // }\r\n\r\n                if(type === 'main'){\r\n                    log.warn('add '+ type + ' stream')\r\n                    let stream = getCaptureStream(type)\r\n                    log.info('get stream : ', stream.id)\r\n                    This.setStream(stream, type, true)\r\n\r\n                    let pc = this.peerConnections[type]\r\n                    pc.addStream(stream)\r\n                }\r\n\r\n                if(type === 'slides'){\r\n                    log.warn('add '+ type + ' stream')\r\n                    let stream = getSlidesCaptureStream(type)\r\n                    log.info('get stream : ', stream.id)\r\n                    This.setStream(stream, type, true)\r\n\r\n                    let pc = this.peerConnections[type]\r\n                    pc.addStream(stream)\r\n                }\r\n\r\n                this.doOffer(this.peerConnections[type])\r\n            }\r\n        } else {\r\n            log.warn('can not create RTCSession with conf is null')\r\n        }\r\n    } catch (e) {\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n/**\r\n * create webRTC multiStream Peer connection\r\n * @param conf\r\n */\r\nPeerConnection.prototype.createMultiStreamRTCSession = function(conf){\r\n    log.info('create webRTC multiStream Peer connection')\r\n    try {\r\n        let This = this\r\n        let sessionsConfig = conf.sessionsConfig ? conf.sessionsConfig : ['multiStreamPeer']\r\n        let type = sessionsConfig[0]\r\n\r\n        this.peerConnections[type] = This.createPeerConnection(type, conf)\r\n        let pc = this.peerConnections[type]\r\n        // create transceiver\r\n        if(RTCPeerConnection.prototype.addTransceiver){\r\n            log.info('use addTransceiver to add transceiver ');\r\n            // add audio Transceiver to keep audio media first\r\n            pc.addTransceiver('audio')\r\n            pc.addTransceiver('video')\r\n            pc.addTransceiver('video')\r\n        }else {\r\n            log.info('use captureStream to add transceiver ');\r\n            // get two video stream\r\n            let streamArray = this.getCaptureStream(2)\r\n            for(let i = 0; i<streamArray.length; i++){\r\n                let stream = streamArray[i]\r\n                log.info('add stream to peerConnection: ' + stream.id)\r\n                pc.addStream(stream)\r\n                // stream.getTracks().forEach(track => pc.addTrack(track, stream));\r\n            }\r\n        }\r\n\r\n        This.doOffer(pc)\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n/**\r\n * Listen for stream change events\r\n * @param pc\r\n */\r\nPeerConnection.prototype.subscribeStreamEvents = function (pc) {\r\n    let This = this\r\n    if (this.gsRTC.isReplaceTrackSupport()) {\r\n        pc.ontrack = function (evt) {\r\n            log.info('__on_add_track')\r\n            let type = This.gsRTC.enableMultiStream ? This.getTypeByMid(evt.transceiver.mid) : pc.type\r\n            This.setStream(evt.streams[0], type, false)\r\n\r\n            evt.streams[0].onremovetrack = function (evt) {\r\n                log.info('__on_remove_track')\r\n                let type = This.gsRTC.enableMultiStream ? This.getTypeByStreamId(evt.currentTarget.id) : pc.type\r\n                This.setStream(null, type, false)\r\n            }\r\n        }\r\n    } else {\r\n        pc.onaddstream = function (evt) {\r\n            log.info('__on_add_stream')\r\n            let type = pc.type\r\n            This.setStream(evt.stream, type, false)\r\n        }\r\n        pc.onremovestream = function (evt) {\r\n            log.info('__on_remove_stream')\r\n            let type = This.gsRTC.enableMultiStream ? This.getTypeByStreamId(evt.currentTarget.id) : pc.type\r\n            This.setStream(null, type, false)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * create peerConnection\r\n * @param type\r\n * @param conf\r\n * @returns {RTCPeerConnection}\r\n */\r\nPeerConnection.prototype.createPeerConnection = function (type, conf) {\r\n    log.info(\"Create peerConnection : \" + type)\r\n    let This = this\r\n    let pc\r\n    let config = {iceTransportPolicy: 'all'}\r\n    let iceservers = conf.iceServer;\r\n    let RTCpeerConnectionOptional = this.conf.RTCpeerConnectionOptional;\r\n    // chrome 72 版本默认unified-plan， 65版本开始unified-plan为实验性质标志，通过sdpSemantics: unified-plan 启用\r\n    if (RTCpeerConnectionOptional === null || RTCpeerConnectionOptional === undefined) {\r\n        RTCpeerConnectionOptional = { optional: [ { 'pcName': \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': false } ] };\r\n    }\r\n    else if(RTCpeerConnectionOptional && RTCpeerConnectionOptional.optional && RTCpeerConnectionOptional.optional.length > 0){\r\n        RTCpeerConnectionOptional.optional.push( { 'pcName': \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': false });\r\n    }\r\n    // config[\"sdpSemantics\"] = \"unified-plan\";\r\n    if(iceservers === null || iceservers === undefined || iceservers.length === 0){\r\n        log.info('iceServers is null')\r\n    }else {\r\n        log.info('icesServer ' + This.conf.iceServer)\r\n        config.iceServers = conf.iceServer;\r\n    }\r\n    if(This.gsRTC.getBrowserDetail().browser !== 'firefox'){\r\n        // firefox not support no need set sdpSemantics config\r\n        config.sdpSemantics = \"unified-plan\";\r\n    }\r\n    log.warn(\"config: \", config)\r\n    log.warn(\"RTCpeerConnectionOptional: \", RTCpeerConnectionOptional)\r\n\r\n    pc = new window.RTCPeerConnection(config, RTCpeerConnectionOptional)\r\n    pc.type = type;\r\n    pc.pcName = \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2)\r\n    pc.peerId = Math.random().toString(36).substr(2)\r\n    pc.action = null\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = false\r\n    pc.isLocalSdpPending = true;\r\n    this.subscribeStreamEvents(pc)\r\n\r\n    // 服务器回复的200 ok中，audio默认 sendrecv，不添加流的话会报错：\"Answer tried to set recv when offer did not set send\"\r\n    if((type === 'audio' || type === 'multiStreamPeer') && !This.gsRTC.MEDIA_STREAMS.LOCAL_AUDIO_STREAM){\r\n        if(This.gsRTC.getBrowserDetail().browser === 'firefox' && This.gsRTC.getBrowserDetail().version > 60){\r\n            log.warn('firefox get fake stream')\r\n            function getMediaCallBack(data){\r\n                if(data.stream){\r\n                    log.info('get fake stream success')\r\n                    data.stream.getTracks().forEach(function(track) {\r\n                        track.enabled = false; //Mute this track, incase the audio send out.\r\n                    });\r\n                    This.processAddStream(data.stream , pc, 'audio');\r\n                }else {\r\n                    log.info(data)\r\n                    log.error(data.error)\r\n                }\r\n            }\r\n            let conf = { streamType: 'audio', callback: getMediaCallBack }\r\n            let constraints =  { audio: true, video: false, fake: true }\r\n            this.gsRTC.device.getMedia(conf, constraints)\r\n        }\r\n    }\r\n\r\n    pc.onicecandidate = function (event) {\r\n        This.onIceCandidate(pc, event);\r\n    };\r\n\r\n    pc.onsignalingstatechange = function () {\r\n        This.onSignalingStateChange(pc)\r\n    }\r\n\r\n    pc.onicegatheringstatechange = function () {\r\n        This.onIceGatheringStateChange(pc)\r\n    }\r\n\r\n    pc.oniceconnectionstatechange = function () {\r\n        This.onIceConnectionStateChange(pc);\r\n    }\r\n\r\n    pc.onconnectionstatechange = function (event) {\r\n        This.onConnectionStateChange(pc, event)\r\n    }\r\n\r\n    return pc\r\n}\r\n\r\n/**\r\n * create localDescription: create offer and setLocalDescription\r\n * @param pc\r\n * @returns {Promise<void>}\r\n */\r\nPeerConnection.prototype.doOffer = async function (pc) {\r\n    let This = this\r\n    this.gsRTC.isProcessingInvite = true\r\n    log.info(\"create sdp( PC: \" + pc.type + \" )\");\r\n    // Added checks to ensure that connection object is defined first\r\n    if (!pc) {\r\n        log.info('RTCSessionDescription offer, Dropping of creating of offer as connection does not exists');\r\n        return;\r\n    }\r\n\r\n    // Added checks to ensure that state is \"stable\" if setting local \"offer\"\r\n    if (pc.signalingState !== 'stable') {\r\n        log.info(\"Dropping of creating of offer as signalingState is not \" + pc.signalingState);\r\n        return;\r\n    }\r\n    log.info('Creating offer');\r\n\r\n    pc.offerConstraints = {\r\n        offerToReceiveAudio: pc.type === 'multiStreamPeer' ? true : pc.type === 'audio',\r\n        offerToReceiveVideo: pc.type === 'multiStreamPeer' ? true : pc.type !== 'audio'\r\n    }\r\n\r\n    async function onCreateOfferSuccess(desc) {\r\n        log.log(`Offer from ` + pc.type + ` \\n${desc.sdp}`);\r\n        log.info('start setLocalDescription');\r\n        try {\r\n            await pc.setLocalDescription(desc);\r\n            This.setLocalDescriptionSuccess(pc);\r\n        } catch (error) {\r\n            This.onSetLocalDescriptionError(error);\r\n        }\r\n    }\r\n\r\n    try {\r\n        log.log(pc.type + ' createOffer start');\r\n        const offer = await pc.createOffer(pc.offerConstraints);\r\n        await onCreateOfferSuccess(offer);\r\n    } catch (error) {\r\n        This.onCreateLocalDescriptionError(error);\r\n    }\r\n}\r\n\r\n/***\r\n * create localDescription: create answer and setLocalDescription\r\n * @param pc\r\n * @returns {Promise<void>}\r\n */\r\nPeerConnection.prototype.doAnswer = async function (pc) {\r\n    let This = this\r\n    pc.isLocalSdpPending = true\r\n    this.gsRTC.isProcessingInvite = true\r\n    log.info(\"prepare do answer\")\r\n    // Added checks to ensure that connection object is defined first\r\n    if (!pc) {\r\n        log.info('RTCSessionDescription offer Dropping of creating of answer as connection does not exists');\r\n        return;\r\n    }\r\n\r\n    // Added checks to ensure that state is \"stable\" if createAnswer\r\n    if (pc.signalingState !== 'have-remote-offer') {\r\n        log.info(\"Dropping of creating of offer as signalingState is not \" + pc.signalingState);\r\n        return;\r\n    }\r\n\r\n    async function onCreateAnswerSuccess(desc) {\r\n        log.info(pc.type + `createAnswerSuccess`);\r\n        log.info(pc.type + ' setLocalDescription start');\r\n        try {\r\n            await pc.setLocalDescription(desc);\r\n            This.setLocalDescriptionSuccess(pc);\r\n        } catch (e) {\r\n            This.onSetLocalDescriptionError(error);\r\n        }\r\n    }\r\n\r\n    log.info('createAnswer start');\r\n    try {\r\n        const answer = await pc.createAnswer();\r\n        await onCreateAnswerSuccess(answer);\r\n    } catch (e) {\r\n        This.onCreateLocalDescriptionError(e);\r\n    }\r\n}\r\n\r\n/**\r\n * fired when peerConnection set localDescription success\r\n * @returns {boolean}\r\n */\r\nPeerConnection.prototype.setLocalDescriptionSuccess = function (pc) {\r\n    log.info('setLocalDescription success ( ' + pc.type + ')')\r\n    // If you don't recollect the dates, you need to judge here whether you can send invite or 200 ok\r\n    if (pc.iceGatheringState === 'complete') {\r\n        pc.isLocalSdpPending = false\r\n        log.info(\"onSetLocalDescriptionSuccess send invite( PC: \" + pc.type + \" )\");\r\n        this.onIceGatheringCompleted();\r\n    }\r\n}\r\n\r\n/**\r\n * fired when peerConnection set localDescription failed\r\n * @param error\r\n */\r\nPeerConnection.prototype.onSetLocalDescriptionError = function (error) {\r\n    log.error(`Failed to set local description: ${error}`);\r\n}\r\n\r\n/**\r\n * fired when peerConnection createOffer or createAnswer failed\r\n * @param error\r\n */\r\nPeerConnection.prototype.onCreateLocalDescriptionError = function (error) {\r\n    log.error(`Failed to create session description: ${error}`);\r\n}\r\n\r\n/**\r\n * setRemoteDescription when answer sdp from the server\r\n * @param sdp\r\n */\r\nPeerConnection.prototype.setRemote = function (sdp) {\r\n    let This = this\r\n\r\n    async function setRo(pc, sdp) {\r\n        try {\r\n            log.info('setRemoteDescription (' + pc.type + ')')\r\n            let roSdp = This.gsRTC.getSdpByType(pc.type, sdp)\r\n            log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)\r\n            let desc = new window.RTCSessionDescription({type: 'answer', sdp: roSdp})\r\n            await pc.setRemoteDescription(desc)\r\n            This.setRemoteDescriptionSuccess(pc)\r\n        } catch (e) {\r\n            This.onSetRemoteDescriptionError(e);\r\n        }\r\n    }\r\n\r\n    for (let key in this.peerConnections) {\r\n        let pc = this.peerConnections[key]\r\n        if (pc.signalingState !== 'have-local-offer') {\r\n            log.info(pc.type + \" dropping of setRemoteDescription as signalingState is \" + pc.signalingState);\r\n            continue;\r\n        }\r\n        setRo(pc, sdp)\r\n    }\r\n}\r\n\r\n/**\r\n * set remote desc success\r\n * @param pc\r\n */\r\nPeerConnection.prototype.setRemoteDescriptionSuccess = function (pc) {\r\n    log.info('setRemoteDescription success ( ' + pc.type + ')')\r\n    this.gsRTC.inviteProcessing = false\r\n    let stream = this.getStream(pc.type, true)\r\n    if (pc.type === 'main' && stream && stream.active === true && !window.wfu) {\r\n        log.info(pc.type + \" prepare get new stream\")\r\n        this.getNewStream(pc)\r\n    }\r\n\r\n    // ice restart的时候，处理完前面的invite之后再处理后面的invite\r\n    for(let i = 0; i<this.gsRTC.sendInviteQueue.length; i++){\r\n        let item = this.gsRTC.sendInviteQueue[i]\r\n        if(item.type === pc.type && item.action ===  pc.action){\r\n            this.gsRTC.sendInviteQueue.splice(i, 1)\r\n            pc.action = null\r\n            if(this.gsRTC.sendInviteQueue && this.gsRTC.sendInviteQueue.length > 0){\r\n                this.gsRTC.action = this.gsRTC.sendInviteQueue[0].action\r\n                let type =  this.gsRTC.sendInviteQueue[0].type\r\n                let pc = this.gsRTC.RTCSession.peerConnections[type]\r\n                this.doOffer(pc)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * set remote desc error\r\n * @param error\r\n */\r\nPeerConnection.prototype.onSetRemoteDescriptionError = function (error) {\r\n    log.error(`Failed to set remote description: ${error}`);\r\n    console.error(error)\r\n}\r\n\r\n/**\r\n * handle server re-invite\r\n * @param sdp\r\n */\r\nPeerConnection.prototype.handleOffer = function (sdp) {\r\n    let This = this\r\n\r\n    async function setRo(pc) {\r\n        try {\r\n            log.info('setRemoteDescription (' + pc.type + ')')\r\n            let roSdp = This.gsRTC.getSdpByType(pc.type, sdp)\r\n            log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)\r\n            let desc = new window.RTCSessionDescription({type: 'offer', sdp: roSdp})\r\n            await pc.setRemoteDescription(desc)\r\n            This.setRemoteDescriptionSuccess(pc)\r\n            This.doAnswer(pc)\r\n        } catch (e) {\r\n            This.onSetRemoteDescriptionError(e);\r\n        }\r\n    }\r\n\r\n    for (let key in this.peerConnections) {\r\n        let pc = this.peerConnections[key]\r\n        if (pc.signalingState !== 'stable') {\r\n            log.info(pc.type + \" dropping of creating of offer as signalingState is not stable\");\r\n            continue;\r\n        }\r\n\r\n        let newRo = This.gsRTC.getSdpByType(pc.type, sdp)\r\n        let currentRo = pc.currentRemoteDescription ? pc.currentRemoteDescription : pc.remoteDescription\r\n        // Compare the sdp of each peerConnection after receiving sdp each time\r\n        if (!This.gsRTC.isObjectXExactlyEqualToY(newRo, currentRo)) {\r\n            setRo(pc)\r\n        } else {\r\n            log.info('current remote description is not change')\r\n        }\r\n    }\r\n}\r\n\r\n/***\r\n * JSEP rollback operation for 491 invite conflict\r\n * plan one: setRemoteDescription direct\r\n */\r\nPeerConnection.prototype.rollbackOperation = async function () {\r\n    log.info('jsep rollback operation')\r\n    var This = this\r\n\r\n    // setRemoteDescription direct\r\n    async function setRemote(pc) {\r\n        log.warn(pc.type + \" peerConnection signalingState: \" + pc.signalingState)\r\n        try {\r\n            let sdp = pc.currentRemoteDescription ? pc.currentRemoteDescription : pc.remoteDescription\r\n            let description = new window.RTCSessionDescription(sdp)\r\n            await pc.setRemoteDescription(description)\r\n            This.setRemoteDescriptionSuccess(pc)\r\n        } catch (e) {\r\n            This.onSetRemoteDescriptionError(error);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < This.peerConnections.length; i++) {\r\n        let pc = This.peerConnections[i]\r\n        if (pc.signalingState === 'have-local-offer') {\r\n            setRemote(pc)\r\n        }\r\n    }\r\n\r\n    log.info('set isProcessingInvite to false')\r\n    This.gsRTC.isProcessingInvite = false\r\n}\r\n\n/**\r\n * get all peerConnection combine sdp\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getDecorateSdp = function () {\r\n    log.info('get local peers combine sdp')\r\n    let This = this\r\n    let sdp\r\n    let sdpArray = [];\r\n    let parseSdp = null\r\n\r\n    if(This.gsRTC.enableMultiStream === true){\r\n        log.warn(\"decorate multi stream Peer sdp \")\r\n        let pc = This.peerConnections['multiStreamPeer']\r\n        let subSDP = pc.localDescription.sdp;\r\n        sdp = This.gsRTC.decorateMultiStreamSdp(subSDP)\r\n    }else {\r\n        for (let i in This.peerConnections) {\r\n            let pc = This.peerConnections[i]\r\n            let subSDP = pc.localDescription.sdp;\r\n\r\n            // save original mid before send invite,\r\n            This.gsRTC.saveMidBeforeSendInvite(subSDP, pc.type)\r\n\r\n            if(pc) {\r\n                if(pc.type === 'audio'){\r\n                    log.warn('set audio recvonly to sendrecv for test!')\r\n                    subSDP = subSDP.replace(/a=recvonly/g, \"a=sendrecv\")\r\n                }\r\n\r\n                // video1 for wfu\r\n                if(pc.type === 'main' || pc.type === 'video1'){\r\n                    parseSdp = SDPTools.parseSDP(subSDP)\r\n                    SDPTools.removeCodecByPayload(parseSdp, 0, [98, 99,127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])\r\n                    // set resolution of sdp\r\n                    let resolution = this.gsRTC.getVideoResolution('EXPECT_RECV_RESOLUTION')\r\n                    if(resolution.width && resolution.height){\r\n                        // set expected receive resolution\r\n                        parseSdp = This.gsRTC.setResolutionOfSdp(parseSdp, resolution.width, resolution.height)\r\n                    }\r\n                    subSDP = SDPTools.writeSDP(parseSdp)\r\n                    // Add media line identification field\r\n                    subSDP = subSDP + \"a=content:main\\n\"\r\n                }\r\n                if(pc.type === 'slides'){\r\n\r\n                    parseSdp = SDPTools.parseSDP(subSDP)\r\n                    SDPTools.removeCodecByPayload(parseSdp, 0, [98, 99, 127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])\r\n                    subSDP = SDPTools.writeSDP(parseSdp)\r\n                    // Add media line identification field\r\n                    subSDP = subSDP + \"a=content:slides\\n\"\r\n\r\n                    if(!window.wfu){\r\n                        // set direction recvonly if not share screen\r\n                        let stream = This.getStream('slides', true)\r\n                        if(stream){\r\n                            subSDP = subSDP.replace(/a=sendrecv/g, \"a=sendonly\");\r\n                            subSDP = subSDP.replace(/a=recvonly/g, \"a=sendonly\");\r\n                        }else {\r\n                            subSDP = subSDP.replace(/a=sendrecv/g, \"a=recvonly\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            sdpArray.push(subSDP);\r\n        }\r\n        sdp = SDPTools.mergeSDP(sdpArray);\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * decorate remote sdp\r\n * @param sdp\r\n */\r\nPeerConnection.prototype.commonDecorateRo  = function(sdp){\r\n    if(!sdp){\r\n        log.error(\"commonDecorateRo: Invalid Argument\");\r\n        return;\r\n    }\r\n    log.info('commonDecorateRo')\r\n    this.setRemote(sdp)\r\n}\r\n\r\n/**\r\n * After receiving 200 ok, adjust the upstream according to the resolution required by the server\r\n * @param pc\r\n * @returns {boolean}\r\n */\r\nPeerConnection.prototype.getNewStream = function (pc) {\r\n    let This = this\r\n    let stream = this.getStream('main', true)\r\n    let isSend = pc.localDescription.sdp.indexOf('sendrecv') >= 0 || pc.localDescription.sdp.indexOf('sendonly') >= 0\r\n    if(stream && stream.active && isSend === true){\r\n        let upResolution = This.gsRTC.getVideoResolution('CURRENT_UP_RESOLUTION')\r\n        let parseSdp = SDPTools.parseSDP(pc.remoteDescription.sdp)\r\n        let askedResolution = This.gsRTC.getResolutionBySdp(parseSdp)\r\n\r\n        log.info(\"resolution(from current sdp): \" + askedResolution.height)\r\n        if(upResolution){\r\n            log.info(\"resolution(from previous sdp): \" + upResolution.height);\r\n        }else {\r\n            log.info(\"resolution(from previous sdp): null\");\r\n        }\r\n\r\n        let constraints = null\r\n        if(askedResolution && askedResolution.width && askedResolution.height){\r\n            if(!upResolution || upResolution.height !== askedResolution.height){\r\n                let frameRate =  This.gsRTC.getFramerateBySdp(parseSdp)\r\n                let browserDetails = This.gsRTC.getBrowserDetail()\r\n                log.info('adjust resolution!')\r\n                // applyConstraints support chrome64+, firefox all version\r\n                if (stream && stream.active === true && ((\r\n                  browserDetails.browser === 'chrome' && browserDetails.version >= 64)\r\n                  || (browserDetails.browser === 'opera' && browserDetails.chromeVersion >= 64)\r\n                  || browserDetails.browser === 'firefox'))\r\n                {\r\n                    constraints = {\r\n                        frameRate: {\r\n                            max: frameRate ? frameRate: 30,\r\n                            ideal: frameRate ? frameRate: 30\r\n                        },\r\n                        width: {\r\n                            max: askedResolution.width,\r\n                            ideal: askedResolution.width\r\n                        },\r\n                        height: {\r\n                            max: askedResolution.height,\r\n                            ideal: askedResolution.height\r\n                        }\r\n                    }\r\n\r\n                    log.info('applyConstraints constraints' + JSON.stringify(constraints, null, '    '))\r\n                    let localVideoTrack = stream.getVideoTracks()[0];\r\n                    localVideoTrack.applyConstraints(constraints).then(function () {\r\n                        log.info('applyConstraints succeed');\r\n                        This.setStream(stream, 'main', true)\r\n                    }).catch(function (error) {\r\n                        log.error(\"applyConstraints Error: \" , error);\r\n                    })\r\n                }else {\r\n                    // getUserMedia 重新取流后需要re-invite，否则视频会loading，因为ssrc已经改变了\r\n                    log.info('getUserMedia')\r\n                    let type = 'main'\r\n                    function getStreamCallback(event){\r\n                        let newStream = event.stream\r\n                        if(newStream){\r\n                            log.info('getUserMedia succeed ', newStream);\r\n                            This.processRemoveStream(stream, pc, type)\r\n                            This.processAddStream(newStream, pc, type)\r\n                            This.setStream(newStream, type, true)\r\n                            This.doOffer(pc)\r\n                        }else if(event.error){\r\n                            log.error(event.error)\r\n                        }\r\n                    }\r\n\r\n                    // TODO：这里需要添加deviceId， 因为多个摄像头的时候，取流时可能会换摄像头\r\n                    let gumData = {\r\n                        streamType: 'video',\r\n                        callback: getStreamCallback\r\n                    }\r\n                    let param = {\r\n                        streamType: 'video',\r\n                        constraintsKeyWord: 'exact',\r\n                        deviceId: This.deviceId,\r\n                        frameRate: frameRate,\r\n                        width: askedResolution.width,\r\n                        height: askedResolution.height,\r\n                    }\r\n\r\n                    if(this.gsRTC.device){\r\n                        constraints = this.gsRTC.device.getConstraints(param)\r\n                        this.gsRTC.device.getMedia(gumData, constraints)\r\n                    }\r\n                }\r\n\r\n                This.gsRTC.setVideoResolution(askedResolution,'CURRENT_UP_RESOLUTION')\r\n            }else {\r\n                log.info(\"handleOffer: resolution is just right\");\r\n            }\r\n        }else {\r\n            log.warn('server asked resolution is null')\r\n            return false\r\n        }\r\n\r\n        return true\r\n    }else {\r\n        log.warn('camera is not open, clear local stream')\r\n        This.setStream(null, 'main', true)\r\n        return false\r\n    }\r\n}\r\n\r\n\nGsRTC.prototype.HTML_MEDIA_ELEMENT = {\r\n    localAudio: null,\r\n    localVideo: null,\r\n    localPresentVideo: null,\r\n    localVideoShare: null,\r\n    remoteAudio: null,\r\n    remoteVideo: null,\r\n    remotePresentVideo: null,\r\n    remoteVideoShare: null,\r\n}\r\n\r\n/**\r\n * save local && remote stream\r\n * @type {{LOCAL_PRESENT_STREAM: null, LOCAL_VIDEO_SHARE_STREAM: null, REMOTE_VIDEO_SHARE_STREAM: null, LOCAL_AUDIO_STREAM: null, REMOTE_PRESENT_STREAM: null, REMOTE_AUDIO_STREAM: null, LOCAL_VIDEO_STREAM: null, REMOTE_VIDEO_STREAM: null}}\r\n */\r\nGsRTC.prototype.MEDIA_STREAMS = {\r\n    LOCAL_AUDIO_STREAM: null,\r\n    REMOTE_AUDIO_STREAM: null,\r\n    LOCAL_VIDEO_STREAM: null,\r\n    REMOTE_VIDEO_STREAM: null,\r\n    LOCAL_PRESENT_STREAM: null,\r\n    REMOTE_PRESENT_STREAM: null,\r\n    LOCAL_VIDEO_SHARE_STREAM : null,\r\n    REMOTE_VIDEO_SHARE_STREAM : null\r\n};\r\n\r\n/**\r\n * Save upstream or downstream resolution\r\n * @type {{EXPECT_RECV_RESOLUTION: {}, CURRENT_UP_RESOLUTION: {}}}\r\n */\r\nGsRTC.prototype.VIDEO_RESOLUTION = {\r\n    CURRENT_UP_RESOLUTION: {},\r\n    EXPECT_RECV_RESOLUTION: {},\r\n}\r\n\r\nGsRTC.prototype.MID_OBJ = {\r\n    AUDIO_MID: {\r\n        ORIGINAL_MID: null,\r\n        MODIFIED_MID: null\r\n    },\r\n    MAIN_MID: {\r\n        ORIGINAL_MID: null,\r\n        MODIFIED_MID: null\r\n    },\r\n    SLIDES_MID: {\r\n        ORIGINAL_MID: null,\r\n        MODIFIED_MID: null\r\n    },\r\n}\r\n\r\n\n/**\r\n * Event registration\r\n */\r\nGsRTC.prototype.eventBindings = function(){\r\n    log.info('event binding.')\r\n    this.on('onEventStack', this.eventStack)\r\n}\r\n\r\n/**\r\n * event stack 所有回调调用触发的地方\r\n * @param event\r\n */\r\nGsRTC.prototype.eventStack = function(event){\r\n    switch (event.type) {\r\n        case 'GET_LO_SUCCESS':\r\n            if(this.inviteProcessing === false){\r\n                let sdp = this.RTCSession.getDecorateSdp()\r\n                // Save the session version, plus one for each re-invite\r\n                this.saveSDPSessionVersion(sdp)\r\n                if(window.wfu){\r\n                    console.warn(\"sendMessage sdp\\n\" ,sdp)\r\n                    this.sokect.sendMessage(sdp)\r\n                }else {\r\n                    this.sipStack.sendSipMessage(sdp)\r\n                }\r\n            }else {\r\n                log.info('exist invite in processing..')\r\n            }\r\n\r\n            break\r\n        case '491_INVITE_CONFLICT':\r\n            this.RTCSession.rollbackOperation()\r\n            break\r\n        default:\r\n            log.info('eventStack null: ', event.type)\r\n            break\r\n    }\r\n}\r\n\r\nGsRTC.prototype.handleIncomingMessage = function (event) {\r\n    /* Server reply message */\r\n    if(event.data.isrsp){\r\n        log.info(\"receive server response: \" + event.data.method + ' , code ' + event.data.code)\r\n        let code = event.data.code\r\n        switch (event.data.method) {\r\n            case 'REGISTER':\r\n                if(this.EVENTS[this.action]){\r\n                    this.trigger(this.action, {codeType: code});\r\n                }\r\n                break\r\n            case 'INVITE':\r\n                if(code === 200){\r\n                    this.sipStack.jsSipSendAck()\r\n                    this.isSendReInvite = true\r\n                    let sdp = event.data.body\r\n                    this.RTCSession.commonDecorateRo(sdp)\r\n\r\n                    if(this.EVENTS[this.action]){\r\n                        this.sendInviteQueue.shift()\r\n                        this.trigger(this.action, {codeType: code});\r\n                    }\r\n                }else if(code === 491){\r\n                    this.eventStack({type: '491_INVITE_CONFLICT'})\r\n                }\r\n                break\r\n            case 'INFO':\r\n                if(this.EVENTS[this.action]){\r\n                    this.trigger(this.action,{codeType: code})\r\n                }\r\n                break\r\n            case 'BYE':\r\n                log.info('Receive server bye, location reload.')\r\n                // window.location.reload(true)\r\n                break\r\n            default:\r\n                log.warn('Other method: '+ event.data)\r\n                break\r\n        }\r\n    }else {\r\n        /* Server request message */\r\n        log.info(\"handle server request: \" + event.data.method)\r\n        switch (event.data.method) {\r\n            case 'INVITE':\r\n                this.transaction = event.data.transaction\r\n                this.isRecvRequest = true\r\n                this.RTCSession.handleOffer(event.data.body)\r\n                break\r\n            case 'ACK':\r\n                log.info('handle offer success')\r\n                if(this.EVENTS[this.action]){\r\n                    this.trigger(this.action, {codeType: this.CODE_TYPE.ACTION_SUCCESS});\r\n                }\r\n                break\r\n            case 'BYE':\r\n                log.info('Receive Server BYE!')\r\n                break\r\n            default:\r\n                log.warn('request message.data.method: '+ event.data.method)\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Message sending mechanism:\r\n * 1、Call sip interface\r\n * 2、sip interface returns data\r\n * 3、webSocket send data\r\n * @param event\r\n */\r\nGsRTC.prototype.onmessage = function (event) {\r\n    log.info('GsRTC: handle incoming message.')\r\n    let content = event.data\r\n\r\n    if( event.data === \"\\r\\n\"){\r\n        /* websocket保活包 */\r\n    }else {\r\n        switch (content.cmd) {\r\n            case 'functionReturn':\r\n                break\r\n            case 'sendMessage':\r\n                this.sokect.sendMessage(event.data.msg)\r\n                break\r\n            case 'recvSipMessage':\r\n                this.handleIncomingMessage(event)\r\n                break\r\n            default:\r\n                log.info('handle non sip message: ', event.data)\r\n                break\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n/***\r\n * Function that clear stream, free resources\r\n * @param stream\r\n */\r\nPeerConnection.prototype.closeStream = function(stream){\r\n    if(!stream){\r\n        log.info('closeStream:stream is null');\r\n        return;\r\n    } else{\r\n        log.info(\"close stream id: \" + stream.id);\r\n    }\r\n\r\n    try {\r\n        stream.oninactive = null;\r\n        let tracks = stream.getTracks();\r\n        for (let track in tracks) {\r\n            tracks[track].onended = null;\r\n            log.info(\"close stream\");\r\n            tracks[track].stop();\r\n        }\r\n    }\r\n    catch (error) {\r\n        log.info('closeStream: Failed to close stream');\r\n        log.info(error);\r\n    }\r\n    stream = null;\r\n}\r\n\r\n/**\r\n * Bind page media elements after streaming successfully\r\n * @param type\r\n * @param stream\r\n * @param isLocal\r\n */\r\nPeerConnection.prototype.setMediaElementStream = function (stream, type, isLocal) {\r\n    log.info('get local/remote stream , ' + type)\r\n    let prefix = isLocal === true ? 'local' : 'remote'\r\n    let identify = null\r\n    let isVideo = !(type === 'audio')\r\n    switch (type) {\r\n        case 'audio':\r\n            identify = prefix + 'Audio'\r\n            break;\r\n        case 'main':\r\n            identify = prefix + 'Video'\r\n            break;\r\n        case 'slides':\r\n            identify = prefix + 'PresentVideo'\r\n            break;\r\n        case 'localVideoShare':\r\n            identify = prefix + 'VideoShare'\r\n            break\r\n        case 'multiStreamPeer':\r\n            // 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video\r\n            if(stream.getAudioTracks().length > 0){\r\n                identify = prefix + 'Audio'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'Video'].srcObject){\r\n                    identify = prefix + 'Video'\r\n                }else if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'PresentVideo'].srcObject){\r\n                    identify = prefix + 'PresentVideo'\r\n                }else if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'VideoShare'].srcObject){\r\n                    identify = prefix + 'VideoShare'\r\n                }\r\n            }\r\n            break\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Fires when video metadata loading is complete (displays the current video resolution)\r\n    function displayVideoDimensions(e) {\r\n        let className = e.target.id + '_dimensions'\r\n        let dimensions = document.getElementsByClassName(className);\r\n        if(dimensions && dimensions[0]){\r\n            dimensions[0].innerHTML = e.target.videoWidth + ' x ' + e.target.videoHeight\r\n        }\r\n    }\r\n\r\n    let target = this.gsRTC.HTML_MEDIA_ELEMENT[identify]\r\n    if (target) {\r\n        target.srcObject = stream;\r\n        log.info('Get ' + identify +' stream');\r\n        // 会覆盖演示流的oninactive监听事件\r\n        // if(stream){\r\n        //     stream.oninactive = function () {\r\n        //         log.info('stream oninactive, clear element source')\r\n        //         target.srcObject = null\r\n        //     }\r\n        // }\r\n        \r\n        if(isVideo){\r\n            log.info('set video _dimensions')\r\n            target.onloadedmetadata = displayVideoDimensions\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get type by stream id\r\n * 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video\r\n * @param streamId\r\n * @returns {string}\r\n */\r\nPeerConnection.prototype.getTypeByStreamId = function(streamId){\r\n    let type\r\n    for(let key in this.gsRTC.MEDIA_STREAMS){\r\n        if(gsRTC.MEDIA_STREAMS[key] && gsRTC.MEDIA_STREAMS[key].id === streamId){\r\n            type = key\r\n        }\r\n    }\r\n    if(type){\r\n        type = type.split('_')[1].toLowerCase()\r\n    }\r\n    return type\r\n}\r\n\r\n/**\r\n * get current stream type by transceiver mid\r\n * @param mid\r\n */\r\nPeerConnection.prototype.getTypeByMid = function(mid){\r\n    let type\r\n    switch (mid) {\r\n        case '0':\r\n            type = 'audio'\r\n            break\r\n        case '1':\r\n            type = 'main'\r\n            break\r\n        case '2':\r\n            type = 'slides'\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    log.info('get type by transceiver mid ' + type)\r\n\r\n    return type\r\n}\r\n\r\n/**\r\n * get stream from canvas\r\n * @param number\r\n * @returns {Array}\r\n */\r\nPeerConnection.prototype.getCaptureStream = function(number){\r\n    let captureStreamArray = []\r\n    // add canvass\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.id = 'canvasForCaptureStream'\r\n    canvas.style.cssText = \"display: none\"\r\n\r\n    for(let i = 0; i<number; i++){\r\n        let stream = canvas.captureStream();\r\n        log.info(\"get captureStream: \", stream)\r\n        captureStreamArray.push(stream)\r\n    }\r\n    return captureStreamArray\r\n}\r\n\r\n/**\r\n * get stream type\r\n * @param type audio/main/slides/localVideo\r\n * @param isLocal\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getStreamType = function(type, isLocal){\r\n    let streamType = null\r\n    if(isLocal){\r\n        switch (type) {\r\n            case 'audio':\r\n                streamType = 'LOCAL_AUDIO_STREAM'\r\n                break\r\n            case 'main':\r\n                streamType = 'LOCAL_VIDEO_STREAM'\r\n                break\r\n            case 'slides':\r\n                streamType = 'LOCAL_PRESENT_STREAM'\r\n                break\r\n            case 'localVideoShare':\r\n                streamType = 'LOCAL_VIDEO_SHARE_STREAM'\r\n                break\r\n            default:\r\n                log.info('no match type: '+ type)\r\n                break\r\n        }\r\n    }else {\r\n        switch (type) {\r\n            case 'audio':\r\n                streamType = 'REMOTE_AUDIO_STREAM'\r\n                break\r\n            case 'main':\r\n                streamType = 'REMOTE_VIDEO_STREAM'\r\n                break\r\n            case 'slides':\r\n                streamType = 'REMOTE_PRESENT_STREAM'\r\n                break\r\n            case 'localVideoShare':\r\n                streamType = 'REMOTE_VIDEO_SHARE_STREAM'\r\n                break\r\n            default:\r\n                log.info('no match type: '+ type)\r\n                break\r\n        }\r\n    }\r\n    return streamType\r\n}\r\n\r\n/**\r\n * set stream\r\n * @param stream\r\n * @param type: audio, main, slides, localVideoShare\r\n * @param isLocal :true for the local stream and false for the accepted remote stream\r\n */\r\nPeerConnection.prototype.setStream = function(stream, type, isLocal){\r\n    if (!type){\r\n        log.warn(\"setStream: Invalid parameter!\");\r\n        return\r\n    }\r\n\r\n    let streamId = stream ? stream.id : null\r\n    let streamType = this.getStreamType(type, isLocal)\r\n    // multiStream: Browsers that do not support replaceTrack can only be judged by the type of stream\r\n    if(!streamType && stream){\r\n        if(isLocal){\r\n            if(stream.getAudioTracks().length > 0){\r\n                streamType = 'LOCAL_AUDIO_STREAM'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!this.gsRTC.MEDIA_STREAMS['LOCAL_VIDEO_STREAM']){\r\n                    streamType = 'LOCAL_VIDEO_STREAM'\r\n                }else {\r\n                    streamType = 'LOCAL_PRESENT_STREAM'\r\n                }\r\n            }\r\n        }else {\r\n            if(stream.getAudioTracks().length > 0){\r\n                streamType = 'REMOTE_AUDIO_STREAM'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!this.gsRTC.MEDIA_STREAMS['REMOTE_VIDEO_STREAM']){\r\n                    streamType = 'REMOTE_VIDEO_STREAM'\r\n                }else {\r\n                    streamType = 'REMOTE_PRESENT_STREAM'\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    log.info('set ' + streamType + ' stream id: ' + streamId)\r\n    this.gsRTC.MEDIA_STREAMS[streamType] = stream\r\n\r\n    this.setMediaElementStream(stream, type, isLocal)\r\n}\r\n\r\n/***\r\n * get stream\r\n * @param isLocal: true for the local stream and false for the accepted remote stream\r\n * @param type audio, main, slides, localVideoShare\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getStream = function(type, isLocal){\r\n    if (!type){\r\n        log.warn(\"getStream: Invalid parameter!\");\r\n        return\r\n    }\r\n\r\n    let streamType = this.getStreamType(type, isLocal)\r\n    let stream = this.gsRTC.MEDIA_STREAMS[streamType]\r\n\r\n    if(stream){\r\n        log.info('get ' + streamType + ' stream id :' + stream.id)\r\n    }else {\r\n        log.info('stream null')\r\n    }\r\n    return stream\r\n}\r\n\r\n/***\r\n * Function that stream mute and unmute switch\r\n * @param data 示例{\r\n *\t\tstream: stream\r\n *\t  type: 'audio'\r\n *\t  mute: true\r\n * }\r\n */\r\nPeerConnection.prototype.streamMuteSwitch = function(data){\r\n\r\n    if(data.stream != null && data.stream !== undefined){\r\n        log.info(\"MuteStream: stream id = \" + data.stream.id);\r\n    }else {\r\n        log.warn(\"stream is not exist!\")\r\n        return\r\n    }\r\n\r\n    if ( data && data.stream && data.type === 'audio' && data.stream.getAudioTracks().length > 0 ){\r\n        for ( let i = 0; i < data.stream.getAudioTracks().length; i++ ) {\r\n            if (data.mute){\r\n                if ( data.stream.getAudioTracks()[i].enabled === true ) {\r\n                    log.info(\"MuteStream exec mute audio\");\r\n                    data.stream.getAudioTracks()[i].enabled = false;\r\n                }\r\n            }\r\n            else{\r\n                if ( data.stream.getAudioTracks()[i].enabled === false ) {\r\n                    log.info(\"MuteStream exec unmute audio\");\r\n                    data.stream.getAudioTracks()[i].enabled = true;\r\n                }\r\n            }\r\n        }\r\n    } else if( (data.type === 'video' || data.type === 'slides') && data.stream.getVideoTracks().length > 0 ){\r\n        for ( let j = 0; j < data.stream.getVideoTracks().length; j++ ) {\r\n            if (data.mute){\r\n                if ( data.stream.getVideoTracks()[j].enabled === true ) {\r\n                    log.info(\"MuteStream exec mute video/slides\");\r\n                    data.stream.getVideoTracks()[j].enabled = false;\r\n                }\r\n            }\r\n            else{\r\n                if ( data.stream.getVideoTracks()[j].enabled === false ) {\r\n                    log.info(\"MuteStream exec unmute video/slides\");\r\n                    data.stream.getVideoTracks()[j].enabled = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * get transceiver mid main for multiStream\r\n * @param pc\r\n * @param type\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getTransceiverMid = function(pc, type){\r\n    log.info('get transceiver')\r\n    let mid = 0\r\n\r\n    if(pc.getTransceivers){\r\n        if(type && pc.getTransceivers().length > 0){\r\n            let transceiver = pc.getTransceivers()\r\n            for(let i = 0; i<transceiver.length; i++){\r\n                if((type === 'audio' && transceiver[i].mid === '0') || (type === 'main' && transceiver[i].mid === '1') || (type === 'slides' && transceiver[i].mid === '2')) {\r\n                    mid = i\r\n                    log.info('get transceiver mid' + mid)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return mid\r\n}\r\n\r\n/***\r\n * Function that add stream\r\n * @param stream\r\n * @param pc\r\n * @param type\r\n */\r\nPeerConnection.prototype.processAddStream = function (stream, pc, type) {\r\n    log.info('process add stream')\r\n    let This = this\r\n\r\n    let mid = this.gsRTC.enableMultiStream ? this.getTransceiverMid(pc, type) : 0\r\n    if(This.gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n        if (!RTCRtpTransceiver.prototype.setDirection){\r\n            /** Direction setting occasionally does not trigger onnegotiationneeded */\r\n            pc.getTransceivers()[mid].direction = 'sendonly';\r\n            pc.getTransceivers()[mid].direction = 'inactive';\r\n\r\n            pc.getSenders()[mid].replaceTrack(stream.getTracks()[0])\r\n              .then(function () {\r\n                  log.info('use replaceTrack to add stream ');\r\n              })\r\n              .catch(function (error) {\r\n                  console.error(error)\r\n                  log.error(error.toString());\r\n              });\r\n            pc.getTransceivers()[mid].direction = 'sendrecv';\r\n        }else{\r\n            log.info('use replaceTrack to add stream ');\r\n            pc.getTransceivers()[mid].setDirection('sendrecv');\r\n        }\r\n    }else {\r\n        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */\r\n        let browserDetail = this.gsRTC.getBrowserDetail()\r\n        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === \"11.0.2\" || browserDetail.UIVersion === \"11.1.2\") && pc.getSenders().length > 0){\r\n            pc.getSenders()[mid].replaceTrack(stream.getTracks()[0])\r\n                .then(function () {\r\n                    log.info('use replaceTrack to add stream ');\r\n                })\r\n                .catch(function (error) {\r\n                    log.error(error.toString());\r\n                });\r\n        }else if(stream){\r\n            log.info('use addStream to add stream.');\r\n            pc.addStream(stream);\r\n        }\r\n    }\r\n}\r\n\r\n/***\r\n * Function that remove stream\r\n * @param stream\r\n * @param pc\r\n * @param type\r\n */\r\nPeerConnection.prototype.processRemoveStream = function (stream, pc, type) {\r\n    let This = this\r\n    log.info('process remove stream')\r\n\r\n    let mid = this.gsRTC.enableMultiStream ? this.getTransceiverMid(pc, type) : 0\r\n    if(This.gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n        if (!RTCRtpTransceiver.prototype.setDirection){\r\n            /** Direction setting occasionally does not trigger onnegotiationneeded */\r\n            pc.getTransceivers()[mid].direction = 'sendonly';\r\n            pc.getTransceivers()[mid].direction = 'inactive';\r\n\r\n            pc.getTransceivers()[mid].direction = 'recvonly';\r\n            pc.getSenders()[mid].replaceTrack(null)\r\n                .then(function () {\r\n                    log.info('use replaceTrack to add stream ');\r\n                })\r\n                .catch(function (error) {\r\n                    log.error(error.toString());\r\n                })\r\n        }else{\r\n            log.info('use replaceTrack to remove stream.');\r\n            pc.getTransceivers()[mid].setDirection('recvonly');\r\n        }\r\n    }else {\r\n        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */\r\n        let browserDetail = this.gsRTC.getBrowserDetail()\r\n        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === \"11.0.2\" || browserDetail.UIVersion === \"11.1.2\") && pc.getSenders().length > 0){\r\n            pc.getSenders()[mid].track.enablsed = false;\r\n        }else if(stream){\r\n            pc.removeStream(stream);\r\n        }\r\n        log.info('use removeStream to remove stream ');\r\n    }\r\n}\r\n\r\n\r\n\n\r\nPeerConnection.prototype.onConnectionStateChange = function(pc){\r\n    log.info('onConnectionStateChange type: ' + pc.type + ', connectionState: ' + pc.connectionState)\r\n\r\n    let browserDetails = this.gsRTC.getBrowserDetail()\r\n    if(pc.connectionState === 'failed' && ((browserDetails.browser === 'chrome' && browserDetails.version >= 76) || (browserDetails.browser === 'opera' &&browserDetails.chromeVersion >= 76))){\r\n        this.iceConnectFailed(pc);\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceConnectionStateChange = function(pc){\r\n    if (!pc) {\r\n        log.warn('Ignoring of ICE candidate event as Peer connection does not exists ->');\r\n        return\r\n    }\r\n\r\n    let iceState =  pc.iceConnectionState\r\n    log.info(\"onIceConnectionStateChange this type: \" + pc.type + \", iceConnectionState: \" + iceState);\r\n    switch (iceState) {\r\n        case 'new':\r\n        case 'starting':\r\n        case 'checking':\r\n            break\r\n        case 'connected':\r\n            if(pc.isIceFailed){\r\n                log.info(\"iceRestartSuccess alter web\");\r\n                this.onIceRestartSuccess(pc)\r\n            }\r\n            break\r\n        case 'failed':\r\n            this.iceConnectFailed(pc)\r\n            break\r\n        case 'completed':\r\n        case 'closed':\r\n        case 'disconnected':\r\n            break\r\n        default:\r\n            break\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onSignalingStateChange = function(pc){\r\n    if (!pc) {\r\n        log.info('PeerConnection is null: unexpected')\r\n        return\r\n    }\r\n    log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)\r\n}\r\n\r\nPeerConnection.prototype.onIceGatheringStateChange = function(pc){\r\n    if (!pc) {\r\n        log.info('PeerConnection is null: unexpected')\r\n        return\r\n    }\r\n\r\n    log.info('onicegatheringstatechange type: ' + pc.type + ', iceGatheringState: ' + pc.iceGatheringState)\r\n}\r\n\r\nPeerConnection.prototype.iceConnectFailed = function(pc){\r\n    log.warn(\"iceConnectFailed, o_failure_num: \" + pc.iceFailureNum + \"  (PC:\" + pc.type + \")\");\r\n    pc.action = 'iceRestart'\r\n    // Re-connected three times without success is considered a failure\r\n    if(pc.iceFailureNum >= 3){\r\n        log.error(\"Failed to do ice restart(PC: \" + pc.type + \")\");\r\n        if(!pc.isIceFailed){\r\n            pc.isIceFailed = true\r\n        }\r\n        this.onIceRestartFailed();\r\n    }else {\r\n        log.info('Prepare start do ice restart！')\r\n        pc.isIceFailed = true\r\n        this.gsRTC.sendInviteQueue.push({\r\n            action: 'iceRestart',\r\n            sdp: null,\r\n            type: pc.type\r\n        })\r\n\r\n        this.doOffer(pc)\r\n        pc.iceFailureNum ++\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceRestartSuccess = function (pc) {\r\n    log.info(\"ice restart success\" + \"  (PC:\" + pc.type + \")\")\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = false\r\n}\r\n\r\nPeerConnection.prototype.onIceRestartFailed = function (pc) {\r\n    log.error(\"ice restart failed\")\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = true\r\n    this.gsRTC.sipStack.jsSipSendBye()\r\n    log.info('close peer')\r\n    for (let key in this.RTCSession.peerConnections) {\r\n        let pc = this.RTCSession.peerConnections[key];\r\n        // close peerConnection\r\n        pc.getSenders().forEach(sender => {\r\n            delete sender.track\r\n            sender.replaceTrack(null)\r\n        })\r\n        pc.close()\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceCandidate = function (pc, event) {\r\n    let iceState = pc.iceGatheringState\r\n    if(iceState === \"completed\" || iceState === \"complete\" || (event && !event.candidate)){\r\n        log.warn(\"onIceCandidate: ICE GATHERING COMPLETED( PC: \" + pc.type + \")\");\r\n        pc.isLocalSdpPending = false\r\n        this.onIceGatheringCompleted();\r\n    }else {\r\n        log.info(`${ pc.type } ICE candidate:\\n${event.candidate ? event.candidate.candidate : '(null)'}`);\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceGatheringCompleted = function () {\r\n    if(!this.gsRTC.isProcessingInvite){\r\n        return\r\n    }\r\n\r\n    if(this.peerConnections){\r\n        for (let key in this.peerConnections){\r\n            let pc = this.peerConnections[key]\r\n            if(pc.isLocalSdpPending === true){\r\n                log.info('MyOnIceGatheringCompleted not ready( ' + pc.type + \" )\")\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    log.warn(\"__MyOnIceGatheringCompleted be ready to send INVITE or 200OK\");\r\n    this.gsRTC.isProcessingInvite = false\r\n    this.gsRTC.eventStack({type: 'GET_LO_SUCCESS'})\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\r\n/**\r\n * get sdp by type\r\n * @param type\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getSdpByType = function (type, sdp) {\r\n    if(!type || !sdp){\r\n        log.warn('invalid parameters remote sdp or type!')\r\n        return\r\n    }\r\n    let This = this\r\n    let result = null\r\n    let parseSdp\r\n    let mid\r\n\r\n    // 这里setRemote 之前修改一下mid\r\n    if(this.enableMultiStream === true){\r\n        log.info('get multi stream sdp')\r\n        result = sdp\r\n    }else {\r\n        let sdpArray = SDPTools.splitSDP(sdp);\r\n        for(let i = 0; i<sdpArray.length; i++) {\r\n            if (type === 'audio' && sdpArray[i].indexOf('m=audio') >= 0) {\r\n                result = sdpArray[i]\r\n                mid = This.MID_OBJ.AUDIO_MID.ORIGINAL_MID\r\n            // video1 for wfu\r\n            } else if ((type === 'main' || type === 'video1') && sdpArray[i].indexOf('a=content:main') >= 0) {\r\n                result = sdpArray[i]\r\n                mid = This.MID_OBJ.MAIN_MID.ORIGINAL_MID\r\n            } else if (type === 'slides' && sdpArray[i].indexOf('a=content:slides') >= 0) {\r\n                mid = This.MID_OBJ.SLIDES_MID.ORIGINAL_MID\r\n                result = sdpArray[i]\r\n            }\r\n\r\n            if(result){\r\n                parseSdp = SDPTools.parseSDP(result)\r\n                parseSdp = This.modifiedMidOfSdp(parseSdp, mid)\r\n                result = SDPTools.writeSDP(parseSdp)\r\n            }\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * set sdp session version\r\n * @param localSdp\r\n */\r\nGsRTC.prototype.saveSDPSessionVersion = function (localSdp) {\r\n    log.info('set local sdp session version value')\r\n    if(!localSdp){\r\n        log.warn('invalid parameters local sdp!')\r\n        return\r\n    }\r\n\r\n    let This = this\r\n    let parseSdp = SDPTools.parseSDP(localSdp)\r\n\r\n    if(This.isSendReInvite){\r\n        parseSdp.origin.sessionVersion = This.sessionVersion + 1\r\n        This.sessionVersion = parseSdp.origin.sessionVersion\r\n    }else {\r\n        This.sessionVersion = parseSdp.origin.sessionVersion\r\n    }\r\n}\r\n\r\n/**\r\n * get resolution bu given level idc\r\n * @param levelIdc\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByLevelIdc = function(levelIdc){\r\n    if(!levelIdc){\r\n        log.warn('getResolutionByLevelIdc: levelIdc is null')\r\n        return null\r\n    }\r\n    let resolution\r\n    switch (levelIdc) {\r\n        case '33':\r\n            log.info('levelIdc ' + levelIdc + ', 3840 * 2160 ')\r\n            resolution = { width: 3840, height: 2160 }\r\n            break\r\n        case '28':\r\n            log.info('levelIdc ' + levelIdc + ', 1920 * 1080 ')\r\n            resolution = { width: 1920, height: 1080 }\r\n            break\r\n        case '1f':\r\n            log.info('levelIdc ' + levelIdc + ', 1280 * 720 ')\r\n            resolution = { width: 1280, height: 720 }\r\n            break\r\n        case '1e':\r\n            log.info('levelIdc ' + levelIdc + ', 848 * 480 ')\r\n            resolution = { width: 848, height: 480 }\r\n            break\r\n        case '16':\r\n            log.info('levelIdc ' + levelIdc + ', 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n        case '15':\r\n            log.info('levelIdc ' + levelIdc + ', 480 * 272 ')\r\n            resolution = { width: 480, height: 272 }\r\n            break\r\n        default:\r\n            log.info('levelIdc ' + levelIdc + ', get default 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get resolution bu given max-fs\r\n * @param maxFs\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByMaxfs = function(maxFs){\r\n    if(!maxFs){\r\n        log.warn('getResolutionByMaxfs: maxFs is null')\r\n        return null\r\n    }\r\n    let resolution\r\n\r\n    maxFs = parseInt(maxFs)\r\n    switch (maxFs) {\r\n        case 32400:\r\n            log.info('maxFs ' + maxFs + ', 3840 * 2160 ')\r\n            resolution = { width: 3840, height: 2160 }\r\n            break\r\n        case 8160:\r\n            log.info('maxFs ' + maxFs + ', 1920 * 1080 ')\r\n            resolution = { width: 1920, height: 1080 }\r\n            break\r\n        case 3600:\r\n            log.info('maxFs ' + maxFs + ', 1280 * 720 ')\r\n            resolution = { width: 1280, height: 720 }\r\n            break\r\n        case 1590:\r\n            log.info('maxFs ' + maxFs + ', 848 * 480 ')\r\n            resolution = { width: 848, height: 480 }\r\n            break\r\n        case 920:\r\n            log.info('maxFs ' + maxFs + ', 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n        case 510:\r\n            log.info('maxFs ' + maxFs + ', 480 * 272 ')\r\n            resolution = { width: 480, height: 272 }\r\n            break\r\n        default:\r\n            log.info('maxFs ' + maxFs + ', get default 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n *  get resolution by given height\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByHeight = function(height){\r\n    if(!height){\r\n        log.warn('getResolutionByHeight: height is null')\r\n        return null\r\n    }\r\n    let resolution\r\n\r\n    height = parseInt(height)\r\n    switch (height) {\r\n        case 2160:\r\n            log.info('3840 * 2160')\r\n            resolution = {width: 3840, height: 2160}\r\n            break\r\n        case 1080:\r\n            log.info('1920 * 1080')\r\n            resolution = {width: 1920, height: 1080}\r\n            break\r\n        case 720:\r\n            log.info('1280 * 720')\r\n            resolution = {width: 1280, height: 720}\r\n            break;\r\n        case 480:\r\n            log.info('848 * 480')\r\n            resolution= {width: 848, height: 480}\r\n            break;\r\n        case 360:\r\n            log.info('640 * 360')\r\n            resolution= {width: 640, height: 360}\r\n            break;\r\n        default:\r\n            log.info(' Unknown resolution ' + height + ', default 640 * 360')\r\n            resolution = {width: 640, height: 360}\r\n            break;\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * save video resolution\r\n * @param resolution\r\n * @param type\r\n */\r\nGsRTC.prototype.setVideoResolution = function (resolution, type) {\r\n    if(!resolution || !type){\r\n        log.warn('setVideoResolution: INVALID PARAMETERS')\r\n        return\r\n    }\r\n    let This = this\r\n\r\n    switch (type) {\r\n        case 'EXPECT_RECV_RESOLUTION':\r\n            log.info('save expect receive resolution ' + resolution.height)\r\n            This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION = resolution\r\n            break\r\n        case 'CURRENT_UP_RESOLUTION':\r\n            log.info('save current up resolution ' + resolution.height)\r\n            This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION = resolution\r\n            break\r\n        default:\r\n            log.info('unknown resolution: ' + type)\r\n          break\r\n    }\r\n}\r\n\r\n/**\r\n * get saved video resolution\r\n * @param type\r\n * @returns {*|GsRTC.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION|{}|GsRTC.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION}\r\n */\r\nGsRTC.prototype.getVideoResolution = function (type) {\r\n    if(!type){\r\n        log.warn('getVideoResolution: INVALID PARAMETER')\r\n        return\r\n    }\r\n    let This = this\r\n    let resolution\r\n\r\n    switch (type) {\r\n        case 'EXPECT_RECV_RESOLUTION':\r\n            resolution = This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION\r\n            log.info('get expect receive resolution')\r\n            break\r\n        case 'CURRENT_UP_RESOLUTION':\r\n            resolution = This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION\r\n            log.info('get current up resolution')\r\n            break\r\n        default:\r\n            log.info('unknown resolution :' + type)\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\n\r\n/**\r\n * Get the codec name corresponding to the highest priority PT in the sdp\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getPriorityCodecBySdp = function(sdp){\r\n    let codec = null\r\n   try {\r\n       if(sdp.media && sdp.media[0] && sdp.media[0].rtp){\r\n           let rtp = sdp.media[0].rtp\r\n           if(rtp && rtp.length > 0){\r\n               codec = rtp[0].codec\r\n           }\r\n       }\r\n   }catch (e) {\r\n       log.error(e.toString())\r\n   }\r\n    log.info('get priority payload, ' + codec)\r\n    return codec\r\n}\r\n\r\n/**\r\n * get framerate\r\n * order: framerate first, max-fr second\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getFramerateBySdp = function (sdp) {\r\n    let framerate = null\r\n    if(sdp.media && sdp.media[0]){\r\n        if(sdp.media[0].framerate){\r\n            framerate = sdp.media[0].framerate\r\n            log.info('framerate, ' + framerate)\r\n        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){\r\n            let fmtp = sdp.media[0].fmtp\r\n            for(let i = 0; i<fmtp.length; i++){\r\n                let pos_max_fr = fmtp[i].config.indexOf('max-fr')\r\n                if (pos_max_fr >= 0) {\r\n                    var max_fr = fmtp[i].config.substring(pos_max_fr + 7);\r\n                    var end = max_fr.indexOf(';');\r\n                    if (end >= 0) {\r\n                        max_fr = max_fr.substring(0, end);\r\n                    }\r\n                    log.info('max-fr, ' + max_fr)\r\n                    framerate =  parseInt(max_fr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    log.info('get framerate, ' + framerate)\r\n    return framerate\r\n}\r\n\r\n/**\r\n * get resolution from profile-level-id\r\n * @param sdp: parseSDP\r\n */\r\nGsRTC.prototype.getH264ResolutionBySdp = function(sdp){\r\n    if(!sdp){\r\n        log.warn('getH264ResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    let subSDP = SDPTools.writeSDP(sdp)\r\n    let index = subSDP.indexOf('profile-level-id')\r\n    let resolution = {}\r\n    if(index >= 0){\r\n        let levelIdc = subSDP.substr(index + 21, 2)\r\n        levelIdc = levelIdc.toLocaleLowerCase()\r\n        switch (levelIdc) {\r\n            case '15':\r\n                resolution = { width: 480, height: 272 }\r\n                break;\r\n            case '16':\r\n                resolution = { width: 640, height: 360 }\r\n                break;\r\n            case '1e':\r\n                resolution = { width: 848, height: 480 }\r\n                break;\r\n            case '1f':\r\n                resolution = { width: 1280, height: 720 }\r\n                break;\r\n            case '28':\r\n                resolution = { width: 1920, height: 1080 }\r\n                break;\r\n            case '33':\r\n                resolution = { width: 3840, height: 2160 }\r\n                break\r\n            default:\r\n                resolution = { width: 640, height: 360 }\r\n                log.info('return default value 640 * 360')\r\n                log.info(\"getH264ResolutionBySdp: The value is out of the range, \" + levelIdc);\r\n                break;\r\n        }\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)\r\n    }else {\r\n        log.info('get resolution {}')\r\n    }\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get vp8 resolution from max-fs\r\n * @param sdp: parseSDP\r\n */\r\nGsRTC.prototype.getVp8ResolutionBySdp = function(sdp){\r\n    if(!sdp){\r\n        log.warn('getVp8ResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    let subSDP = SDPTools.writeSDP(sdp)\r\n    let index = subSDP.indexOf('max-fs')\r\n    let resolution  = {}\r\n    if(index >= 0){\r\n        let maxFs = subSDP.substring(index + 7)\r\n        maxFs = parseInt(maxFs.substring(0,maxFs.indexOf(';')))\r\n        log.info('VP8, ' + maxFs)\r\n        switch (maxFs) {\r\n            case 520:\r\n                resolution = { width: 480, height: 272 }\r\n                break;\r\n            case  920:\r\n            case  900:\r\n                resolution = { width: 640, height: 360 }\r\n                break;\r\n            case 1596:\r\n                resolution = { width: 848, height: 480 }\r\n                break;\r\n            case 3600:\r\n                resolution = { width: 1280, height: 720 }\r\n                break;\r\n            case 8192:\r\n            case 8160:\r\n            case 8100:\r\n                resolution = { width: 1920, height: 1080 }\r\n                break;\r\n            case 32400:\r\n                resolution = { width: 3840, height: 2160 }\r\n                break\r\n            default:\r\n                resolution = { width: 640, height: 360 }\r\n                log.info('return default value 640 * 360')\r\n                log.info(\"get_vp8_resolution: The value is out of the range or invalid, \" + maxFs);\r\n                break;\r\n        }\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)\r\n    }else {\r\n        log.info('get resolution {}')\r\n    }\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get resolution\r\n * @param sdp : parseSDP\r\n */\r\nGsRTC.prototype.getResolutionBySdp = function (sdp) {\r\n    log.info('get resolution')\r\n    if(!sdp){\r\n        log.warn('getResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n    let codec = this.getPriorityCodecBySdp(sdp)\r\n    let resolution = {}\r\n\r\n    if(codec === 'H264'){\r\n        resolution = this.getH264ResolutionBySdp(sdp)\r\n    }\r\n    if(codec === 'VP8'){\r\n        resolution = this.getVp8ResolutionBySdp(sdp)\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('resolution ' + resolution.width + \" * \" + resolution.height)\r\n    }else {\r\n        log.info('resolution {}')\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * set frameRate of sdp\r\n * order: framerate first ,max-fr second\r\n * @param sdp: parseSDP\r\n * @param framerate\r\n */\r\nGsRTC.prototype.setFrameRateOfSdp = function(sdp, framerate){\r\n    if(!sdp || !framerate){\r\n        log.warn('setFrameRate: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    if(sdp.media && sdp.media[0]){\r\n        if(sdp.media[0].framerate){\r\n            log.info('change framerate ' + sdp.media[0].framerate + ' to ' + framerate)\r\n            sdp.media[0].framerate = framerate\r\n        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){\r\n            let fmtp = sdp.media[0].fmtp\r\n            for(let i = 0; i<fmtp.length; i++){\r\n                let index = fmtp[i].config.indexOf('max-fr')\r\n                if (index >= 0) {\r\n                    let replacement =  'max-fr=' + framerate ;\r\n                    fmtp[i].config = fmtp[i].config.replace(/max-fr=([a-zA-Z0-9]{1,2})/, replacement);\r\n                    log.info('change max-fr to ' + framerate)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * Modify level-idc of sdp\r\n * @param sdp: parseSDP\r\n * @param width\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setH264ResolutionOfSdp = function(sdp, width, height){\r\n    if(!sdp || !width || !height){\r\n        log.warn('setH264ResolutionOfSdp: Invalid argument!')\r\n        return\r\n    }\r\n    let levelIdc = null\r\n    switch (height) {\r\n        case 2160:\r\n            levelIdc = '33'\r\n            break\r\n        case 1080:\r\n            levelIdc = '28'\r\n            break\r\n        case 720:\r\n            levelIdc = '1f'\r\n            break\r\n        case 480:\r\n            levelIdc = '1e'\r\n            break\r\n        case 360:\r\n            levelIdc = '16'\r\n            break\r\n        case 272:\r\n            levelIdc = '15'\r\n            break\r\n        default:\r\n            levelIdc = 16\r\n            log.info('set default levelIdc, ' + levelIdc)\r\n            break\r\n    }\r\n\r\n    log.info('set levelId of local sdp ' + levelIdc)\r\n\r\n    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp){\r\n        let fmtp = sdp.media[0].fmtp\r\n        if(fmtp.length > 0){\r\n            for(let i = 0; i < fmtp.length; i++){\r\n                let index  = fmtp[i].config.indexOf('profile-level-id')\r\n                if(index >= 0){\r\n                    let str = fmtp[i].config.substr(index, 21);\r\n                    let replacement =  str + levelIdc ;\r\n                    fmtp[i].config = fmtp[i].config.replace(/profile-level-id=([a-zA-Z0-9]{6})/, replacement);\r\n                }\r\n            }\r\n        }\r\n    }else {\r\n        log.info('profile-level-id fmtp filed has not been find')\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * Modify max-fs of sdp\r\n * @param sdp: parseSDP\r\n * @param width\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setVp8ResolutionOfSdp = function(sdp, width, height){\r\n    if(!sdp || !width || !height){\r\n        log.warn('setVp8ResolutionOfSdp: Invalid argument!')\r\n        return\r\n    }\r\n    let mbWidth = (parseInt(width, 10) + 15) / 16;\r\n    let mbHeight = (parseInt(height, 10) + 15) / 16;\r\n    let maxFs = Math.floor(mbWidth) * Math.floor(mbHeight);\r\n    log.info('set mas-fs ,' + maxFs)\r\n\r\n    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp) {\r\n        let fmtp = sdp.media[0].fmtp\r\n        for (let i = 0; i < fmtp.length; i++) {\r\n            let index = fmtp[i].config.indexOf('max-fs')\r\n            if (index >= 0) {\r\n                let replacement = 'max-fs=' + maxFs;\r\n                fmtp[i].config = fmtp[i].config.replace(/max-fs=([a-zA-Z0-9]{3,5})/, replacement);\r\n            }\r\n        }\r\n    }else {\r\n        log.warn('max-fs fmtp filed has not been find')\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * modified mid of sdp\r\n * @param sdp\r\n * @param mid\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.modifiedMidOfSdp = function(sdp, mid){\r\n    log.info('modified mid of sdp')\r\n    if(sdp.media && sdp.media[0]){\r\n        sdp.media[0].mid = mid\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * save original and modified mid before send invites\r\n * @param sdp\r\n * @param type\r\n */\r\nGsRTC.prototype.saveMidBeforeSendInvite = function(sdp, type){\r\n    log.info('save mid')\r\n    let This = this\r\n    let mid\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    if(parseSDP.media && parseSDP.media[0] && parseSDP.media[0]){\r\n        mid = parseSDP.media[0].mid\r\n    }\r\n\r\n    switch (type) {\r\n        case 'audio':\r\n            This.MID_OBJ.AUDIO_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.AUDIO_MID.MODIFIED_MID = 0\r\n            break\r\n        case 'main':\r\n            This.MID_OBJ.MAIN_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.MAIN_MID.MODIFIED_MID = 1\r\n            break\r\n        case 'slides':\r\n            This.MID_OBJ.SLIDES_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.SLIDES_MID.MODIFIED_MID = 2\r\n            break\r\n        default:\r\n            break\r\n    }\r\n}\r\n\r\n/**\r\n * get modified mid before set remote\r\n * @param type\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getModifiedMid = function(type){\r\n    let This = this\r\n    let mid;\r\n    if(type === \"audio\"){\r\n        mid = This.MID_OBJ.AUDIO_MID.MODIFIED_MID ? This.MID_OBJ.AUDIO_MID.MODIFIED_MID : 0;\r\n    }else if(type === \"main\"){\r\n        mid = This.MID_OBJ.MAIN_MID.MODIFIED_MID ? This.MID_OBJ.MAIN_MID.MODIFIED_MID : 1;\r\n    }else if(type === \"slides\"){\r\n        mid = This.MID_OBJ.SLIDES_MID.MODIFIED_MID ? This.MID_OBJ.SLIDES_MID.MODIFIED_MID : 2;\r\n    }\r\n    log.info('get ' + type + ' mid of ' + mid)\r\n    return mid;\r\n}\r\n\r\n/**\r\n * change resolution of sdp\r\n * @param width\r\n * @param height\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setResolutionOfSdp = function (sdp, width, height) {\r\n    if (!sdp || !width || !height) {\r\n        log.error(\"Invalid argument\");\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        sdp = this.setH264ResolutionOfSdp(sdp, width, height)\r\n        sdp = this.setVp8ResolutionOfSdp(sdp, width, height)\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n    return sdp\r\n}\r\n\r\n/**\r\n * Processing sdp when multistream\r\n * @param subSDP\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.decorateMultiStreamSdp  = function(subSDP) {\r\n    let This = this\r\n    var sdp\r\n    let sdpArray = []\r\n    let lines = subSDP.split('\\n')\r\n\r\n    // modified BUNDLE and content\r\n    for(let i = 0; i<lines.length; i++){\r\n        if(lines[i].indexOf('a=group:BUNDLE') >= 0){\r\n            lines.splice(i, 2, \"a=msid-semantic: WMS\\na=msid-semantic: WMS\\na=msid-semantic: WMS\\na=group:BUNDLE 0\\na=group:BUNDLE 1\\na=group:BUNDLE 2\");\r\n        }\r\n        if(lines[i].indexOf('a=mid:1') >= 0){\r\n            lines.splice(i+1, 0, \"a=content:main\");\r\n            i++\r\n        }\r\n        if(lines[i].indexOf('a=mid:2') >= 0){\r\n            lines.splice(i+1, 0, \"a=content:slides\");\r\n            i++\r\n        }\r\n    }\r\n\r\n    // get all media line\r\n    function getPositions(arr){\r\n        // get all media line\r\n        let pos = []\r\n        for(let i = 0; i<arr.length; i++){\r\n            if(arr[i].indexOf('m=') >= 0){\r\n                pos.push(i)\r\n            }\r\n        }\r\n        return pos\r\n    }\r\n    let positions = getPositions(lines)\r\n\r\n    let target\r\n    let index = 0\r\n    // get audio main slides sdp array\r\n    if(positions.length > 0){\r\n        for(let j = 0; j <= positions.length; j++){\r\n            if(j === positions.length){\r\n                target = lines.slice(positions[index], lines.length).join('\\n')\r\n            }else {\r\n                target = lines.slice(positions[j-1], positions[j]).join('\\n')\r\n            }\r\n            sdpArray.push(target)\r\n            index = j\r\n        }\r\n    }\r\n\r\n    sdpArray[0] = sdpArray[0].concat(['\\n'])\r\n    let audioSdp = sdpArray[0].concat(sdpArray[1])\r\n    let mainSdp = sdpArray[0].concat(sdpArray[2])\r\n    let slidesSdp = sdpArray[0].concat(sdpArray[3])\r\n\r\n    // delete useless PT number for main\r\n    let mainSdp_ = SDPTools.parseSDP(mainSdp)\r\n    SDPTools.removeCodecByPayload(mainSdp_, 0, [98, 99,127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])\r\n    // set resolution of sdp\r\n    let resolution = This.getVideoResolution('EXPECT_RECV_RESOLUTION')\r\n    if(resolution.width && resolution.height){\r\n        // set expected receive resolution\r\n        mainSdp_ = This.setResolutionOfSdp(mainSdp_, resolution.width, resolution.height)\r\n    }\r\n    mainSdp = SDPTools.writeSDP(mainSdp_)\r\n    // delete useless PT number for slides\r\n    let slidesSdp_ = SDPTools.parseSDP(slidesSdp)\r\n    SDPTools.removeCodecByPayload(slidesSdp_, 0, [98, 99, 127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])\r\n    slidesSdp = SDPTools.writeSDP(slidesSdp_)\r\n\r\n    // delete ssrc if no stream to send\r\n    function removeSSRC(sdp){\r\n        let sdpArray = sdp.split('\\n');\r\n        for(let k = 0; k<sdpArray.length; k++){\r\n            if(sdpArray[k].indexOf('a=ssrc-group:') >= 0 || sdpArray[k].indexOf('a=ssrc') >= 0 || sdpArray[k].indexOf('a=msid:-') >= 0){\r\n                sdpArray.splice(k, 1)\r\n                k--\r\n            }\r\n        }\r\n        return sdpArray.join('\\n')\r\n    }\r\n\r\n    // modified direction for three media\r\n    let audioStream = This.RTCSession.getStream('audio', true)\r\n    if(!audioStream){\r\n        audioSdp = audioSdp.replace(/a=sendrecv/g, \"a=recvonly\")\r\n        audioSdp = removeSSRC(audioSdp)\r\n    }\r\n    let mainStream = This.RTCSession.getStream('main', true)\r\n    if(!mainStream){\r\n        mainSdp = mainSdp.replace(/a=sendrecv/g, \"a=recvonly\")\r\n        mainSdp = removeSSRC(mainSdp)\r\n    }\r\n    // set direction recvonly if not share screen\r\n    let stream = This.RTCSession.getStream('slides', true)\r\n    if(stream){\r\n        slidesSdp = slidesSdp.replace(/a=sendrecv/g, \"a=sendonly\");\r\n        slidesSdp = slidesSdp.replace(/a=recvonly/g, \"a=sendonly\");\r\n    }else {\r\n        slidesSdp = slidesSdp.replace(/a=sendrecv/g, \"a=recvonly\");\r\n        slidesSdp = removeSSRC(slidesSdp)\r\n    }\r\n\r\n    function deleteHead(sdp) {\r\n        let lines = sdp.split('\\n')\r\n        for(var k = 0; k<lines.length; k++){\r\n            if(lines[k].indexOf('m=') >= 0){\r\n                sdpArray[0] = lines.slice(0, k)\r\n                sdp = lines.slice(k, lines.length).join('\\n')\r\n            }\r\n        }\r\n        return sdp\r\n    }\r\n\r\n    audioSdp = deleteHead(audioSdp)\r\n    mainSdp = deleteHead(mainSdp)\r\n    slidesSdp = deleteHead(slidesSdp)\r\n    let head =  sdpArray[0].join('\\n')\r\n    sdp = head + '\\n' + audioSdp + '\\n'+ mainSdp + slidesSdp\r\n    return sdp\r\n}\n/*Log Debug Start*/\r\n/**\r\n * @param {Function} debug The function that handles the DEBUG level logs.\r\n * @param {Function} log The function that handles the LOG level logs.\r\n * @param {Function} info The function that handles the INFO level logs.\r\n * @param {Function} warn The function that handles the WARN level logs.\r\n * @param {Function} error The function that handles the ERROR level logs.\r\n * @type {{warn: *, debug: *, log: *, error: *, info: *}}\r\n */\r\nvar log = {\r\n    debug: window.debug(\"WebSocket:DEBUG\"),\r\n    log: window.debug(\"WebSocket:LOG\"),\r\n    info: window.debug(\"WebSocket:INFO\"),\r\n    warn: window.debug(\"WebSocket:WARN\"),\r\n    error: window.debug(\"WebSocket:ERROR\")\r\n};\r\n/*Log Debug End*/\r\n\r\n/**\r\n * create webSocket instance\r\n * @param url\r\n * @param protocol such as sip\r\n * @returns {WebSocket|*}\r\n * @constructor\r\n */\r\nlet WebSocketInstance = function (url, protocol) {\r\n    log.info('create new webSocket.')\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(url)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" + url + \"' is not valid as webSocket url value\");\r\n    }\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(protocol)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" + protocol + \"' is not valid as protocol value\");\r\n    }\r\n\r\n    if(this instanceof WebSocketInstance){\r\n        this.isChannelOpen = false\r\n        this.ws = this.createWebSocket(url, protocol)\r\n    }else {\r\n        return new WebSocketInstance()\r\n    }\r\n}\r\n\r\n/**\r\n * create new webSocket\r\n * @param url\r\n * @param protocols\r\n * @returns {WebSocket}\r\n */\r\nWebSocketInstance.prototype.createWebSocket = function(url, protocols){\r\n    log.info('create webSocket')\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(url)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" + url + \"' is not valid as webSocket url value\");\r\n    }\r\n\r\n    let This = this\r\n    log.info('Connecting to \\'' + url);\r\n    let ws = new WebSocket(url, protocols)\r\n    ws.onopen = function (event) {\r\n        log.info('websocket onopen')\r\n        This.isChannelOpen = true;\r\n    }\r\n\r\n    ws.onmessage = function (event) {\r\n        // if (typeof (event.data) === 'string') {\r\n        //     jsSipParser(event.data, 0)\r\n        // }\r\n\r\n        // for wfu\r\n        if (isJsonString(event.data)) {\r\n            let parseDate = JSON.parse(event.data)\r\n            console.warn(\"************ onmessage parseDate: \", parseDate)\r\n            if (parseDate.createMediaSessionRet && parseDate.createMediaSessionRet.sdp && parseDate.createMediaSessionRet.sdp.data) {\r\n                role = ''\r\n                let sdp  = parseDate.createMediaSessionRet.sdp.data\r\n                console.warn('get createMediaSessionRet sdp: \\n', sdp)\r\n                gsRTC.RTCSession.commonDecorateRo(sdp)\r\n            }\r\n        } else {\r\n            let type = typeJudgement(event.data)\r\n            console.warn(\"event.data type: \", type)\r\n        }\r\n    }\r\n\r\n    ws.onclose = function (event) {\r\n        log.info('websocket onclose')\r\n        console.warn(event)\r\n        This.isChannelOpen = false\r\n    }\r\n\r\n    ws.onerror = function (event) {\r\n        log.info('websocket onerror')\r\n        console.warn(event)\r\n    }\r\n\r\n    return ws\r\n}\r\n\r\n\r\n/**\r\n * send message\r\n * @param message\r\n */\r\nWebSocketInstance.prototype.sendMessage = function (message) {\r\n    try {\r\n        if(!this.ws){\r\n            log.warn('websocket has not been created yet to send message')\r\n            return\r\n        }\r\n\r\n        // for wfu\r\n        if(window.wfu === true){\r\n            let reqId = parseInt(Math.round(Math.random()*100));\r\n            console.warn(\"random req id is\" + reqId);\r\n            let data = {\r\n                createMediaSession: {\r\n                    userName: \"wfu_test\",\r\n                    reqId: reqId,\r\n                    sdp: {\r\n                        length: message.length,\r\n                        data: message,\r\n                    }\r\n                }\r\n            }\r\n            log.warn(\"ws send message: \" , data);\r\n            this.ws.send(JSON.stringify(data))\r\n        }else {\r\n            this.ws.send(message)\r\n        }\r\n    }catch (e) {\r\n        console.error(e)\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n\n"],"file":"gsRTC.min.js"}