
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.debug = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){},{

}],2:[function(require,module,exports){
/* global window, exports, define */
    !function() {
            'use strict';

            var re = {
                not_string: /[^s]/,
                not_bool: /[^t]/,
                not_type: /[^T]/,
                not_primitive: /[^v]/,
                number: /[diefg]/,
                numeric_arg: /[bcdiefguxX]/,
                json: /[j]/,
                not_json: /[^j]/,
                text: /^[^\x25]+/,
                modulo: /^\x25{2}/,
                placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
                key: /^([a-z_][a-z_\d]*)/i,
                key_access: /^\.([a-z_][a-z_\d]*)/i,
                index_access: /^\[(\d+)\]/,
                sign: /^[\+\-]/
            }

            function sprintf(key) {
                // `arguments` is not an array, but should be fine for this call
                return sprintf_format(sprintf_parse(key), arguments)
            }

            function vsprintf(fmt, argv) {
                return sprintf.apply(null, [fmt].concat(argv || []))
            }

            function sprintf_format(parse_tree, argv) {
                var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign
                for (i = 0; i < tree_length; i++) {
                    if (typeof parse_tree[i] === 'string') {
                        output += parse_tree[i]
                    }
                    else if (Array.isArray(parse_tree[i])) {
                        match = parse_tree[i] // convenience purposes only
                        if (match[2]) { // keyword argument
                            arg = argv[cursor]
                            for (k = 0; k < match[2].length; k++) {
                                if (!arg.hasOwnProperty(match[2][k])) {
                                    throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
                                }
                                arg = arg[match[2][k]]
                            }
                        }
                        else if (match[1]) { // positional argument (explicit)
                            arg = argv[match[1]]
                        }
                        else { // positional argument (implicit)
                            arg = argv[cursor++]
                        }

                        if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {
                            arg = arg()
                        }

                        if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {
                            throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                        }

                        if (re.number.test(match[8])) {
                            is_positive = arg >= 0
                        }

                        switch (match[8]) {
                            case 'b':
                                arg = parseInt(arg, 10).toString(2)
                                break
                            case 'c':
                                arg = String.fromCharCode(parseInt(arg, 10))
                                break
                            case 'd':
                            case 'i':
                                arg = parseInt(arg, 10)
                                break
                            case 'j':
                                arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
                                break
                            case 'e':
                                arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()
                                break
                            case 'f':
                                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
                                break
                            case 'g':
                                arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)
                                break
                            case 'o':
                                arg = (parseInt(arg, 10) >>> 0).toString(8)
                                break
                            case 's':
                                arg = String(arg)
                                arg = (match[7] ? arg.substring(0, match[7]) : arg)
                                break
                            case 't':
                                arg = String(!!arg)
                                arg = (match[7] ? arg.substring(0, match[7]) : arg)
                                break
                            case 'T':
                                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                                arg = (match[7] ? arg.substring(0, match[7]) : arg)
                                break
                            case 'u':
                                arg = parseInt(arg, 10) >>> 0
                                break
                            case 'v':
                                arg = arg.valueOf()
                                arg = (match[7] ? arg.substring(0, match[7]) : arg)
                                break
                            case 'x':
                                arg = (parseInt(arg, 10) >>> 0).toString(16)
                                break
                            case 'X':
                                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                                break
                        }
                        if (re.json.test(match[8])) {
                            output += arg
                        }
                        else {
                            if (re.number.test(match[8]) && (!is_positive || match[3])) {
                                sign = is_positive ? '+' : '-'
                                arg = arg.toString().replace(re.sign, '')
                            }
                            else {
                                sign = ''
                            }
                            pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '
                            pad_length = match[6] - (sign + arg).length
                            pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                            output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                        }
                    }
                }
                return output
            }

            var sprintf_cache = Object.create(null)

            function sprintf_parse(fmt) {
                if (sprintf_cache[fmt]) {
                    return sprintf_cache[fmt]
                }

                var _fmt = fmt, match, parse_tree = [], arg_names = 0
                while (_fmt) {
                    if ((match = re.text.exec(_fmt)) !== null) {
                        parse_tree.push(match[0])
                    }
                    else if ((match = re.modulo.exec(_fmt)) !== null) {
                        parse_tree.push('%')
                    }
                    else if ((match = re.placeholder.exec(_fmt)) !== null) {
                        if (match[2]) {
                            arg_names |= 1
                            var field_list = [], replacement_field = match[2], field_match = []
                            if ((field_match = re.key.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1])
                                    }
                                    else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1])
                                    }
                                    else {
                                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                                    }
                                }
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                            match[2] = field_list
                        }
                        else {
                            arg_names |= 2
                        }
                        if (arg_names === 3) {
                            throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                        }
                        parse_tree.push(match)
                    }
                    else {
                        throw new SyntaxError('[sprintf] unexpected placeholder')
                    }
                    _fmt = _fmt.substring(match[0].length)
                }
                return sprintf_cache[fmt] = parse_tree
            }

            /**
             * export to either browser or node.js
             */
            /* eslint-disable quote-props */
            if (typeof exports !== 'undefined') {
                exports['sprintf'] = sprintf
                exports['vsprintf'] = vsprintf
            }
            if (typeof window !== 'undefined') {
                window['sprintf'] = sprintf
                window['vsprintf'] = vsprintf

                if (typeof define === 'function' && define['amd']) {
                    define(function() {
                        return {
                            'sprintf': sprintf,
                            'vsprintf': vsprintf
                        }
                    })
                }
            }
            /* eslint-enable quote-props */
        }()
},{}],3:[function(require,module,exports){
var sprintf = require("sprintf-js").sprintf;

var argsToString = function(args) {
            //sprintf-js did not support %o / %O
            args[0] = args[0].replace(/%o/g, "%s");

            switch (args.length) {
                case 1:
                    return args[0];
                case 2:
                    return sprintf(args[0], args[1]);
                case 3:
                    return sprintf(args[0], args[1], args[2]);
                case 4:
                    return sprintf(args[0], args[1], args[2], args[3]);
                case 5:
                    return sprintf(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                case 8:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                case 9:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                case 10:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                case 11:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);
                case 12:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);
                case 13:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);
                case 14:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);
                case 15:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);
                case 16:
                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);
                default:
                    return null;
            }
        };


function beautyDate(date) {
    var yyyy = date.getFullYear();
    var m = date.getMonth() + 1; // getMonth() is zero-based
    var d = date.getDate();
    var h = date.getHours();
    var mi = date.getMinutes();
    var sec = date.getSeconds();
    var msec = date.getMilliseconds();

    var mm  = m < 10 ? "0" + m : m;
    var dd  = d < 10 ? "0" + d : d;
    var hh  = h < 10 ? "0" + h : h;
    var min = mi < 10 ? "0" + mi : mi;
    var ss  = sec < 10 ? "0" + sec : sec;
    var mss = msec < 10 ? "00" + msec : ( msec < 100 ? "0" + msec : msec );

    return "".concat(yyyy).concat("-").concat(mm).concat("-").concat(dd).concat("@").concat(hh).concat(":").concat(min).concat(":").concat(ss).concat(".").concat(mss);
};

//For catch browser console error events
self.onerror = function(msg, url, lineNo, columnNo, error) {
    var message = [
        'Message: ' + msg,
        'URL: ' + url,
        'Line: ' + lineNo,
        'Column: ' + columnNo,
        'Error object: ' + JSON.stringify(error)
    ].join('\n');

    this.debug('Console:ERROR')(message);
    return false;
};

/***
 * indexedDB Class Model
 * @type {self.DBmanager}
 */
self.DBmanager = class DBmanager {
    constructor(dbName, storeName, version, index) {
        this.dbName = dbName;
        this.storeName = storeName;
        this.version = version || 1;
        this.index = index;
        this.currentDB = null;
    }

    /***
     * create database
     */
    openDB() {
        var request = self.indexedDB.open(this.dbName, this.version);
        request.onerror = function (e) {
            console.log(e.currentTarget.error.message);
        }.bind(this);

        request.onsuccess = function (e) {
            this.currentDB = e.target.result;
            console.log(this.currentDB.name + ' database is already opened!');
        }.bind(this);

        request.onupgradeneeded = function (e) {
            console.log('database version is already upgrade to ' + this.version);
            this.currentDB = e.target.result;
            if (!this.currentDB.objectStoreNames.contains(this.storeName)) {
                var objectStore = this.currentDB.createObjectStore(this.storeName, {keyPath: "id", autoIncrement: true});

                // create index
                if(this.index && this.index.length > 0){
                    this.index.forEach(function (item) {
                        objectStore.createIndex(item, item);
                    })
                }
            }
        }.bind(this);
    }

    /***
     * get store by storeName
     * @returns {IDBObjectStore}
     */
    getStoreByName() {
        return this.currentDB.transaction(this.storeName, 'readwrite').objectStore(this.storeName);
    }

    /***
     * add one data
     * data should be an object
     * @param data
     */
    setItem(data) {
        var store = this.getStoreByName(this.storeName);
        store.add(data);

        store.onsuccess = function (event) {
            console.log('Data write succeeded');
        };

        store.onerror = function (event) {
            console.log('Data write failed');
        }
    }

    /***
     * add more than one data
     * data should be array
     * @param items
     */
    setItems(items){
        var store = this.getStoreByName(this.storeName);
        for(var i = 0; i < items.length; i++){
            store.put(items[i]);
        }
    }

    /***
     * Get a piece of data by key value
     * @param key  Index name
     * @param value
     */
    getItem (key, value) {
        var store = this.getStoreByName(this.storeName);
        var index = store.index(key);
        var request = index.get(value);

        request.onsuccess = function( e) {
            if ( request.result) {
                console.log(request.result);
            } else {
                console.log('未获得数据记录');
            }
        };
    }

    /***
     * get all items
     */
    getAllItems() {
        var store = this.getStoreByName(this.storeName);
        var request = store.openCursor();

        request.onsuccess = function (event) {
            var cursor = event.target.result;

            if (cursor) {
                console.log(cursor.value);
                cursor.continue();
            } else {
                console.log('没有更多数据了！');
            }
        };
    }

    /***
     * update data
     * @param newItem
     */
    update(newItem) {
        var store = this.getStoreByName(this.storeName);
        store.put(newItem);

        store.onsuccess = function (event) {
            console.log('data update success');
        };

        store.onerror = function (event) {
            console.log('data update failed');
        }
    }

    clear () {
        var store = this.getStoreByName(this.storeName);
        var request = store.clear();

        request.onsuccess = function (event) {
            console.log('clear Success');
        };
        request.onerror = function (event) {
            console.log('clear Error');
        };
    }
};


/**
 * This is the common logic for both the Node.js and web browser implementations of `debug()`.
 */
module.exports = function setup(env) {
    createDebug.debug = createDebug['default'] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.sessionStorageSave = sessionStorageSave();
    createDebug.enabledLocalLog = enabledLocalLog;
    createDebug.enableLocalLog = enableLocalLog;
    createDebug.disableLocalLog = disableLocalLog;
    createDebug.getLocalLogs = getLocalLogs;
    createDebug.getLocalDBName = getLocalDBName;
    createDebug.exportLog = exportLog;

    //The currently state of Local Log.
    createDebug.localLogState = true;
    createDebug.createdDBList = false; //marked the DB List is saved.
    createDebug.logBuffer = [];

    // Function is converted to a function under createDebug, eg useColors、formatArgs ect.
    Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
    });

    // create dataBase
    createDebug.dataBaseListDB = new self.DBmanager('DatabaseLists', "keyvaluepairs", 1, ["dbName", "TS"]);
    createDebug.localLogsDB = new self.DBmanager(env.sessionStorage.dbName, "localLogs", 1, ["cseqNumber", "moduleName", "logLevel", "TS", "content"]);
    createDebug.dataBaseListDB.openDB();
    createDebug.localLogsDB.openDB();


   // Active `debug` instances.
    createDebug.instances = [ ];
    // The currently active debug mode names, and names to skip.
    createDebug.names = [ ];
    createDebug.skips = [ ];


     // Map of special "%n" handling functions, for the debug "format" argument.
     // Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    createDebug.formatters = { };

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */
    function selectColor(namespace) {
        var hash = 0, i;

        for (i in namespace) {
            hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;

    /**
     * Select a background color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectBGColor(namespace) {
        var hash = 0, i;

        var level = namespace.match(/:(\w+)/)[1];
        switch (level) {
        case 'DEBUG':
            i = 0;
            break;
        case 'LOG':
            i = 1;
            break;
        case 'INFO':
            i = 2;
            break;
        case 'WARN':
            i = 3;
            break;
        case 'ERROR':
            i = 4;
            break;
        case 'FATAL':
            i = 5;
            break;
        default:
            i = 2;
            break;
        }

        return createDebug.bgColors[i];
    }
    createDebug.selectBGColor = selectBGColor;

    function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */
    function enable(namespaces) {
        createDebug.save(namespaces);

        createDebug.names = [ ];
        createDebug.skips = [ ];

        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
            if (!split[i]) continue; // ignore empty strings
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') {
                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            } else {
                createDebug.names.push(new RegExp('^' + namespaces + '$'));
            }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
        }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
        createDebug.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
        if (name[name.length - 1] === '*') {
            return true;
        }
        var i, len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
                return false;
            }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Create a debugger with the given `namespace`.
     * @param {String} namespace
     * @return {Function}
     * @api public
     */
    function createDebug(namespace) {
        //var prevTime;
        function debug() {

            var date = new Date();
            // turn the `arguments` into a proper Array
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
            }
            args[0] = createDebug.coerce(args[0]);

            if ('string' !== typeof args[0]) {
                // anything else let's inspect with %O
                args.unshift('%O');
            }

            if (createDebug.localLogState === true) {
                //Save log into localforage whatever debug is disabled or not.
                var logTime = beautyDate(date);
                var logList = {
                    cseqNumber: createDebug.logIndex,
                    moduleName: namespace.split(":")[0],
                    logLevel: namespace.split(":")[1],
                    TS: (new Date()).getTime(),
                    content: argsToString(args)
                }

                createDebug.logBuffer.push(logList);

                // To avoid writing too often, write data to the database for every 20 data.
                if (createDebug.logBuffer.length >= 20) {
                    createDebug.localLogsDB.setItems(createDebug.logBuffer);
                    createDebug.logBuffer = [ ];

                    // save the databaseName into DatabaseLists database if not exist
                    if (!createDebug.createdDBList) {
                        var key = env.sessionStorage.dbName;
                        var store = createDebug.dataBaseListDB.getStoreByName();
                        var request = store.index('dbName').get(key);
                        var infoJson = {};

                        request.onsuccess = function( e) {
                            if ( !request.result) {
                                infoJson = {
                                    TS: [ (new Date()).getTime() ],
                                    dbName: env.sessionStorage.dbName,
                                    data: {
                                        confID: env.sessionStorage.confID,
                                        userName: self.localStorage.userName,
                                        email: self.localStorage.email
                                    }
                                };
                            } else {
                                infoJson = request.result;
                                var ts = request.result.TS;
                                if (ts) {
                                    infoJson.TS.push((new Date()).getTime());
                                }
                            }
                            createDebug.dataBaseListDB.update(infoJson);
                            createDebug.createdDBList = true;
                        };
                    }
                }
                createDebug.logIndex++;

                self.logIndex = createDebug.logIndex;
                self.sessionStorage.dbIndex = self.logIndex;
            }

            // apply env-specific formatting (colors, etc.)
            if (debug.enabled){
            createDebug.logFormatters(args, debug)
            }
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.bgColor = selectBGColor(namespace);
        debug.destroy = destroy;

        // env-specific initialization logic for debug instances
        if ('function' === typeof createDebug.init) {
            createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
    }

    /**
     * Log formatted output, add color, etc.
     * @param args
     * @param debug
     */
    function logFormatters(args, debug) {
        var self = debug;
        var index = 0;

        args[0] = args[0].replace(/%[a-zA-Z%]/g,function(match, format) {
            // if we encounter an escaped % then don't increase the array index
            if (match === '%%') return match;
            index++;
            var formatter = createDebug.formatters[format];
            if ('function' === typeof formatter) {
                var val = args[index];
                match = formatter.call(self, val);

                // now we need to remove `args[index]` since it's inlined in the `format`
                args.splice(index, 1);
                index--;
            }
            return match;
        });

        // apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);

        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
    }
    createDebug.logFormatters = logFormatters;

    /***
     * 本地会话存储
     */
    function sessionStorageSave() {
        var tabID = (env.sessionStorage.tabID && env.sessionStorage.closedLastTab !== '2') ? env.sessionStorage.tabID : (env.sessionStorage.tabID = Math.random().toString(36).substr(2));

        env.sessionStorage.closedLastTab = '2';
        self.onunload = self.onbeforeunload = function() {
            env.sessionStorage.closedLastTab = '1';
        };

        if (!env.sessionStorage.dbName || !env.sessionStorage.dbName.match(tabID) ) {
            console.log("Create dbName !!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            // env.sessionStorage.setItem("dbName", "db_" + tabID);
            env.sessionStorage.setItem("dbName", tabID + "_db");
            env.sessionStorage.setItem("dbIndex", "0");
        }

        if (!env.sessionStorage.dbIndex) {
            createDebug.logIndex = 0;
        } else {
            createDebug.logIndex = env.sessionStorage.dbIndex;
        }
        self.logIndex = createDebug.logIndex;
    }

    /**
   * Enable LocalLog
   *
   * @api public
   */
    function enableLocalLog() {
        createDebug.saveLocalLogState(true);
        createDebug.localLogState = true;
    }

    /**
     * Disable LocalLog.
     *
     * @api public
     */

    function disableLocalLog() {
        createDebug.saveLocalLogState(false);
        createDebug.localLogState = false;
    }

    /**
     * Returns true if the LocalLog is enabled, false otherwise.
     *
     * @return {Boolean}
     * @api public
     */

    function enabledLocalLog() {
        return createDebug.localLogState;
    }

    /**
     * Get the local log
     *
     * @param dbName
     * @param {String} filter  {String} dbName (null means current
     *        DB) {function} callback(logs)
     * @param callback
     * @return {Array} logs self.logs =
     *         self.logs.filter(function(x){return (x !==
     *         (undefined || null || ''));});
     * @api public
     */

    function getLocalLogs(dbName, filter, callback) {
        var localLogs = [];
        var skips = [ ];
        var names = [ ];
        var db;

        function enabled(name, skips, names) {
            if (name[name.length - 1] === '*') {
                return true;
            }
            var i, len;

            for (i = 0, len = skips.length; i < len; i++) {
                if (skips[i].test(name)) {
                    return false;
                }
            }

            for (i = 0, len = names.length; i < len; i++) {
                if (names[i].test(name)) {
                    return true;
                }
            }
            return false;
        }

        if (dbName && dbName !== createDebug.sessionStorage.dbName) {
            db = new self.DBmanager(dbName, "localLogs", 1, ["cseqNumber", "moduleName", "logLevel", "TS", "content"]);
        } else {
            db = createDebug.localLogsDB;
        }
        db.openDB();

        if (filter !== '*') {
            //Process filter
            var i = 0;
            var split = (typeof filter === 'string' ? filter : '').split(/[\s,]+/);
            var len = split.length;

            for (i = 0; i < len; i++) {
                if (!split[i]) continue; // ignore empty strings
                filter = split[i].replace(/\*/g, '.*?');
                if (filter[0] === '-') {
                    skips.push(new RegExp('^' + filter.substr(1) + '$'));
                } else {
                    names.push(new RegExp('^' + filter + '$'));
                }
            }

            //Filter all keys
            db.keys().then(function(keys) {
                    for (var i = 0; i < keys.length; i++) {

                        //Remove the logIndex first "index-REALKEY"
                        var index = parseInt(keys[i]);
                        var key = keys[i].substr(index.toString().length + 1);

                        if (enabled(key, skips, names)) {
                            db.getItem(keys[i]).then(function(log) {
                                    var index = parseInt(log);
                                    localLogs[index] = '[' + index + ']' + log.substr(index.toString().length) + "\r\n";
                                }).catch(function(err) {})
                        }
                    }
                }).catch(function(err) {});

        } else {
            var request = self.indexedDB.open(db.dbName);

            request.onsuccess = function (e) {
                var transaction = db.currentDB.transaction(db.storeName, 'readwrite');
                var store = transaction.objectStore(db.storeName);

                store.openCursor().onsuccess = function (event) {
                    var cursor = event.target.result;

                    if (cursor) {
                        var string =  JSON.stringify(cursor.value);
                        var cseqNumber  = cursor.value.cseqNumber;
                        localLogs[cseqNumber] = '[' + cseqNumber + ']' + string + "\r\n";
                        cursor.continue();
                    } else {
                        callback(localLogs);
                    }
                };
            }
        }
    }

    /**
     * Get all Database name list
     * @api public
     */

    function getLocalDBName(callback) {
        var localDBs = [];
        var request = self.indexedDB.open(createDebug.dataBaseListDB.dbName);

        request.onsuccess = function (e) {
            var dbName = createDebug.dataBaseListDB.storeName;
            var transaction = createDebug.dataBaseListDB.currentDB.transaction(dbName, 'readwrite');
            var objectStore = transaction.objectStore(dbName);
            objectStore.openCursor().onsuccess = function (event) {
                var cursor = event.target.result;
                if (cursor) {
                    localDBs.push(cursor.value);
                    cursor.continue();
                } else {
                    console.log('no more data!');
                    callback(localDBs);
                }
            };
            objectStore.openCursor().onerror = function (error) {
                console.error(error)
            }
        }.bind(this);

        request.onerror = function (e) {
            console.log(e.currentTarget.error.message);
        }.bind(this);
    }

    /**
     * Update the sipID and confSEQ in dbInformation in database
     * "DatabaseList" .
     * info should be { sipID: XXX, confSEQ: xxx, userName: aaa,
     * email: bbb }
     *
     */
    function updateConfInfo(confInfo) {
        try {
            var store = createDebug.dataBaseListDB.getStoreByName(createDebug.sessionStorage.dbName);
            var index = store.index("dbName");
            var request = index.get(createDebug.sessionStorage.dbName);
            var infoJson;

            request.onsuccess = function( e) {
                if ( request.result) {
                    if (request.result != null && request.result !== "[object Object]") { //Todo: figure out why info is [object Object], when dbName is not exisit.
                        infoJson = request.result;
                        infoJson.data.confID = createDebug.sessionStorage.confID;
                    } else {
                        infoJson = {
                            TS: [ (new Date()).getTime() ],
                            dbName: createDebug.sessionStorage.dbName,
                            data: {
                                confID: createDebug.sessionStorage.confID,
                                userName: self.localStorage.userName,
                                email: self.localStorage.email
                            }
                        };
                    }

                    if (confInfo.sipID) {
                        if (!infoJson.sipID) {
                            infoJson.data.sipID = [ ];
                        }
                        infoJson.data.sipID.push(confInfo.sipID);
                    }

                    if (confInfo.confSEQ) {
                        if (!infoJson.data.confSEQ) {
                            infoJson.data.confSEQ = [ ];
                        }
                        infoJson.data.confSEQ.push(confInfo.confSEQ);
                    }

                    if (confInfo.userName) {
                        infoJson.data.userName = confInfo.userName;
                    }

                    if (confInfo.email) {
                        infoJson.data.email = confInfo.email;
                    }

                    if (confInfo.confTitle) {
                        infoJson.data.confTitle = confInfo.confTitle;
                    }

                    createDebug.dataBaseListDB.update(infoJson);
                    createDebug.createdDBList = true;
                }
            };
        } catch (e) {}
    }
    createDebug.updateConfInfo = updateConfInfo;

    /**
     * Flush buffer into DB
     *将缓冲区刷新到database里
     */
    function flushLogBuffer() {
        try {
            if (createDebug.logBuffer.length > 0) {
                createDebug.logBuffer.push( createDebug.logBuffer);
                createDebug.logBuffer = [ ];
            }

        } catch (e) {}
    }
    createDebug.flushLogBuffer = flushLogBuffer;

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }

    /**
     * Export the local log
     * 导出日志文件
     * @api public
     */

    function exportLog() {

        var fileName = 'meetingLog.txt';

        debug.getLocalLogs(null, "*",
           function(logs) {
               if ( navigator.userAgent.match('(rv:11.0|Edge)') ) {
                   /*IE 11 or Edge*/

                   var log_file;
                   try {
                       log_file = new Blob(logs, { type: 'text/plain' });
                   } catch (e) {
                       // Old browser, need to use blob builder
                       self.BlobBuilder = self.BlobBuilder || self.MSBlobBuilder;
                       if (self.BlobBuilder) {
                           var tmp = new BlobBuilder('text/plain');
                           tmp.append(logs);
                           log_file = tmp.getBlob();
                       }

                   }

                   if (self.navigator && self.navigator.msSaveBlob) {
                       self.navigator.msSaveBlob(log_file, fileName);
                   }

                   delete log_file;

               } else {

                   var log_file = new Blob(logs, { type: 'text/plain' });
                   var b = document.createElement('a');
                   var ev = document.createEvent('MouseEvents');
                   ev.initEvent("click", false, false);
                   b.href = URL.createObjectURL(log_file);
                   b.download = fileName;
                   b.dispatchEvent(ev)

                   delete b;
                   delete log_file;
               }
           });
    }

    createDebug.enable(createDebug.load());

    createDebug.localLogState = createDebug.loadLocalLogState() !== "false" ;

    return createDebug;
}

},{"sprintf-js":2}],4:[function(require,module,exports){
/**
 * This is the web browser implementation of `debug()`.   这是`debug()`的Web浏览器实现。
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();
exports.log = log;
exports.saveLocalLogState = saveLocalLogState;
exports.loadLocalLogState = loadLocalLogState;
exports.sessionStorage = self.sessionStorage;
/*-------------------------------------------*/

exports.colors = [
    '#295288'
   //'#46A7C9'
    ];

/**
 * Background Colors
 */
exports.bgColors = [
  'inherit', //DEBUG
  'inherit', //LOG
  '#46A7C9', //INFO
  '#D08005;font-size:14px', //WARN
  '#F64863;font-size:16px', //ERROR
  '#F64863;font-size:18px'  //FATAL
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && self.process && self.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/trident\/(\d+)/)) {
      return false;
  }

  // Rzhang: Edge supports colors since 16215
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/edge\/(\d+)/)
      && (parseInt(navigator.userAgent.toLowerCase().match(/edge\/\d+.(\d+)/)[1]) < 16215)) {
      return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && self.console && (self.console.firebug || (self.console.exception && self.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ');
    //+ '+' + module.exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: ' + this.bgColor)

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  if (this.bgColor !== debug.bgColors[4]) {
    return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
  } else {
    return 'object' === typeof console
           && console.error
           && Function.prototype.apply.call(console.error, console, arguments);

  }
}

/**
 * Save `namespaces`.
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  //if (!r && typeof process !== 'undefined' && 'env' in process) {
  //  r = process.env.DEBUG;
  //}

  if ( !r ) {
      //Set default namespaces
      r = '*:INFO,*:WARN,*:ERROR';
  }

  return r;
}

/**
 * Save LocalLog enable state.
 * @param {Bool} state
 * @api private
 */
function saveLocalLogState(state) {
  try {
    if (null == state || state != false) {
      exports.storage.setItem('localLog', true);
    } else {
      exports.storage.setItem('localLog', false);
    }
  } catch (e) {
  }
}

/**
 * Load `localLog` setting.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function loadLocalLogState() {
  var r = true;
  try {
      r = exports.storage.localLog;
  } catch (e) {
  }

  // If debug isn't set in LS
  if (!r ) {
    r = true;
  }

  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return self.localStorage;
  } catch (e) {}
}

module.exports = require('./common')(exports);

var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

},{"./common":3}]},{},[4])(4)
});
/***
 * Function that get the version of each browser that uses replaceTrack
 * @returns
 */
function isReplaceTrackSupport() {
    var version = adapter.browserDetails.version
    var result = false

    switch (adapter.browserDetails.browser) {
        case 'chrome':
            result = version >= 72
            break
        case 'opera':
            result = version >= 59
            break
        case 'firefox':
            result = version >= 59
            break
        case 'safari':
            version = adapter.browserDetails.UIVersion
            result = version >= '12.1.1'
            break
        default:
            break
    }
    return result
}

function closeStream(stream) {
    if(!stream){
        return
    }
    try {
        var tracks = stream.getTracks();
        for (var track in tracks) {
            tracks[track].onended = null;
            log.info("close stream");
            tracks[track].stop();
        }
    }
    catch (error) {
        log.info('closeStream: Failed to close stream');
        log.error(error);
    }
}

/***
 * JS 数据类型判断
 * @param data
 * @returns {string}
 */
function typeJudgement(data) {
    let type = Object.prototype.toString.call(data)
    let endIndex = type.indexOf(']')
    let result = type.substring(8, endIndex).toLocaleLowerCase()
    console.log("current match case: ", result)
    return result
}

/***
 * 判断字符串是否为Json
 * @param str
 * @returns {boolean}
 */
function isJsonString(str) {
    try {
        if (typeof JSON.parse(str) == "object") {
            return true;
        }
    } catch(e) {
    }
    return false;
}

/***
 * 页面内内容输出
 * @param message
 */
function writeToScreen(message) {
    let parent = document.getElementById('output');
    let newChild = document.createElement("div");
    newChild.innerHTML = message;
    parent.appendChild(newChild);
}

/***
 * 当前时间格式化处理
 */
function formatDate(now) {
    let year = now.getFullYear();
    let month = now.getMonth() + 1;
    let date = now.getDate();
    let hour = now.getHours();
    let minute = now.getMinutes();
    let second = now.getSeconds();
    return year + "-" + (month = month < 10 ? ("0" + month) : month) + "-" + (date = date < 10 ? ("0" + date) : date) + " " + (hour = hour < 10 ? ("0" + hour) : hour) + ":" + (minute = minute < 10 ? ("0" + minute) : minute) + ":" + (second = second < 10 ? ("0" + second) : second);
}
const grammar = {
    v: [ {
        name: 'version',
        reg: /^(\d*)$/
    } ],
    o: [ {
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: 'origin',
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: [ 'username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address' ],
        format: '%s %s %d %s IP%d %s'
    } ],
    // default parsing of these only (though some of these feel outdated)
    s: [ { name: 'name' } ],
    i: [ { name: 'description' } ],
    u: [ { name: 'uri' } ],
    e: [ { name: 'email' } ],
    p: [ { name: 'phone' } ],
    z: [ { name: 'timezones' } ], // TODO: this one can actually be parsed properly...
    r: [ { name: 'repeats' } ],   // TODO: this one can also be parsed properly
    // k: [{}], // outdated thing ignored
    t: [ {
        // t=0 0
        name: 'timing',
        reg: /^(\d*) (\d*)/,
        names: [ 'start', 'stop' ],
        format: '%d %d'
    } ],
    c: [ {
        // c=IN IP4 10.47.197.26
        name: 'connection',
        reg: /^IN IP(\d) (\S*)/,
        names: [ 'version', 'ip' ],
        format: 'IN IP%d %s'
    } ],
    b: [ {
        // b=AS:4000
        push: 'bandwidth',
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: [ 'type', 'limit' ],
        format: '%s:%s'
    } ],
    m: [ {
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: [ 'type', 'port', 'protocol', 'payloads' ],
        format: '%s %d %s %s'
    } ],
    a: [
    {
        // a=rtpmap:110 opus/48000/2
        push: 'rtp',
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: [ 'payload', 'codec', 'rate', 'encoding' ],
        format: function(o) {
            return (o.encoding)
                   ? 'rtpmap:%d %s/%s/%s'
                   : o.rate
                   ? 'rtpmap:%d %s/%s'
                   : 'rtpmap:%d %s';
        }
    },
    {
        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
        // a=fmtp:111 minptime=10; useinbandfec=1
        push: 'fmtp',
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: [ 'payload', 'config' ],
        format: 'fmtp:%d %s'
    },
    {
        // a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: 'control:%s'
    },
    {
        // a=rtcp:65179 IN IP4 193.84.77.194
        name: 'rtcp',
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: [ 'port', 'netType', 'ipVer', 'address' ],
        format: function(o) {
            return (o.address != null)
                   ? 'rtcp:%d %s IP%d %s'
                   : 'rtcp:%d';
        }
    },
    {
        // a=rtcp-fb:98 trr-int 100
        push: 'rtcpFbTrrInt',
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: [ 'payload', 'value' ],
        format: 'rtcp-fb:%d trr-int %d'
    },
    {
        // a=rtcp-fb:98 nack rpsi
        push: 'rtcpFb',
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: [ 'payload', 'type', 'subtype' ],
        format: function(o) {
            return (o.subtype != null)
                   ? 'rtcp-fb:%s %s %s'
                   : 'rtcp-fb:%s %s';
        }
    },
    {
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:1/recvonly URI-gps-string
        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
        push: 'ext',
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: [ 'value', 'direction', 'encrypt-uri', 'uri', 'config' ],
        format: function(o) {
            return (
                'extmap:%d' +
                (o.direction ? '/%s' : '%v') +
                (o['encrypt-uri'] ? ' %s' : '%v') +
                ' %s' +
                (o.config ? ' %s' : '')
                );
        }
    },
    {
        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
        push: 'crypto',
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: [ 'id', 'suite', 'config', 'sessionConfig' ],
        format: function(o) {
            return (o.sessionConfig != null)
                   ? 'crypto:%d %s %s %s'
                   : 'crypto:%d %s %s';
        }
    },
    {
        // a=setup:actpass
        name: 'setup',
        reg: /^setup:(\w*)/,
        format: 'setup:%s'
    },
    {
        // a=connection:new
        name: 'connectionType',
        reg: /^connection:(new|existing)/,
        format: 'connection:%s'
    },
    {
        // a=mid:1
        name: 'mid',
        reg: /^mid:([^\s]*)/,
        format: 'mid:%s'
    },
    {
        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
        name: 'msid',
        reg: /^msid:(\S*) (\S*)/,
        names: [ 'msid', 'trackid' ],
        format: 'msid:%s %s'
    },
    {
        // a=ptime:20
        name: 'ptime',
        reg: /^ptime:(\d*)/,
        format: 'ptime:%d'
    },
    {
        // a=maxptime:60
        name: 'maxptime',
        reg: /^maxptime:(\d*)/,
        format: 'maxptime:%d'
    },
    {
        // a=sendrecv
        name: 'direction',
        reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
        // a=ice-lite
        name: 'icelite',
        reg: /^(ice-lite)/
    },
    {
        // a=ice-ufrag:F7gI
        name: 'iceUfrag',
        reg: /^ice-ufrag:(\S*)/,
        format: 'ice-ufrag:%s'
    },
    {
        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
        name: 'icePwd',
        reg: /^ice-pwd:(\S*)/,
        format: 'ice-pwd:%s'
    },
    {
        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
        name: 'fingerprint',
        reg: /^fingerprint:(\S*) (\S*)/,
        names: [ 'type', 'hash' ],
        format: 'fingerprint:%s %s'
    },
    {
        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
        push: 'candidates',
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: [ 'foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost' ],
        format: function(o) {
            var str = 'candidate:%s %d %s %d %s %d typ %s';

            str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

            // NB: candidate has three optional chunks, so %void middles one if it's missing
            str += (o.tcptype != null) ? ' tcptype %s' : '%v';

            if ( o.generation != null ) {
                str += ' generation %d';
            }

            str += (o['network-id'] != null) ? ' network-id %d' : '%v';
            str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
            return str;
        }
    },
    {
        // a=end-of-candidates (keep after the candidates line for readability)
        name: 'endOfCandidates',
        reg: /^(end-of-candidates)/
    },
    {
        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
        name: 'remoteCandidates',
        reg: /^remote-candidates:(.*)/,
        format: 'remote-candidates:%s'
    },
    {
        // a=ice-options:google-ice
        name: 'iceOptions',
        reg: /^ice-options:(\S*)/,
        format: 'ice-options:%s'
    },
    {
        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
        push: 'ssrcs',
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: [ 'id', 'attribute', 'value' ],
        format: function(o) {
            var str = 'ssrc:%d';
            if ( o.attribute != null ) {
                str += ' %s';
                if ( o.value != null ) {
                    str += ':%s';
                }
            }
            return str;
        }
    },
    {
        // a=ssrc-group:FEC 1 2
        // a=ssrc-group:FEC-FR 3004364195 1080772241
        push: 'ssrcGroups',
        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: [ 'semantics', 'ssrcs' ],
        format: 'ssrc-group:%s %s'
    },
    {
        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
        push: 'msidSemantics', /*Modified by rzhang, for merge/split SDP*/
        //name: 'msidSemantic',
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: [ 'semantic', 'token' ],
        format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
        // a=group:BUNDLE audio video
        push: 'groups',
        reg: /^group:(\w*) (.*)/,
        names: [ 'type', 'mids' ],
        format: 'group:%s %s'
    },
    {
        // a=rtcp-mux
        name: 'rtcpMux',
        reg: /^(rtcp-mux)/
    },
    {
        // a=rtcp-rsize
        name: 'rtcpRsize',
        reg: /^(rtcp-rsize)/
    },
    {
        // a=sctpmap:5000 webrtc-datachannel 1024
        name: 'sctpmap',
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: [ 'sctpmapNumber', 'app', 'maxMessageSize' ],
        format: function(o) {
            return (o.maxMessageSize != null)
                   ? 'sctpmap:%s %s %s'
                   : 'sctpmap:%s %s';
        }
    },
    {
        // a=x-google-flag:conference
        name: 'xGoogleFlag',
        reg: /^x-google-flag:([^\s]*)/,
        format: 'x-google-flag:%s'
    },
    {
        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
        push: 'rids',
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: [ 'id', 'direction', 'params' ],
        format: function(o) {
            return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
        }
    },
    {
        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
        // a=imageattr:* send [x=800,y=640] recv *
        // a=imageattr:100 recv [x=320,y=240]
        push: 'imageattrs',
        reg: new RegExp(
            // a=imageattr:97
            '^imageattr:(\\d+|\\*)' +
            // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
            '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
            // recv [x=330,y=250]
            '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
            ),
        names: [ 'pt', 'dir1', 'attrs1', 'dir2', 'attrs2' ],
        format: function(o) {
            return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
        }
    },
    {
        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
        // a=simulcast:recv 1;4,5 send 6;7
        name: 'simulcast',
        reg: new RegExp(
            // a=simulcast:
            '^simulcast:' +
            // send 1,2,3;~4,~5
            '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
            // space + recv 6;~7,~8
            '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
            // end
            '$'
            ),
        names: [ 'dir1', 'list1', 'dir2', 'list2' ],
        format: function(o) {
            return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
        }
    },
    {
        // old simulcast draft 03 (implemented by Firefox)
        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
        // a=simulcast: recv pt=97;98 send pt=97
        // a=simulcast: send rid=5;6;7 paused=6,7
        name: 'simulcast_03',
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: [ 'value' ],
        format: 'simulcast: %s'
    },
    {
        // a=framerate:25
        // a=framerate:29.97
        name: 'framerate',
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: 'framerate:%s'
    },
    {
        // RFC4570
        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
        name: 'sourceFilter',
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: [ 'filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList' ],
        format: 'source-filter: %s %s %s %s %s'
    },
    {
        // a=bundle-only
        name: 'bundleOnly',
        reg: /^(bundle-only)/
    },
    {
        // a=label:1
        name: 'label',
        reg: /^label:(.+)/,
        format: 'label:%s'
    },
    {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
        name: 'sctpPort',
        reg: /^sctp-port:(\d+)$/,
        format: 'sctp-port:%s'
    },
    {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
        name: 'maxMessageSize',
        reg: /^max-message-size:(\d+)$/,
        format: 'max-message-size:%s'
    },
    {
        // a=keywds:keywords
        name: 'keywords',
        reg: /^keywds:(.+)$/,
        format: 'keywds:%s'
    },
    {
        // RFC4796 The Content Attribute
        // a=content:slides,main,sl,speaker
        name: 'content',
        reg: /^content:(.+)$/,
        format: 'content:%s'
    },
    {
        // any a= that we don't understand is kept verbatim on media.invalid
        push: 'invalid',
        names: [ 'value' ]
    }
        ]
};
// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function(key) {
        var objs = grammar[key];
        objs.forEach(function(obj) {
                if ( !obj.reg ) {
                    obj.reg = /(.*)/;
                }
                if ( !obj.format ) {
                    obj.format = '%s';
                }
            });
    });

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function(formatStr) {
    var i = 1;
    var args = arguments;
    var len = args.length;
    return formatStr.replace(formatRegExp, function(x) {
            if ( i >= len ) {
                return x; // missing argument
            }
            var arg = args[i];
            i += 1;
            switch ( x ) {
                case '%%':
                    return '%';
                case '%s':
                    return String(arg);
                case '%d':
                    return Number(arg);
                case '%v':
                    return '';
            }
        });
    // NB: we discard excess arguments - they are typically undefined from makeLine
};

function getType(obj) {
    if ( Object.prototype.toString.call(obj) == '[object Object]' ) {
        return 'Object';
    } else if ( Object.prototype.toString.call(obj) == '[object Array]' ) {
        return 'Array';
    } else {
        return 'nomal';
    }
}

function deepCopy(obj) {
    if ( getType(obj) == 'nomal' ) {
        return obj;
    } else {
        var newObj = getType(obj) == 'Object' ? { }
            : [ ];
        for ( var key in obj ) {
            if ( obj.hasOwnProperty(key) ) {
                newObj[key] = deepCopy(obj[key]);
            }
        }
    }
    return newObj;
}

var makeLine = function(type, obj, location) {
    var str = obj.format instanceof Function ?
              (obj.format(obj.push ? location : location[obj.name])) :
              obj.format;

    var args = [ type + '=' + str ];
    if ( obj.names ) {
        for ( var i = 0; i < obj.names.length; i += 1 ) {
            var n = obj.names[i];
            if ( obj.name ) {
                args.push(location[obj.name][n]);
            } else { // for mLine and push attributes
                args.push(location[obj.names[i]]);
            }
        }
    } else {
        args.push(location[obj.name]);
    }
    return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
                        'v', 'o', 's', 'i',
                        'u', 'e', 'p', 'c',
                        'b', 't', 'r', 'z', 'a'
                        ];
var defaultInnerOrder = [ 'i', 'c', 'b', 'a' ];


var toIntIfInt = function(v) {
    return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function(match, location, names, rawName) {
    if ( rawName && !names ) {
        location[rawName] = toIntIfInt(match[1]);
    } else {
        for ( var i = 0; i < names.length; i += 1 ) {
            if ( match[i + 1] != null ) {
                location[names[i]] = toIntIfInt(match[i + 1]);
            }
        }
    }
};

var parseReg = function(obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if ( obj.push && !location[obj.push] ) {
        location[obj.push] = [ ];
    } else if ( needsBlank && !location[obj.name] ) {
        location[obj.name] = { };
    }
    var keyLocation = obj.push ?
    { }
        :  // blank object that will be pushed
        needsBlank ? location[obj.name] : location; // otherwise, named location or root

    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

    if ( obj.push ) {
        location[obj.push].push(keyLocation);
    }
};

var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

var paramReducer = function(acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if ( s.length === 2 ) {
        acc[s[0]] = toIntIfInt(s[1]);
    } else if ( s.length === 1 && expr.length > 1 ) {
        acc[s[0]] = undefined;
    }
    return acc;
};

var SDPTools = {

    midMap: new Array(), /*Save SDP mid mapping: msid:xxx(The original msid), mid:xx(The original mid), mappedMID:XX(The mapped mid)*/
    msidMap: new Array(), /*Save SDP msid mapping: msid:xxx(The original msid), pcName:XXX(The mapped msid) */
    sessionVersion: 0, /*SDP o line session version*/

    writeSDP: function(session, opts) {
        opts = opts || { };
        // ensure certain properties exist
        if ( session.version == null ) {
            session.version = 0; // 'v=0' must be there (only defined version atm)
        }
        if ( session.name == null ) {
            session.name = ' '; // 's= ' must be there if no meaningful name set
        }
        session.media.forEach(function(mLine) {
                if ( mLine.payloads == null ) {
                    mLine.payloads = '';
                }
            });

        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [ ];

        // loop through outerOrder for matching properties on session
        outerOrder.forEach(function(type) {
                grammar[type].forEach(function(obj) {
                        if ( obj.name in session && session[obj.name] != null ) {
                            sdp.push(makeLine(type, obj, session));
                        } else if ( obj.push in session && session[obj.push] != null ) {
                            session[obj.push].forEach(function(el) {
                                    sdp.push(makeLine(type, obj, el));
                                });
                        }
                    });
            });

        // then for each media line, follow the innerOrder
        session.media.forEach(function(mLine) {
                sdp.push(makeLine('m', grammar.m[0], mLine));

                innerOrder.forEach(function(type) {
                        grammar[type].forEach(function(obj) {
                                if ( obj.name in mLine && mLine[obj.name] != null ) {
                                    sdp.push(makeLine(type, obj, mLine));
                                } else if ( obj.push in mLine && mLine[obj.push] != null ) {
                                    mLine[obj.push].forEach(function(el) {
                                            sdp.push(makeLine(type, obj, el));
                                        });
                                }
                            });
                    });
            });

        return sdp.join('\r\n') + '\r\n';
    },

    parseSDP: function(sdp) {
        var session = { }, media = [ ]
        , location = session; // points at where properties go under (one of the above)

        // parse lines we understand
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
                var type = l[0];
                var content = l.slice(2);
                if ( type === 'm' ) {
                    media.push({ rtp: [ ], fmtp: [ ] });
                    location = media[media.length - 1]; // point at latest media line
                }

                for ( var j = 0; j < (grammar[type] || [ ]).length; j += 1 ) {
                    var obj = grammar[type][j];
                    if ( obj.reg.test(content) ) {
                        return parseReg(obj, location, content);
                    }
                }
            });

        session.media = media; // link it up
        if ( this.sessionVersion <= 0 ) {
            this.sessionVersion = session['origin']['sessionVersion'];
        }
        return session;
    },

    parseFmtpConfig: function(str) {
        return str.split(/;\s?/).reduce(paramReducer, { });
    },

    parsePayloads: function(str) {
        return str.toString().split(' ').map(Number);
    },

    parseRemoteCandidates: function(str) {
        var candidates = [ ];
        var parts = str.split(' ').map(toIntIfInt);
        for ( var i = 0; i < parts.length; i += 3 ) {
            candidates.push({
                component: parts[i],
                ip: parts[i + 1],
                port: parts[i + 2]
            });
        }
        return candidates;
    },

    parseImageAttributes: function(str) {
        return str.split(' ').map(function(item) {
                return item.substring(1, item.length - 1).split(',').reduce(paramReducer, { });
            });
    },

    parseSimulcastStreamList: function(str) {
        return str.split(';').map(function(stream) {
                return stream.split(',').map(function(format) {
                        var scid, paused = false;

                        if ( format[0] !== '~' ) {
                            scid = toIntIfInt(format);
                        } else {
                            scid = toIntIfInt(format.substring(1, format.length));
                            paused = true;
                        }

                        return {
                            scid: scid,
                            paused: paused
                        };
                    });
            });
    },

    /*Set Media content type*/
    setMediaContentType: function(session, index, contentType) {
        if ( index < session.media.length ) {
            session.media[index]['content'] = contentType;
        } else {
            log.log("Error index");
        }
    },

    /*Process bandwidth relative: b line and x-google-start-bitrate*/
    setMediaBandwidth: function(session, index, bandwidth) {
    },

    /*Increase SDP Session version*/
    increaseSessionVersion: function(session) {
        if ( this.sessionVersion <= 0 ) {
            this.sessionVersion = session['origin']['sessionVersion'];
        }
        this.sessionVersion += 1;
        session['origin']['sessionVersion'] = this.sessionVersion;
    },

    /*payloads must be a array of NUMBERS*/
    removeCodecByPayload: function(session, index, payloads) {
        if ( index >= session.media.length ) {
            log.log("Error index");
            return;
        }

        var mediaSession = session.media[index];

        /*Check relative fmtp payload*/
        for ( var i = 0; i < payloads.length; i += 1 ) {
            for ( var j = 0; j < mediaSession.fmtp.length; j += 1 ) {

                if ( mediaSession.fmtp[j].config.match("apt=" + payloads[i]) != null ) {

                    if ( payloads.indexOf(mediaSession.fmtp[j].payload) === -1 ) {
                        /*Added relative payload which also need to be removed*/
                        payloads.push(mediaSession.fmtp[j].payload);
                    }
                }
            }
        }

        payloads.forEach(pt => {

            /*Process payloads*/
            if ( typeof(mediaSession.payloads) === 'string' ) {
                mediaSession.payloads = mediaSession.payloads.replace(pt, "");
            }

            if ( mediaSession.rtp != undefined ) {
                /*Process rtp*/
                for ( var i = 0; i < mediaSession.rtp.length;) {

                    if ( mediaSession.rtp[i].payload == pt ) {
                        mediaSession.rtp.splice(i, 1);
                        break;
                    } else {
                        i += 1;
                    }
                }
            }

            if ( mediaSession.fmtp != undefined ) {
                /*Process fmtp*/
                for ( var i = 0; i < mediaSession.fmtp.length;) {

                    if ( mediaSession.fmtp[i].payload == pt ) {
                        mediaSession.fmtp.splice(i, 1);
                        //break; maybe there more than one fmtp for some payload.
                    } else {
                        i += 1;
                    }
                }
            }

            if ( mediaSession.rtcpFb != undefined ) {
                /*Process rtcpFb*/
                for ( var i = 0; i < mediaSession.rtcpFb.length;) {

                    if ( mediaSession.rtcpFb[i].payload == pt ) {
                        mediaSession.rtcpFb.splice(i, 1);
                        //break; more than one rtcpFb for some payload.
                    } else {
                        i += 1;
                    }
                }
            }
        });

        /*Process payloads blanks*/
        if ( typeof(mediaSession.payloads) === 'string' ) {
            mediaSession.payloads = mediaSession.payloads.replace(/[ ]+/g, " ");
        }
    },

    /*payloads must be a array of STRING, case sensive*/
    removeCodecByName: function(session, index, names) {
        if ( index >= session.media.length ) {
            log.log("Error index");
            return;
        }

        var mediaSession = session.media[index];

        /*Get payloads by names*/
        var payloads = new Array();
        mediaSession.rtp.forEach(item => names.forEach(codec => {
            if ( item.codec === codec ) {
                payloads.push(item.payload);
            }
        }));

        this.removeCodecByPayload(session, index, payloads);
    },

    /*Merge SDP, SDPs must be a SDP STRING array*/
    mergeSDP: function(SDPs) {
        let mergedSDP;
        let mergedSession;
        let sessions = new Array();

        for ( let i = 0; i < SDPs.length; i += 1 ) {
            sessions[i] = this.parseSDP(SDPs[i]);
        }

        /***Process msid mapping***/
        //for ( let i = 0; i < SDPs.length; i += 1 ) {
        //    sessions[i].media.msid
        //}

        /***Process mid mapping***/
        let id = 0;
        for ( let i = 0; i < SDPs.length; i += 1 ) {
            for(let j = 0; j < sessions[i].media.length; j += 1 ){
                let item = { };
                item['msid'] = sessions[i].media[j].msid;
                item['mid']  = sessions[i].media[j].mid;
                item['mappedMID'] = id;
                this.midMap.push(item);

                /*Modified the group a line*/
                if ( typeof(sessions[i].groups[0].mids) === 'string' ) {
                    sessions[i].groups[0].mids = sessions[i].groups[0].mids.replace(sessions[i].media[j].mid, id);
                } else if ( typeof(sessions[i].groups[0].mids) === 'number' ) {
                    sessions[i].groups[0].mids = id;
                } else {
                    log.log("ERROR on Process mid mapping");
                }

                /*Modified the mid*/
                sessions[i].media[j].mid = id;

                id += 1;
            }
        }

        /***Merge session level part***/
        if ( sessions[0].groups === undefined ) {
            sessions[0].groups = new Array();
        }

        if ( sessions[0].msidSemantics === undefined ) {
            sessions[0].msidSemantics = new Array();
        }

        for ( let i = 0; i < SDPs.length; i += 1 ) {
            log.log("Session " + i + "th:\n" + sessions[i]);
            /*Process ssesion fingerprint a line*/
            if ( sessions[i].fingerprint !== undefined ) {
                sessions[i].media.forEach(
                    function(m) {
                        m['fingerprint'] = deepCopy(sessions[i].fingerprint);
                    });

                delete sessions[i].fingerprint;
            }

            /*Process copy all groups a line*/
            if ( sessions[i].groups !== undefined ) {
                if ( i > 0 ) {
                    sessions[i].groups.forEach(
                        function(g) {
                            sessions[0].groups.push(deepCopy(g));
                        });
                }
            }

            /*Process MSID a line*/
            if ( sessions[i].msidSemantics !== undefined ) {
                if ( i > 0 ) {
                    sessions[i].msidSemantics.forEach(
                        function(msid) {
                            sessions[0].msidSemantics.push(deepCopy(msid));
                        });
                }
            }


        }

        /***Merge media level part***/
        for ( let i = 0; i < SDPs.length; i += 1 ) {
            if ( sessions[i].media !== undefined ) {
                if ( i > 0 ) {
                    sessions[i].media.forEach(
                        function(m) {
                            sessions[0].media.push(deepCopy(m));
                        });
                }
            }
        }

        /***Process C line and port of M line, if has ICE candidate***/


        mergedSDP = this.writeSDP(sessions[0]);

        return mergedSDP;
    },

    /*Split SDP, return SDP STRING array*/
    splitSDP: function(SDP) {
        let sdpArray = new Array();
        let session = this.parseSDP(SDP);

        if ( session.groups === undefined ) {
            log.log("No GROUP information, need to split m lines to each pc");

            session.groups = new Array();
            this.midMap = new Array();
            for ( let i = 0; i < session.media.length; i += 1 ) {
                /*Make fake groups*/
                session.groups.push({ type: "BUNDLE", mids: session.media[i].mid });
                let item = { };
                item['msid'] = session.media[i].msid;
                item['mid'] = 0;
                item['mappedMID'] = session.media[i].mid;
                this.midMap.push(item);
            }
        }

        for ( let i = 0; i < session.groups.length; i += 1 ) {
            let sdp;
            let sess = deepCopy(session);

            sess.groups = new Array(sess.groups[i]);
            if ( sess.msidSemantics !== undefined ) {
                sess.msidSemantics = new Array(sess.msidSemantics[i]);
            } else {
                delete sess.msidSemantics;
            }
            let media = new Array();

            if ( typeof( sess.groups[0].mids ) === 'number' ) {
                for (let j = 0; j < sess.media.length; j +=1 ) {
                    if ( sess.media[j].mid === sess.groups[0].mids ) {
                        media.push(sess.media[j]);
                        break;
                    }
                }
            } else if ( typeof(sess.groups[0].mids) === 'string' ) {

                sess.groups[0].mids.split(' ').forEach( mid => {
                    for ( let j = 0; j < sess.media.length; j += 1 ) {
                        if ( sess.media[j].mid === mid ) {
                            media.push(sess.media[j]);
                            break;
                        }
                    }
                });
            }
            sess.media = media;

            /***Revert the mid mapping***/
            for (let k = 0; k < sess.media.length; k += 1) {
                for(let l = 0; l < this.midMap.length; l +=1 ){
                    if ( sess.media[k].mid === this.midMap[l].mappedMID ) {
                        sess.media[k].mid = this.midMap[l].mid;

                        if ( typeof(sess.groups[0].mids) === 'string' ) {
                            sess.groups[0].mids = sess.groups[0].mids.replace(sess.media[k].mid, this.midMap[l].mid);
                        } else if ( typeof(sess.groups[0].mids) === 'number' ) {
                            sess.groups[0].mids = this.midMap[l].mid;
                        } else {
                            log.log("ERROR on Process mid mapping");
                        }
                        break;
                    }
                }
            }

            /***Revert the msid mapping***/

            sdp = this.writeSDP(sess);
            sdpArray.push(sdp);
        }



        return sdpArray;
    }

};


/**
 * AMD, CommonJS, Global compatible Script Wrapper
 * https://github.com/umdjs/umd
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
        /* istanbul ignore next */
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.MediaDevice = factory();
    }
}(this, function () {


    function MediaDevice() {
        this.deviceCheckTimer = null
    }

    /***
     * 获取分辨率扫描列表
     */
    MediaDevice.prototype.getQuickScanList = function () {
        return [
            {
                "label": "4K(UHD)",
                "width": 3840,
                "height": 2160,
                "ratio": "16:9",
                "frameRate": 30
            },
            {
                "label": "4K(UHD)",
                "width": 3840,
                "height": 2160,
                "ratio": "16:9",
                "frameRate": 15
            },
            {
                "label": "1080p(FHD)",
                "width": 1920,
                "height": 1080,
                "ratio": "16:9",
                "frameRate": 30
            },
            {
                "label": "1080p(FHD)",
                "width": 1920,
                "height": 1080,
                "ratio": "16:9",
                "frameRate": 15
            },
            {
                "label": "UXGA",
                "width": 1600,
                "height": 1200,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "UXGA",
                "width": 1600,
                "height": 1200,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "720p(HD)",
                "width": 1280,
                "height": 720,
                "ratio": "16:9",
                "frameRate": 30
            },
            {
                "label": "720p(HD)",
                "width": 1280,
                "height": 720,
                "ratio": "16:9",
                "frameRate": 15
            },
            {
                "label": "SVGA",
                "width": 800,
                "height": 600,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "SVGA",
                "width": 800,
                "height": 600,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "VGA",
                "width": 640,
                "height": 480,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "VGA",
                "width": 640,
                "height": 480,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "360p(nHD)",
                "width": 640,
                "height": 360,
                "ratio": "16:9",
                "frameRate": 30
            },
            {
                "label": "360p(nHD)",
                "width": 640,
                "height": 360,
                "ratio": "16:9",
                "frameRate": 15
            },
            {
                "label": "CIF",
                "width": 352,
                "height": 288,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "CIF",
                "width": 352,
                "height": 288,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "QVGA",
                "width": 320,
                "height": 240,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "QVGA",
                "width": 320,
                "height": 240,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "180p?",
                "width": 320,
                "height": 180,
                "ratio": "16:9",
                "frameRate": 30
            },
            {
                "label": "180p?",
                "width": 320,
                "height": 180,
                "ratio": "16:9",
                "frameRate": 15
            },
            {
                "label": "QCIF",
                "width": 176,
                "height": 144,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "QCIF",
                "width": 176,
                "height": 144,
                "ratio": "4:3",
                "frameRate": 15
            },
            {
                "label": "QQVGA",
                "width": 160,
                "height": 120,
                "ratio": "4:3",
                "frameRate": 30
            },
            {
                "label": "QQVGA",
                "width": 160,
                "height": 120,
                "ratio": "4:3",
                "frameRate": 15
            }
        ];
    }

    /***
     * 获取音视频设备并进行分类
     * @param deviceInfoCallback
     * @param error
     */
    MediaDevice.prototype.enumDevices = function (deviceInfoCallback, error) {
        if (navigator.mediaDevices === undefined || navigator.mediaDevices.enumerateDevices === undefined) {
            if (error) {
                error("browser don't support enumerate devices")
            }
            return
        }
        navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {
            var microphone = []
            var speaker = []
            var camera = []
            var screenResolution = []
            var isConstraintsKeywordSupport = true
            for (var i = 0; i < deviceInfos.length; i++) {
                var deviceInfo = deviceInfos[i]
                if(deviceInfo.deviceId === 'default' || deviceInfo.deviceId === 'communications'){
                    continue
                }
                if (deviceInfo.kind === 'audioinput') {
                    microphone.push({
                        label: deviceInfo.label,
                        deviceId: deviceInfo.deviceId,
                        groupId: deviceInfo.groupId,
                        status: 'available',
                    })
                }
                if (deviceInfo.kind === 'audiooutput') {
                    speaker.push({
                        label: deviceInfo.label,
                        deviceId: deviceInfo.deviceId,
                        groupId: deviceInfo.groupId,
                        status: 'available',
                    })
                }
                if (deviceInfo.kind === 'videoinput') {
                    camera.push({
                        label: deviceInfo.label,
                        deviceId: deviceInfo.deviceId,
                        groupId: deviceInfo.groupId,
                        status: 'available',
                        capability: []
                    })
                }
            }

            screenResolution.push({
                width: window.screen.width,
                height: window.screen.height,
            })

            if (deviceInfoCallback) {
                deviceInfoCallback({
                    microphones: microphone,
                    speakers: speaker,
                    cameras: camera,
                    screenResolution: screenResolution,
                    isConstraintsKeywordSupport: isConstraintsKeywordSupport
                })
            } else {
                return {
                    microphones: microphone,
                    speakers: speaker,
                    cameras: camera,
                    screenResolution: screenResolution,
                    isConstraintsKeywordSupport: isConstraintsKeywordSupport
                }
            }
        }).catch(function (err) {
            if (error) {
                error(err)
            }
        })
    }

    /***
     * 更新localStorage存储
     * @param deviceInfos 所有的媒体数据
     * @param type ： cameras / microphones / speakers， 更新的类型
     */
    MediaDevice.prototype.updateDeviceInfo = function (deviceInfos, type) {
        var localStorageDeviceInfo = JSON.parse(localStorage.getItem('mediaDevice'))
        var deviceInfoList = []
        var storageInfoList = []

        switch (type) {
            case 'cameras':
                deviceInfoList = deviceInfos.cameras
                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.cameras ? localStorageDeviceInfo.cameras : [] : []
                break
            case 'microphones':
                deviceInfoList = deviceInfos.microphones
                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.microphones ? localStorageDeviceInfo.microphones : [] : []
                break
            case 'speakers':
                deviceInfoList = deviceInfos.speakers
                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.speakers ? localStorageDeviceInfo.speakers : [] : []
                break
            default:
                break
        }

        /***
         * 判断localStorage中的设备是否有还存在，不存在则设置状态为 unavailable，还存在的置为available
         * @param deviceInfoList
         * @param storageInfoList
         */
        function setDeviceStatus(deviceInfoList, storageInfoList) {
            for (var i = 0; i < storageInfoList.length; i++) {
                for (var j = 0; j < deviceInfoList.length; j++) {
                    if (storageInfoList[i].label === deviceInfoList[j].label) {
                        if (storageInfoList[i].status === 'unavailable') {
                            log.log('set device unavailable to available!')
                            storageInfoList[i].status = 'available'
                        }
                        storageInfoList[i].deviceId = deviceInfoList[j].deviceId
                        storageInfoList[i].groupId = deviceInfoList[j].groupId
                        break
                    }
                    if (storageInfoList[i].label !== deviceInfoList[j].label && j === deviceInfoList.length - 1 && storageInfoList[i].status !== 'unavailable') {
                        log.warn(storageInfoList[i].label + "   device is unavailable")
                        storageInfoList[i].status = 'unavailable'
                    }
                }
            }
        }

        /***
         * 判断设备是否是新设备，是的话，添加到localStorage中
         * @param deviceInfoList
         * @param storageInfoList
         */
        function addInsertDevice(deviceInfoList, storageInfoList) {
            for (var i = 0; i < deviceInfoList.length; i++) {
                for (var j = 0; j < storageInfoList.length; j++) {
                    if (deviceInfoList[i].label === storageInfoList[j].label) {
                        storageInfoList[j].deviceId = deviceInfoList[i].deviceId
                        storageInfoList[j].groupId = deviceInfoList[i].groupId
                        break
                    }
                    if (deviceInfoList[i].label !== storageInfoList[j].label && j === storageInfoList.length - 1) {
                        log.warn("new device has been insert!")
                        storageInfoList.push(deviceInfoList[i])
                    }
                }
            }
        }

        // 本地存储没有任何值，直接设置获取的设备列表到localStorage中
        if (deviceInfoList.length && !storageInfoList.length) {
            log.warn("set new device info list")
            localStorage.setItem('mediaDevice', JSON.stringify(deviceInfos, null, '    '))
            return
        }

        // 未获取当任何有效的设备列表，localStorage保存的设备全部设置为不可用
        if (!deviceInfoList.length && storageInfoList.length) {
            log.warn('set all device to unavailable');
            for (var i = 0; i < storageInfoList.length; i++) {
                storageInfoList[i].status = 'unavailable'
            }
            localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))
            return
        }

        // 获取到设备列表，且localStorage中有设备存储信息
        setDeviceStatus(deviceInfoList, storageInfoList)
        addInsertDevice(deviceInfoList, storageInfoList)
        log.log('update modified device info into localStorage!')
        localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))
    }

    /***
     * 清除流
     * @param stream
     */
    MediaDevice.prototype.closeStream = function (stream) {
        try {
            var tracks = stream.getTracks();
            for (var track in tracks) {
                tracks[track].onended = null;
                log.log("close stream");
                tracks[track].stop();
            }
        } catch (e) {
            log.error(e)
        }
    }

    /***
     * 判断取流是否支持关键字：min/max/exact/ideal
     * 常见：测试一体机不支持关键字
     * @returns {Promise<boolean>}
     */
    MediaDevice.prototype.isConstraintsKeywordSupport = async function () {
        var This = this
        var result = true
        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        var isKeywordSupport = mediaDevice ? mediaDevice.isConstraintsKeywordSupport : null

        if (isKeywordSupport !== null) {
            result = isKeywordSupport
        } else {
            var constraints = {
                audio: false,
                video: {
                    width: {ideal: 640},
                    height: {ideal: 360}
                }
            }

            function onGetUserMediaSuccess(stream){
                log.log('constraints keyWords support')
                result = true
                This.closeStream(stream)
            }

            function onGetUserMediaFailed(error){
                console.error(error)
                log.log('ideal is not support' + error.message)
                result = false
            }

            log.log("isConstraintsKeywordSupport test constraints: \n" + JSON.stringify(constraints, null, '    '));
            try {
                var stream = await navigator.mediaDevices.getUserMedia(constraints)
                onGetUserMediaSuccess(stream)
            }catch(error){
                onGetUserMediaFailed(error)
            }
        }

        log.info('is constraints Keyword support: ', result)
        return result
    }

    /***
     * 使用exact关键字取流
     * @returns {Promise<void>}
     */
    MediaDevice.prototype.getStreamWithExactConstraints = async function () {
        var This = this
        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        var quickScanList = This.getQuickScanList()
        var localStream
        var constraints

        function onGetUserMediaSuccess(stream) {
            // log.info('applyConstraints success' + JSON.stringify(constraints, null, '    '))
            log.info("get Stream Success : " + quickScanList[i].width + " x " + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);
            if(stream){
                localStream = stream
            }

            capability.push({
                width: quickScanList[i].width,
                height: quickScanList[i].height,
                frameRate: quickScanList[i].frameRate,
                aspectRatio: quickScanList[i].ratio
            })

            if (j === mediaDevice.cameras.length - 1 && i === quickScanList.length - 1) {
                log.log("Resolution scan completed, clear stream.")
                This.closeStream(localStream)
            }
        }

        function onGetUserMediaFailed(error) {
            if (error.name === 'ConstraintNotSatisfiedError') {
                log.info('The resolution ' + quickScanList[i].width + 'x' +
                  quickScanList[i].height + ' px and frameRate with ' +  quickScanList[i].frameRate + ' is not supported by your device.');
            } else if (error.name === 'PermissionDeniedError') {
                log.info('Permissions have not been granted to use your camera and ' +
                  'microphone, you need to allow the page access to your devices in ' +
                  'order for the demo to work.');
            }
            // log.error('getUserMedia error: ' + error.name, error);
            log.info("fail: mismatch : " + quickScanList[i].width + " x " + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);
        }

        for (var j = 0; j < mediaDevice.cameras.length; j++) {
            // 换摄像头时需要重新取流，避免使用applyConstraints时不换摄像头的场景
            if (localStream) {
                This.closeStream(localStream)
            }
            // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描
            if (mediaDevice.cameras[j].capability && mediaDevice.cameras[j].capability.length > 0) {
                log.warn("this device has already get resolution before: " + mediaDevice.cameras[j].label)
                continue
            }

            log.warn("Current scan device：", mediaDevice.cameras[j].label)
            var deviceId = mediaDevice.cameras[j].deviceId
            var capability = mediaDevice.cameras[j].capability


            // 存在问题：不使用关键字时，applyConstraints和getUserMedia取流都存在不准确问题，比如1920*1080，摄像头不支持该分辨率也能取流成功，因为取的是别的分辨率
            for (var i = 0; i < quickScanList.length; i++) {
                var videoTrack = localStream ? localStream.getVideoTracks()[0] : null
                if (localStream && localStream.active === true && localStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {
                    constraints = {
                        frameRate: {exact: quickScanList[i].frameRate},
                        aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},
                        width: {exact: quickScanList[i].width},
                        height: {exact: quickScanList[i].height}
                    }
                    try {
                        await videoTrack.applyConstraints(constraints)
                        onGetUserMediaSuccess()
                    }catch (error) {
                        onGetUserMediaFailed(error)
                    }
                } else {
                    constraints = {
                        audio: false,
                        video: {
                            frameRate: {exact: quickScanList[i].frameRate},
                            aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},
                            width: {
                                max: quickScanList[i].width,
                                exact: quickScanList[i].width
                            },
                            height: {
                                max: quickScanList[i].height,
                                exact: quickScanList[i].height
                            },
                        }
                    }
                    if(deviceId){
                        constraints.video.deviceId = { exact: deviceId}
                    }

                    try {
                        let stream = await navigator.mediaDevices.getUserMedia(constraints)
                        onGetUserMediaSuccess(stream)
                    }catch (error) {
                        onGetUserMediaFailed(error)
                    }
                }
            }
        }
        localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))
    }

    // 创建video标签
    var cameraPrevVideo = document.createElement('video')
    cameraPrevVideo.onloadedmetadata = MediaDevice.prototype.displayVideoDimensions;
    /***
     * video 元数据加载完成后触发，用于判断取流后的分辨率与实际要求是否一致
     * @param scanListIndex 当前扫描的分辨率列表的索引值
     * @param cameraIndex 当前扫描的摄像头列表值
     */
    MediaDevice.prototype.displayVideoDimensions = function (scanListIndex, cameraIndex) {
        var This = this
        var i = scanListIndex
        var j = cameraIndex
        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        var capability = mediaDevice.cameras[j].capability
        var quickScanList = This.getQuickScanList()
        log.log("Video onloadedmetadata call~~~");

        function captureResults(data) {
            if (data.result === true) {
                log.log("pass")
                capability.push({
                    width: quickScanList[i].width,
                    height: quickScanList[i].height,
                    frameRate: quickScanList[i].frameRate,
                    aspectRatio: quickScanList[i].ratio
                })
                localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))
            } else {
                log.log("fail: mismatch")
            }

            i++
            if (i < quickScanList.length) {
                log.log('Scan the next resolution')
                window.isScanCameraChange = false
                This.getStreamWithoutConstraintsKeyWords(i, j)
            } else if (j < mediaDevice.cameras.length - 1) {
                log.log('Scan the next camera')
                window.isScanCameraChange = true
                This.closeStream(stream)
                j++;
                i = 0;
                This.getStreamWithoutConstraintsKeyWords(i, j)
            } else {
                This.closeStream(stream)
                log.log("All camera capabilities are End of scan ~~")
                cameraPrevVideo = null
            }
        }

        if (!cameraPrevVideo.videoWidth) {
            setTimeout(function () {
                This.displayVideoDimensions(scanListIndex, cameraIndex)
            }, 500);  //was 500
        }

        if (cameraPrevVideo.videoWidth * cameraPrevVideo.videoHeight > 0) {
            log.info("Display size for : " + quickScanList[scanListIndex].width + "x" + quickScanList[scanListIndex].height);
            log.info("Stream dimensions for :" + cameraPrevVideo.videoWidth + "x" + cameraPrevVideo.videoHeight);
            if (quickScanList[scanListIndex].width + "x" + quickScanList[scanListIndex].height !== cameraPrevVideo.videoWidth + "x" + cameraPrevVideo.videoHeight) {
                log.info("fail: mismatch")
                captureResults({result: false})
            } else {
                log.info("pass :" + quickScanList[scanListIndex].width + "x" + quickScanList[scanListIndex].height)
                captureResults({result: true})
            }
        }

    }

    /***
     * 兼容不支持min/max/ideal/exact的情况，使用{audio:false, video: { width: 1280, height: 720}} 格式取流
     * 通过取流后的video实际尺寸判断取流是否成功
     * @param scanListIndex 当前扫描的分辨率列表的索引值
     * @param cameraIndex 当前扫描的摄像头列表值
     * @returns {Promise<void>}
     */
    MediaDevice.prototype.getStreamWithoutConstraintsKeyWords = async function (scanListIndex, cameraIndex) {
        var This = this
        var quickScanList = This.getQuickScanList()
        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        var i = scanListIndex
        var j = cameraIndex
        var mediaStream = window.stream
        var deviceId = mediaDevice.cameras[j].deviceId
        var capability = mediaDevice.cameras[j].capability
        var constraints;

        // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描
        if (window.isScanCameraChange === true && capability && capability.length > 0) {
            log.warn("this device has already get resolution before: " + mediaDevice.cameras[j].label)
            cameraIndex++
            if (cameraIndex < mediaDevice.cameras.length) {
                log.warn('Scan the next device')
                This.getStreamWithoutConstraintsKeyWords(scanListIndex, cameraIndex)
            }
            return
        }
        window.isScanCameraChange = false

        function onGetUserMediaSuccess(stream) {
            log.log('applyConstraints success' + JSON.stringify(constraints, null, '    '))
            log.log("Display size for " + quickScanList[i].label + ": " + quickScanList[i].width + "x" + quickScanList[i].height);

            if(stream){
                window.stream = stream
                cameraPrevVideo.srcObject = stream
            }

            setTimeout(function () {
                This.displayVideoDimensions(scanListIndex, cameraIndex)
            }, 2000);
        }

        function onGetUserMediaFailed(error){
            log.warn('applyConstraints error: ', error.name)
        }

        log.warn("Current scan device：", mediaDevice.cameras[j].label)
        var videoTrack = mediaStream ? mediaStream.getVideoTracks()[0] : null
        if (mediaStream && mediaStream.active === true && mediaStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {
            constraints = {
                frameRate: quickScanList[i].frameRate,
                width: quickScanList[i].width,
                height: quickScanList[i].height,
                aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},
            }

           try {
               await videoTrack.applyConstraints(constraints)
               onGetUserMediaSuccess()
           }catch (error) {
               onGetUserMediaFailed(error)
           }
        } else {
            constraints = {
                audio: false,
                video: {
                    deviceId: deviceId,
                    frameRate: quickScanList[i].frameRate,
                    width: quickScanList[i].width,
                    height: quickScanList[i].height,
                    aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},
                }
            }

           try {
               await navigator.mediaDevices.getUserMedia(constraints)
               onGetUserMediaSuccess(stream)
           }catch (error) {
               onGetUserMediaFailed(error)
           }
        }
    }

    /***
     * 设置设备所支持的取流能力：frameRate, width, height
     */
    MediaDevice.prototype.setDeviceCapability = async function () {
        log.warn('device capability scanning')
        var This = this
        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        // 判断取流是否支持关键字设置
        var isKeywordSupport = await This.isConstraintsKeywordSupport()
        mediaDevice.isConstraintsKeywordSupport = isKeywordSupport

        if (mediaDevice && mediaDevice.cameras.length > 0) {
            if (isKeywordSupport === true) {
                log.info("min/max/ideal/exact keyWord is support")
                await This.getStreamWithExactConstraints()
            } else {
                log.info("min/max/ideal/exact keyWord is  NOT support")
                window.isScanCameraChange = true
                await This.getStreamWithoutConstraintsKeyWords(0, 0)
            }
        } else {
            log.warn('no cameras need to resolution scan!')
        }
    }

    /***
     * 检查可用设备列表
     */
    MediaDevice.prototype.checkAvailableDev = function () {
        var This = this

        This.enumDevices(function (deviceInfo) {
            // log.log("get device info success: \n", JSON.stringify(deviceInfo))
            function setLabel(devices, type) {
                for (var key = 0; key < devices.length; key++) {
                    if (!devices[key].label) {
                        devices[key].label = type + key
                    }
                    log.log(type + " " + devices[key].label)
                }
                return devices
            }

            if (deviceInfo) {
                if (deviceInfo.cameras) {
                    setLabel(deviceInfo.cameras, 'cameras')
                }
                if (deviceInfo.microphones) {
                    setLabel(deviceInfo.microphones, 'microphones')
                }
                if (deviceInfo.speakers) {
                    setLabel(deviceInfo.speakers, 'speakers')
                }

                This.updateDeviceInfo(deviceInfo, "cameras")
                This.updateDeviceInfo(deviceInfo, "microphones")
                This.updateDeviceInfo(deviceInfo, "speakers")
            } else {
                log.warn("deviceInfo is null")
            }

        }, function (error) {
            log.error('enum device error: ' + error.toString())
        })
    }

    /***
     * 设备定时检查开关
     * @param switchOn: true 开启定时器；  false 关闭定时器
     */
    MediaDevice.prototype.setDeviceCheckInterval = function (switchOn) {
        var This = this
        if (switchOn) {
            clearInterval(This.deviceCheckTimer)
            This.deviceCheckTimer = setInterval(function () {
                This.checkAvailableDev()
            }, 1000)
        } else {
            clearInterval(This.deviceCheckTimer);
            This.deviceCheckTimer = null
        }
    }

    /***
     * 获取最接近，最合适的设备支持的分辨率
     * @param expectRes 当前希望获取的分辨率，eg {
     *   deviceId: 4b5305afd805f2d8439eac80dc94b14846799929d44d18c7dd8fc97eda75c046
     *   frameRate: 15,
     *   width: 1080,
     *   height: 720
     * }
     */
    MediaDevice.prototype.getSuitableResolution = function (expectRes) {
        if (!expectRes.deviceId || !expectRes.width || !expectRes.height || !expectRes.frameRate) {
            log.warn('Invalid parameter');
            return
        }

        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        var capability = []
        var sameWidthList = []
        var matchRes = {}

        if (mediaDevice && mediaDevice.cameras.length > 0) {
            // 获取给定设备支持的取流能力列表
            for (var i = 0; i < mediaDevice.cameras.length; i++) {
                if (mediaDevice.cameras[i].deviceId === expectRes.deviceId) {
                    capability = mediaDevice.cameras[i].capability
                    log.warn("capability: ", capability)
                    break
                }
            }

            // 过滤出相同width的分辨率
            if (capability.length > 0) {
                for (var j = 0; j < capability.length; j++) {
                    if (capability[j].width === expectRes.width) {
                        sameWidthList.push(capability[j])
                    }
                }
                log.warn("sameWidthList: ", sameWidthList)
            }

            // 获取最合适的分辨率
            if (sameWidthList.length > 0) {
                for (var k = 0; k < sameWidthList.length; k++) {
                    // 返回width height frameRate 都相同的分辨率
                    if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {
                        log.warn('Returns the resolution of width height frameRate', sameWidthList[k])
                        matchRes = sameWidthList[k]
                        break
                    }
                }

                if (JSON.stringify(matchRes) === "{}") {
                    for (var k = 0; k < sameWidthList.length; k++) {
                        // 返回width height相同， frameRate 小于期望值的的分辨率
                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate < expectRes.frameRate) {
                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])
                            matchRes = sameWidthList[k]
                            break
                        }
                    }
                }

                if (JSON.stringify(matchRes) === "{}") {
                    for (var k = 0; k < sameWidthList.length; k++) {
                        // 返回width frameRate 相同， height 小于期望值的的分辨率
                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height < expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {
                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])
                            matchRes = sameWidthList[k]
                            break
                        }
                    }
                }
            } else {
                log.warn("no same with resolution exist, get other resolution;")
                // 返回设备支持的最大的、width比期望值小的分辨率
                for (var j = 0; j < capability.length; j++) {
                    if (capability[j].width < expectRes.width) {
                        log.log('Returns the maximum resolution supported by the device with a smaller width than expected')
                        matchRes = capability[j]
                        break
                    }
                }
            }
            return matchRes
        }
        return matchRes
    }

    /******************************************************************************************************************/
    /******************************************************* 取流 *****************************************************/
    /******************************************************************************************************************/
    /***
     * 取流： audio/video/screenShare
     * @param data {
     *      callback: callback,
        streamType: "video",
        constraintsKeyWord: "exact",
        constraints: {
            aspectRatio: {min: 1.777, max: 1.778},
            frameRate: 30,
            width: 1280,
            height: 720,
            deviceId: deviceId,
        }
     * }
     * @param constraints
     */
    MediaDevice.prototype.getMedia = async function (data, constraints) {
        log.warn("getMedia")
        var This = this
        if (!constraints) {
            constraints = This.getConstraints(data, true)
        }

        function onGetStreamSuccess(stream) {
            data.callback({stream: stream})
        }

        function onGetStreamFailed(error) {
            data.settings = constraints
            data.error = error
            log.error("onGetStreamFailed: ", error.name, error.message)
            if(error.name === "OverconstrainedError" || error.name === "ConstraintNotSatisfiedError"){
                // constraints can not be satisfied by avb.device
                log.warn('constraints can not be satisfied by avb.device')
                This.getMedia(data)
            }else {
                if(error.name === "NotFoundError" || error.name === "DeviceNotFoundError"){
                    // require track is missing
                    log.warn('require track is missing')
                }else if(error.name === "NotReadableError" || error.name === "TrackStartError"){
                    // webcam or mic are already in use
                    log.warn('webcam or mic are already in use')
                }else if(error.name === "NotAllowedError" || error.name === "PermissionDeniedError" || error.name === "PermissionDismissedError"){
                    // permission denied in browser
                    log.warn('permission denied in browser')
                }else if(error.name === "TypeError"){
                    // empty constraints object
                    log.warn('empty constraints object')
                }else {
                    // other errors
                    log.warn('other errors ' + error.name)
                }
                data.callback({error: error})
            }
        }

        if (data.streamType === 'audio' || data.streamType === 'video') {
            let stream = data.stream
            let videoTrack = null
            if (data.streamType === 'video' && stream && stream.getVideoTracks().length && stream.active === true) {
                videoTrack = stream.getVideoTracks()[0]
                var constraintsOfApply = constraints.video
                if (videoTrack && videoTrack.applyConstraints) {
                    log.warn("applyConstraints constraints: ", JSON.stringify(constraintsOfApply, null, '    '))
                    await videoTrack.applyConstraints(constraintsOfApply).then(onGetStreamSuccess).catch(onGetStreamFailed)
                }
            } else {
                // audio and video not
                log.warn("getUserMedia constraints: ", JSON.stringify(constraints, null, '    '))
                navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)
            }
        } else if (data.streamType === 'screenShare') {
            if (navigator.getDisplayMedia) {
                navigator.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)
            } else if (navigator.mediaDevices.getDisplayMedia) {
                navigator.mediaDevices.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)
            } else {
                log.info('getDisplayMedia is not supported by current browser')
                // 使用插件共享桌面
                window.getScreenId('all', function(error, sourceId, screen_constraints) {
                    navigator.getUserMedia(screen_constraints, onGetStreamSuccess, onGetStreamFailed)
                });
            }
        }
    }

    /***
     * 获取分辨率
     * @param data, eg.{
        constraintsKeyWord: "exact"
        deviceId: "8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03"
        frameRate: 30s
        height: 720
        streamType: "video"
        width: 1280
     * }
     * @param reTry: true 取流失败后重新取流， false 第一次取流
     */
    MediaDevice.prototype.getConstraints = function (data, reTry) {
        let This = this
        let constraints = {}
        switch (data.streamType) {
            case 'audio':
                constraints = {
                    audio: data.deviceId ? {deviceId: data.deviceId} : true,
                    video: false
                }
                break;
            case 'video':
                constraints = This.getVideoConstraints(data, reTry)
                break
            case 'screenShare':
                constraints = This.getScreenShareConstraints(data)
                break
            default:
                break
        }

        return constraints
    }

    /***
     * 获取video 分辨率
     * @param data 需要得参数
     constraintsKeyWord: "exact"
     deviceId: "8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03"
     frameRate: 15
     height: 720
     streamType: "video"
     width: 1280
     * @param reTry 需要得参数 : true 取流失败重新取流, false 第一次取流
     * @returns {{audio: boolean, video: {frameRate: {exact: number}, width: {exact: number}, aspectRatio: {exact: number}, height: {exact: number}}}}
     */
    MediaDevice.prototype.getVideoConstraints = function (data, reTry) {
        let This = this
        let matchResolution = {}
        let currentLimit = {}
        let deviceId

        if (reTry) {
            // 这种方式不需要重复获取匹配了
            currentLimit = This.getNextConstraints(data)
            deviceId = currentLimit.deviceId
            matchResolution = currentLimit
        } else {
            // 默认首次取流都使用exact
            deviceId = data.deviceId
            currentLimit = data
            log.info("deviceId: ", deviceId)
            if (deviceId) {
                matchResolution = This.getSuitableResolution({
                    frameRate: currentLimit.frameRate ? currentLimit.frameRate : 30,
                    width: currentLimit.width ? currentLimit.width : 640,
                    height: currentLimit.height ? currentLimit.height : 360,
                    deviceId: currentLimit.deviceId
                })
                log.log("match constraints: ", matchResolution)
            }
        }

        log.info("currentLimit: ", currentLimit)
        let constraints = {
            audio: false,
            video: {
                frameRate: {
                    exact: matchResolution.frameRate ? matchResolution.frameRate : currentLimit.frameRate ? currentLimit.frameRate : 30
                },
                aspectRatio: {
                    exact: matchResolution.width ? (matchResolution.width / matchResolution.height) : (currentLimit.width / currentLimit.height)
                },
                width: {
                    exact: matchResolution.width ? matchResolution.width : currentLimit.width ? currentLimit.width : 640
                },
                height: {
                    exact: matchResolution.height ? matchResolution.height : currentLimit.height ? currentLimit.height : 360
                }
            }
        }

        if (deviceId) {
            constraints.video.deviceId = {
                exact: deviceId
            }
        }

        log.log("data.constraintsKeyWord: ", data.constraintsKeyWord)
        if (!data.constraintsKeyWord) {
            log.warn("Do not use keyWord limit")
            constraints.video.frameRate = constraints.video.frameRate.exact
            constraints.video.aspectRatio = constraints.video.aspectRatio.exact
            constraints.video.width = constraints.video.width.exact
            constraints.video.height = constraints.video.height.exact
            if (constraints.video.deviceId.exact || constraints.video.deviceId.ideal) {
                constraints.video.deviceId = constraints.video.deviceId.exact ? constraints.video.deviceId.exact : constraints.video.deviceId.ideal
            }
        } else if (data.constraintsKeyWord === 'ideal') {
            log.warn("Use ideal limit")
            constraints.video.frameRate.ideal = constraints.video.frameRate.exact
            constraints.video.aspectRatio.ideal = constraints.video.aspectRatio.exact
            constraints.video.width.ideal = constraints.video.width.exact
            constraints.video.height.ideal = constraints.video.height.exact
            // 使用max限制来避免超出要求的能力
            constraints.video.frameRate.max = constraints.video.frameRate.exact
            constraints.video.aspectRatio.max = constraints.video.aspectRatio.exact
            constraints.video.width.max = constraints.video.width.exact
            constraints.video.height.max = constraints.video.height.exact
            if (constraints.video.deviceId.exact) {
                constraints.video.deviceId.ideal = constraints.video.deviceId.exact
            }
            // 删除exact属性
            delete constraints.video.frameRate.exact
            delete constraints.video.aspectRatio.exact
            delete constraints.video.width.exact
            delete constraints.video.height.exact
            delete constraints.video.deviceId.exact
        } else if (data.constraintsKeyWord === 'exact') {
            log.warn("Use exact limit")
        }

        log.warn("get new Video Constraints: ", JSON.stringify(constraints, null, '   '))
        return constraints
    }

    /***
     * 取流失败后根据设备支持的能力列表获取下一个分辨率
     * @param data = {
     *      callback: ƒ (message)
        constraints: {aspectRatio: {…}, frameRate: 30, width: 1280, height: 720, deviceId: "5e3722883e2e9337040a4f1ababf85a5bd2f6a36afc815fd391424ac05a84ab0"}
        constraintsKeyWord: "ideal"
        error: OverconstrainedError {name: "OverconstrainedError", message: null, constraint: "frameRate"}
        settings: {audio: false, video: {…}}
        streamType: "video"
     * }
     * @returns {{frameRate: number, streamType: string, width: number, deviceId: (*|number|boolean|string|string[]|ConstrainDOMStringParameters|"user"|"environment"|"left"|"right"|VideoFacingModeEnum[]), constraintsKeyWord: (string), height: number}}
     */
    MediaDevice.prototype.getNextConstraints = function (data) {
        let This = this
        // 获取上一次取流失败的分辨率限制
        let lastSettings = data.settings
        let settings = {
            frameRate: lastSettings.video.frameRate.exact ? lastSettings.video.frameRate.exact : lastSettings.video.frameRate.ideal ? lastSettings.video.frameRate.ideal : lastSettings.video.frameRate,
            width: lastSettings.video.width.exact ? lastSettings.video.width.exact : lastSettings.video.width.ideal ? lastSettings.video.width.ideal : lastSettings.video.width,
            height: lastSettings.video.height.exact ? lastSettings.video.height.exact : lastSettings.video.height.ideal ? lastSettings.video.height.ideal : lastSettings.video.height,
            deviceId: lastSettings.video.deviceId.exact ? lastSettings.video.deviceId.exact : lastSettings.video.deviceId.ideal ? lastSettings.video.deviceId.ideal : lastSettings.video.deviceId,
        }

        // 获取下一个分辨率
        let deviceId = settings.deviceId ? settings.deviceId : data.deviceId
        let capability = This.getCapability(deviceId)
        let nextConstraints
        for (let j = 0; j < capability.length; j++) {
            if (capability[j].width === settings.width && capability[j].height === settings.height && capability[j].frameRate === settings.frameRate) {
                nextConstraints = capability[j + 1]
                break
            }
        }

        log.log("nextConstraints: ", nextConstraints)
        // 如果nextConstraints不存在，说明能力列表全部扫描完成，换其他的限制尝试（exact/ideal/不使用）
        if (!nextConstraints) {
            log.warn("Change the restriction condition.")
            if (data.constraintsKeyWord === 'exact') {
                log.warn("Exact has been scanned, using ideals")
                data.constraintsKeyWord = 'ideal'
            } else if (data.constraintsKeyWord === 'ideal') {
                log.warn("The ideal has been scanned. Do not use keywords")
                data.constraintsKeyWord = ''
            } else {
                // 取流彻底失败，调用回调返回
                log.warn("The flow failed completely, and the flow was not taken.")
                data.callback({error: data.error})
            }
        }

        return {
            constraintsKeyWord: data.constraintsKeyWord,
            streamType: data.streamType,
            deviceId: settings.deviceId ? settings.deviceId : data.deviceId,
            frameRate: nextConstraints ? nextConstraints.frameRate ? nextConstraints.frameRate : data.constraints.frameRate : data.constraints.frameRate,
            width: nextConstraints ? nextConstraints.width ? nextConstraints.width : data.constraints.width : data.constraints.width,
            height: nextConstraints ? nextConstraints.height ? nextConstraints.height : data.constraints.height : data.constraints.height,
        }
    }

    /***
     * 获取屏幕共享分辨率
     * @param data
     * @returns {{audio: boolean, video: {frameRate: {max: string}, width: {max: string}, height: {max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, mozMediaSource: *, width: {min: string, max: string}, mediaSource: *, height: {min: string, max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, width: {min: string, max: string}, logicalSurface: boolean, displaySurface: string, height: {min: string, max: string}}}|{audio: boolean, video: {optional: {sourceId: string}[], mandatory: {minFrameRate: number, maxFrameRate: number}}}}
     */
    MediaDevice.prototype.getScreenShareConstraints = function (data) {
        let screenConstraints
        /***
         * for all supported getDisplayMedia browser versions
         */
        if (navigator.mediaDevices.getDisplayMedia) {
            screenConstraints = {
                audio: false,
                video: {
                    width: {max: '1920'},
                    height: {max: '1080'},
                    frameRate: {max: '5'}
                }
            };
        }

        /***
         * for Firefox
         */
        if (!!navigator.mozGetUserMedia) {
            screenConstraints = {
                audio: false,
                video: {
                    mozMediaSource: source,
                    mediaSource: source,
                    width: {min: '10', max: '1920'},
                    height: {min: '10', max: '1080'},
                    frameRate: {min: '1', max: '5'}
                }
            };
        }

        /***
         * for Edge
         */
        if (adapter.browserDetails.browser === "edge") {
            if (adapter.browserDetails.version >= 17134 && !!navigator.getDisplayMedia) {
                screenConstraints = {
                    audio: false,
                    video: {
                        displaySurface: 'window',
                        logicalSurface: true,
                        width: {min: '10', max: '1920'},
                        height: {min: '10', max: '1080'},
                        frameRate: {min: '1', max: '5'}
                    }
                };
            } else {
                log.warn("This version of Edge does not support screen capture feature");
                return;
            }
        }

        /***
         * For IE / Safari which is installed webrtc-everywhere
         */
        if ((adapter.browserDetails.browser === "ie" || adapter.browserDetails.browser === "safari") && adapter.browserDetails.isWebRTCPluginInstalled === true) {
            screenConstraints = {
                audio: false,
                video: {
                    optional: [{sourceId: "X978GrandstreamScreenCapturer785"}],
                    mandatory: {
                        minFrameRate: 1,
                        maxFrameRate: 5
                    }
                }
            };
        }

        return screenConstraints
    }

    /***
     * 根据deviceId 获取当前设备的设备支持能力
     * 设备信息定时更新的，所以deviceId不会存在不匹配问题
     * @param deviceId
     * @returns {Array}
     */
    MediaDevice.prototype.getCapability = function (deviceId) {
        let This = this
        let mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))
        let capability = []
        let cameras = mediaDevice.cameras
        if (cameras && cameras.length) {
            for (let i = 0; i < cameras.length; i++) {
                if (cameras[i].deviceId === deviceId) {
                    capability = cameras[i].capability
                }
            }
        }

        if (!capability.length) {
            capability = This.getQuickScanList()
        }
        log.info("capability: ", capability)

        return capability
    }

    return MediaDevice;

}));
/*Log Debug Start*/
var log = { };
log.debug = window.debug("sipWebRTC:DEBUG");
log.log   = window.debug("sipWebRTC:LOG");
log.info  = window.debug("sipWebRTC:INFO");
log.warn  = window.debug("sipWebRTC:WARN");
log.error = window.debug("sipWebRTC:ERROR");
/*Log Debug End*/

/**
 * WebRTC API Instance
 * @constructor
 */
let GsRTC = function (options) {
    this.device = null
    this.sipStack = null
    this.sokect = null
    this.RTCSession = null

    this.EVENTS = []
    // 上层注册事件
    this.handlerFuns = []
    this.conf = options;
    this.sessionVersion = 0
    this.enableMultiStream = false
    this.action = null

    this.transaction = null
    this.isRecvRequest = false    // true => recv request
    this.isSendReInvite = false
    this.inviteProcessing = false
    this.sendInviteQueue = []

    // if(options){
    //     this.loadStorageConfiguration();
    // }
    //
    // this.deviceInit()
    // this.eventBindings()
}

/**
 * set storage settings
 */
GsRTC.prototype.loadStorageConfiguration = function () {
    log.info('local storage configuration')
    /* 这里设置fec的开关控制阀 */
    if (this.getBrowserDetail().browser === 'chrome'&& this.getBrowserDetail().version >= 69 || this.getBrowserDetail().browser === 'safari'){
        log.info('set test_red_ulpfec_enabled false')
        localStorage.setItem("test_red_ulpfec_enabled", 'false');
    }else{
        if(localStorage.test_red_ulpfec_enabled === undefined){
            log.info('set test_red_ulpfec_enabled true')
            localStorage.setItem("test_red_ulpfec_enabled", 'true');
        }
    }

    /* set switch of trickle_ice */
    if(localStorage.trickle_ice === undefined){
        log.info('set trickle_ice false')
        localStorage.setItem("trickle_ice", 'false');
    }
}

/**
 * available device scan and capability scan
 */
GsRTC.prototype.deviceInit = function () {
    log.info('device init')
    let This = this
    if(window.MediaDevice){
        This.device =  new MediaDevice()
        This.device.enumDevices(deviceInfo => {
            log.log('enumDevices' + JSON.stringify(deviceInfo))
            This.device.availableDev = {}
            This.device.availableDev.videoInputList = deviceInfo.cameras
            This.device.availableDev.audioOutputList = deviceInfo.speakers
            This.device.availableDev.audioInputList = deviceInfo.microphones
            This.device.checkAvailableDev()
            setTimeout(function () {
                This.device.setDeviceCapability()
            }, 1000)
        }, function (error) {
            log.error('enum device error: ' + error)
        })
    }else {
        log.info('MediaDevice is not exist!')
    }
}




window.onload = function () {
    var oReadyStateTimer = setInterval(function () {
            if (document.readyState === "complete") {
                if(!GsRTC){
                    log.warn("ERR_NOT_LOADED: GsRTC not loaded yet.")
                    return
                }
                clearInterval(oReadyStateTimer);
                // initialize gsRTC
                GsRTC.prototype.preInit()
            }
        },
        500);
}

/**
 * gsRTC init
 */
GsRTC.prototype.preInit = function() {
    log.info('create new GsRTC object');
    try {
        let options = {}
        window.gsRTC = new GsRTC(options);
        /* Listen for postMessage messages thrown on webWorker*/
        window.onmessage = function(event){
            gsRTC.onmessage(event)
        }
    }catch (e) {
        log.error(e.toString())
    }
}

/**
 * Binding page media elements
 * @param args
 */
GsRTC.prototype.setHtmlMediaElement = function(args){
    try {
        this.HTML_MEDIA_ELEMENT.localAudio = args.localAudio
        this.HTML_MEDIA_ELEMENT.localVideo = args.localVideo
        this.HTML_MEDIA_ELEMENT.localPresentVideo = args.localPresentVideo
        this.HTML_MEDIA_ELEMENT.localVideoShare = args.localVideoShare
        this.HTML_MEDIA_ELEMENT.remoteAudio = args.remoteAudio
        this.HTML_MEDIA_ELEMENT.remoteVideo = args.remoteVideo
        this.HTML_MEDIA_ELEMENT.remotePresentVideo = args.remotePresentVideo
        this.HTML_MEDIA_ELEMENT.remoteVideoShare = args.remoteVideoShare
    }catch (e) {
        throw new Error(e);
    }
}

/**
 * Open to upper-level event registration interface
 * eventType：Event type
 * handerFun：User-defined processing functions
 */
GsRTC.prototype.addSipEventHandler = function(eventType,handlerFun){
    this.preInit();
    if (window.gsRTC){
        window.gsRTC.on(eventType,handlerFun);
        window.gsRTC.handlerFuns[eventType] = handlerFun;
    }else {
        log.error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please create gsRTC first");
    }
}

/**
 * Sip registration information
 *
 * sipRegisterInfo：Sip Required fields for registration
 * sipRegisterInfo：Sip:{
 * 		p_realm : "dsf",
		p_impi : "f",
		p_passwd : "",
		p_displayname : "",
		p_websocketurl : "",
		p_iceservers : ""
 * }
 *
 * cb_register：Registration result callback function
 * cb_register：function(err:undefined|ErrorObject)
 */
GsRTC.prototype.sipRegister = function(sipRegisterInfo,registerCb) {
    if(!sipRegisterInfo){
        log.error("sipRegister failed!");
        registerCb("RegisterSipError:ArgumentInvalid");
        return;
    }

    if(this.device){
        log.info('set device check interval')
        this.device.setDeviceCheckInterval(true)
    }

    if(this.conf){
        this.conf.sipRealm = sipRegisterInfo.sipRealm;
        this.conf.sipImpi = sipRegisterInfo.sipImpi;
        this.conf.sipPasswd = sipRegisterInfo.sipPasswd;
        this.conf.sipDispalyName = sipRegisterInfo.sipDispalyName;

        // Grandstream gsmeeting/webrtc_chrome 74.0.3729.108
        this.conf.userAgent= sipRegisterInfo.userAgent ? sipRegisterInfo.userAgent :  "Grandstream gsmeeting/webrtc_" + this.getBrowserDetail().browser + ' ' + this.detectBrowser().UIVersion
        this.conf.host = sipRegisterInfo.host    // df7jal23ls0d.invalid
        this.conf.organization = sipRegisterInfo.organization ? sipRegisterInfo.organization : 'Grandstream'

        this.conf.protocol = sipRegisterInfo.protocol
        this.conf.websocketUrl = sipRegisterInfo.websocketUrl;

        this.conf.iceServer = sipRegisterInfo.iceServers;
        this.conf.iceTransportPolicy = sipRegisterInfo.iceTransportPolicy;
        this.conf.RTCpeerConnectionOptional = sipRegisterInfo.RTCpeerConnectionOptional;
    }
    this.action = 'onRegister'
    this.on('onRegister', registerCb)

    this.sokect = new WebSocketInstance(sipRegisterInfo.websocketUrl, sipRegisterInfo.protocol || 'sip')
    this.sipStack = new SipStack(sipRegisterInfo, registerCb, this)
    this.sipStack.jsSipSendRegister(3600)
}

/**
 * call and send invite
 * @param sipCallInfo
 * @param callback
 */
GsRTC.prototype.call = function (sipCallInfo, callback) {
    if(!sipCallInfo){
        throw new Error('ERR_INVALID_PARAMETER_VALUE');
    }

    if(this.conf){
        this.conf.sessionsConfig = sipCallInfo.sessionsConfig;
        this.conf.to = sipCallInfo.to
        this.conf.initialResolution = sipCallInfo.initialResolution
    }
    if (this.sipStack.conf){
        this.sipStack.conf.allocate = 'sip:'+ sipCallInfo.to + '@' + this.conf.sipRealm
    }

    this.action = 'onCall'
    this.on('onCall', callback)
    this.RTCSession = new PeerConnection(sipCallInfo, this)

    if(sipCallInfo.enableMultiStream){
        log.info('set enableMultiStream true')
        localStorage.setItem("enableMultiStream", 'true');
        this.enableMultiStream = true
        this.RTCSession.createMultiStreamRTCSession(this.conf)
    }else {
        log.info('set enableMultiStream false')
        localStorage.setItem("enableMultiStream", 'false');
        this.enableMultiStream = false
        this.RTCSession.createRTCSession(this.conf)
    }
}

/**
 * Leave the meeting
 */
GsRTC.prototype.hangup = function () {
    if(!this.sipStack){
        log.error('gsRTC is not initialized')
        return
    }
    if(!this.RTCSession){
        log.error("RTCSession is not initialized")
        return
    }
    try {
        this.sipStack.jsSipSendBye()
        for (let key in this.RTCSession.peerConnections) {
            let pc = this.RTCSession.peerConnections[key];
            // close stream
            let type = this.RTCSession.getStreamType(pc.type, true)
            this.RTCSession.closeStream(this.MEDIA_STREAMS[type])

            // close peerConnection
            pc.getSenders().forEach(sender => {
                delete sender.track
                sender.replaceTrack(null)
            })
            pc.close()
        }
    }catch (e) {
        log.error(e)
    }
}

/**
 * share local audio
 * @param data
 * data.stream
 * data.deviceId: given deviceId
 */
GsRTC.prototype.shareAudio = function(data) {
    if(!this.RTCSession){
        log.error('invalid RTCSession parameters! can not share audio')
        return
    }

    log.info('share local audio: ' + data.deviceId)
    let This = this
    let type = 'audio'
    let stream = this.RTCSession.getStream(type, true)
    if(stream){
        this.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: false})
    }else {
        log.info('getting new stream')
        async function getMediaCallBack(args){
            if(args.stream){
                let stream = args.stream
                log.info('get stream: ' +  stream ? stream.id : null)
                This.RTCSession.setStream(stream, type, true)
                let pc
                if(This.enableMultiStream){
                    pc = This.RTCSession.peerConnections['multiStreamPeer']
                }else {
                    pc = This.RTCSession.peerConnections[type]
                }
                This.RTCSession.processAddStream(stream, pc, type)
                await This.RTCSession.doOffer(pc)
            }else if(args.error){
                log.error('Get audio stream failed: ' + args.error)
                data.callback({error: args.error})
            }
        }

        let conf = { streamType: type, callback: getMediaCallBack }
        let constraints = {
            audio: data.deviceId ? { deviceId: data.deviceId }: true,
            video: false
        }

        this.action = 'audioRefresh'
        this.on('audioRefresh', data.callback)
        this.sendInviteQueue.push({ action: 'audioRefresh', sdp: null })
        this.device.getMedia(conf, constraints)
    }
}

/**
 * 切换音频源
 * @param data
 * data.callback
 * data.deviceId
 */
GsRTC.prototype.switchAudioSource = function(data) {
    log.info('switch audio source: ' + data.deviceId)
    if(!this.RTCSession){
        log.error('switchAudioSource: invalid RTCSession parameters!')
        return
    }
    let This = this
    let type = data.type
    let previousStream = this.RTCSession.getStream(type, true)
    let pc
    if(This.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    async function getMediaCallBack(event){
        if(event.stream){
            let stream = event.stream
            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){
                This.RTCSession.processAddStream(stream, pc, type)
                data.callback({codeType: 200})
            }else {
                log.info('clear previous stream')
                This.sendInviteQueue.push({ action: 'switchAudioSource', sdp: null })
                This.RTCSession.processRemoveStream(previousStream, pc, type)
                This.RTCSession.processAddStream(stream, pc, type)
                await This.RTCSession.doOffer(pc)
            }
            This.RTCSession.closeStream(previousStream)
            This.RTCSession.setStream(stream, type, true)
        }else {
            log.error(event.error)
            data.callback({error:event.error})
        }
    }

    let conf = { streamType: type, callback: getMediaCallBack }
    let  constraints = {
        audio: data.deviceId ? { deviceId: data.deviceId } : true,
        video: false
    }

    this.action = 'switchAudioSource'
    this.on('switchAudioSource', data.callback)
    this.device.getMedia(conf, constraints)
}

/**
 * stop share local audio
 * @param data: callback
 */
GsRTC.prototype.stopShareAudio = function(data) {
    if(!this.RTCSession){
        log.error('stopShareAudio: invalid RTCSession parameters! ')
        return
    }

    try {
        let type = data.type
        let stream = this.RTCSession.getStream(type, true)
        if(stream){
            this.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: true})
        }else {
            log.info('Audio stream: null')
        }
    }catch (e) {
        log.error(e.toString())
        data.callback({error: e})
    }
}

/**
 * 开启本地视频
 * @param data
 * data.stream
 * data.type
 * data.deviceId
 */
GsRTC.prototype.shareVideo = function(data) {
    if(!this.RTCSession){
        log.error('shareVideo: invalid RTCSession parameters! ')
        return
    }

    let This = this
    let type = 'main'
    let previousStream = This.RTCSession.getStream(type, true)
    let pc
    if(This.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }
    let param = {
        streamType: 'video',
        constraintsKeyWord: 'exact',
        deviceId: data.deviceId,
        frameRate: 30,
        width: 640,
        height: 360,
    }
    let constraints = this.device.getConstraints(param)

    function getMediaCallBack(event){
        if(event.stream){
            log.info('get stream success')
            let stream = event.stream
            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){
                This.RTCSession.processAddStream(stream, pc, type)
                if(data.callback){
                    data.callback({codeType: 200})
                }
            }else {
                log.info('clear previous stream')
                This.sendInviteQueue.push({ action: 'shareVideo', sdp: null })
                This.RTCSession.processRemoveStream(previousStream, pc, type)
                This.RTCSession.processAddStream(stream, pc, type)
                This.RTCSession.doOffer(pc)
            }

            This.RTCSession.closeStream(previousStream)
            This.RTCSession.setStream(stream, type, true)

            This.RTCSession.deviceId = data.deviceId  // save deviceId
            This.setVideoResolution({width: param.width, height: param.height}, 'CURRENT_UP_RESOLUTION')
        }else {
            log.info('get stream failed')
            data.callback({error: event.error})
            log.error(event.error)
        }
    }

    let gumData = { streamType: 'video', callback: getMediaCallBack }
    this.action = 'shareVideo'
    this.on('shareVideo', data.callback)
    this.device.getMedia(gumData, constraints)
}

/**
 * 关闭本地视频
 * @param data 回调函数
 */
GsRTC.prototype.stopShareVideo = function(data) {
    if(!this.RTCSession){
        log.error('stopShareVideo: invalid RTCSession parameters! ')
        return
    }

    let type = 'main'
    let stream = this.RTCSession.getStream(type, true)
    let pc
    if(this.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    if(stream){
        this.action = 'stopShareVideo'
        this.on('stopShareVideo', data.callback)
        this.sendInviteQueue.push({ action: 'stopShareVideo', sdp: null })

        log.info('clear previous stream')
        this.RTCSession.deviceId = null
        this.RTCSession.processRemoveStream(stream, pc, type)
        this.RTCSession.closeStream(stream)
        this.RTCSession.setStream(null, type, true)
        this.RTCSession.doOffer(pc)
    }else {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: VIDEO STREAM IS NULL");
    }
}

/**
 * to be host
 * @param data
 */
GsRTC.prototype.hostMeeting = function (data) {
    if(!data.contentType || !data.body){
        log.error('invalid parameters!')
        return
    }

    this.action = 'onHostMeeting'
    this.on('onHostMeeting', data.callback)
    this.sipStack.jsSipSendInfo(data.contentType, data.body)
}

/**
 * 开启桌面演示
 * @param data
 * data.stream: 要共享的视频流
 * data.callback
 */
GsRTC.prototype.shareScreen = function(data) {
    if(!this.RTCSession){
        log.error('shareScreen: invalid RTCSession parameters! ')
        return
    }

    let This = this
    let type = 'slides'
    let pc
    if(This.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    this.action = 'shareScreen'
    this.on('shareScreen', data.callback)
    this.sendInviteQueue.push({ action: 'shareScreen', sdp: null })

    function getMediaCallBack(event){
        if(event.stream){
            log.info('get stream success, ' + event.stream.id)
            let stream = event.stream
            stream.oninactive = function () {
                log.warn("user clicks the bottom share bar to stop sharing")
                let stream = This.RTCSession.getStream("slides", true)
                This.RTCSession.closeStream(stream);
                This.stopShareScreen({
                    type: 'slides',
                    callback: data.callback
                })
            }

            This.RTCSession.setStream(stream, type, true)
            This.RTCSession.processAddStream(stream, pc, type)
            This.RTCSession.doOffer(pc)
        }else {
            log.warn('Get present stream failed: ' + event.error)
            data.callback({error: event.error})
        }
    }

    let gumData = {
        streamType: 'screenShare',
        callback: getMediaCallBack
    }
    this.device.getMedia(gumData, data.constraints)
}

/**
 * 切换桌面共享源
 * @param data.type 类型："window"/"screen"/"whiteboard"/"tab"
 * @param data.callback 回调函数
 */
GsRTC.prototype.switchScreenSource = function(data) {
    if(!this.RTCSession){
        log.error('switchScreenSource: invalid RTCSession parameters! ')
        return
    }

    let This = this
    let type = 'slides'
    let previousStream = This.RTCSession.getStream(type, true)
    let pc
    if(This.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    this.action = 'switchScreenSource'
    this.on('switchScreenSource', data.callback)

    function getMediaCallBack(event){
        if(event.stream){
            let stream = event.stream
            stream.oninactive = function () {
                log.warn("user clicks the bottom share bar to stop sharing")
                let stream = This.RTCSession.getStream("slides", true)
                This.RTCSession.closeStream(stream);
                This.stopShareScreen({
                    type: 'slides',
                    callback: data.callback
                })
            }

            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){
                log.info('use replace track to switch presentation stream')
                This.RTCSession.processAddStream(stream, pc, type)
                data.callback({codeType: This.CODE_TYPE.ACTION_SUCCESS})
            }else {
                This.sendInviteQueue.push({ action: 'switchScreenSource', sdp: null })
                This.RTCSession.processRemoveStream(previousStream, pc)
                This.RTCSession.processAddStream(stream, pc, type)
                This.RTCSession.doOffer(pc)
            }

            This.RTCSession.closeStream(previousStream)
            This.RTCSession.setStream(stream, type, true)
        }else {
            log.error(event.error.toString())
            data.callback({error: event.error})
        }
    }

    let gumData = {
        streamType: 'screenShare',
        callback: getMediaCallBack
    }
    this.device.getMedia(gumData, data.constraints)
}

/**
 * 关闭桌面演示
 * @param data
 */
GsRTC.prototype.stopShareScreen = function(data) {
    if(!this.RTCSession){
        log.error('stopShareScreen: invalid RTCSession parameters! ')
        return
    }

    let type = 'slides'
    let stream = this.RTCSession.getStream(type, true)
    let pc
    if(this.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    if(stream){
        this.action = 'stopShareScreen'
        this.on('stopShareScreen', data.callback)
        this.sendInviteQueue.push({ action: 'stopShareScreen', sdp: null })

        log.info('clear previous stream')
        this.RTCSession.processRemoveStream(stream, pc, type)
        this.RTCSession.closeStream(stream)
        this.RTCSession.setStream(null, type, true)
        this.RTCSession.doOffer(pc)
    }
}

/**
 * 发送DTMF
 * @param data.digit 发送的内容
 * @param data.callback 回调函数
 */
GsRTC.prototype.sendDtmf = function(data){
    log.info('send dtmf digit:  ' + data.digit)
    if(!this.RTCSession){
        log.error('sendDtmf: invalid RTCSession parameters!')
        return
    }
    let type = 'audio'
    let pc
    if(this.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    let dtmfSender
    if(pc.getSenders){
        let senders = pc.getSenders();
        let audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');
        if (!audioSender) {
            log.warn('No local audio track to send DTMF with');
            return
        }else {
            dtmfSender = audioSender.dtmf;
        }

        if (dtmfSender && dtmfSender.canInsertDTMF) {
            log.info("prepare send digit: "+ data.digit);
            dtmfSender.insertDTMF(data.digit);
        }else {
            log.warn("DTMF function not available");
        }
    }else {
        log.warn('getSenders is not available by current browser version')
    }
}

/***
 * 调整下行分辨率
 * @param data
 */
GsRTC.prototype.adjustResolution = function(data){
    if(!this.RTCSession){
        log.error('adjustResolution: invalid RTCSession parameters!')
        return
    }
    if(!data || !data.height){
        log.error('adjustResolution: ERR_INVALID_PARAMETER_VALUE')
        return
    }
    log.info('adjust down resolution:  ' + data.height)

    let type = 'main'
    let pc
    if(this.enableMultiStream){
        pc = this.RTCSession.peerConnections['multiStreamPeer']
    }else {
        pc = this.RTCSession.peerConnections[type]
    }

    this.action = 'adjustResolution'
    this.on('adjustResolution', data.callback)
    this.setVideoResolution(this.getResolutionByHeight(data.height), 'EXPECT_RECV_RESOLUTION')

    this.sendInviteQueue.push({ action: 'adjustResolution', sdp: null })
    this.RTCSession.doOffer(pc)
}



GsRTC.prototype.CODE_TYPE = {
    // sip信令错误码 200- 699
    REGISTER_ERROR: 200,
    INVITE_ERROR: 201,

    //success code
    ACTION_SUCCESS: 999
}
/**
 * Function that subscribes a listener to an event.
 * @method on
 * @param {String} eventName The event.
 * @param {Function} callback The listener.
 */
GsRTC.prototype.on = function(eventName, callback) {
    if ('function' === typeof callback) {
        this.EVENTS[eventName] = this.EVENTS[eventName] || [];
        this.EVENTS[eventName].push(callback);
    } else {
        throw 'Provided parameter is not a function'
    }
};

/**
 * Function that unsubscribes listeners from an event.
 * @method off
 * @param {String} [eventName] The event.
 * - When not provided, all listeners to all events will be unsubscribed.
 * @param {Function} [callback] The listener to unsubscribe.
 * - When not provided, all listeners associated to the event will be unsubscribed.
 */
GsRTC.prototype.off = function(eventName, callback) {
    if (!(eventName && typeof eventName === 'string')) {
        this.EVENTS = {};
    } else {
        if (callback === undefined) {
            this.EVENTS[eventName] = [];
            return;
        }
        let arr = this.EVENTS[eventName] || [];

        // unsubscribe events that is triggered always
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === callback) {
                arr.splice(i, 1);
                break;
            }
        }
    }
};

/**
 * Function that triggers an event.
 * The rest of the parameters after the <code>eventName</code> parameter is considered as the event parameter payloads.
 * @method trigger
 */
GsRTC.prototype.trigger = function(eventName) {
    //convert the arguments into an array
    let args = Array.prototype.slice.call(arguments);
    let arr = this.EVENTS[eventName];
    args.shift(); //Omit the first argument since it's the event name
    if (arr) {
        // for events subscribed forever
        for (let i = 0; i < arr.length; i++) {
            try {
                if(arr[i].apply(this, args) === false) {
                    break;
                }
            } catch(error) {
                throw error;
            }
        }
    }
}

/**
 * Function that Determine whether it is nxx corresponding, such as: isResponseNxx(2, 200) ==> true
 * @param i
 * @param code Received status code, such 200
 * @returns {boolean}
 */
GsRTC.prototype.isNxx= function(i, code) {
    return ((i * 100) <= code && code <= ((i * 100) + 99));
}

/***
 * Function that Generate a UUID as the unique identifier of the peer ID
 * @returns {string}
 */
GsRTC.prototype.generateUUID = function() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r && 0x7 | 0x8)).toString(16);
    });
};

/***
 * get file url
 * @param file
 * @returns {*}
 */
GsRTC.prototype.getObjectURL = function(file) {
    let url = null;
    if (window.createObjectURL !== undefined) { // basic
        url = window.createObjectURL(file);
    } else if (window.URL !== undefined) { // mozilla(firefox)
        url = window.URL.createObjectURL(file);
    } else if (window.webkitURL !== undefined) { // webkit or chrome
        url = window.webkitURL.createObjectURL(file);
    }
    return url;
}

/***
 * Function that deep clone an object.
 * @param obj
 * @returns {*}
 */
GsRTC.prototype.objectDeepClone = function(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    let copy = function (data) {
        let copy = data.constructor();
        for (let attr in data) {
            if (data.hasOwnProperty(attr)) {
                copy[attr] = data[attr];
            }
        }
        return copy;
    };

    if (typeof obj === 'object' && !Array.isArray(obj)) {
        try {
            return JSON.parse( JSON.stringify(obj) );
        } catch (err) {
            return copy(obj);
        }
    }

    return copy(obj);
};

/***
 * Function that Depth comparison of two objects is completely equal
 * @param x
 * @param y
 * @returns {boolean}
 */
GsRTC.prototype.isObjectXExactlyEqualToY = function(x, y) {
    let i, l, leftChain, rightChain;

    function compare2Objects(x, y) {
        let p;

        // remember that NaN === NaN returns false
        // and isNaN(undefined) returns true
        if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
            return true;
        }

        // Compare primitives and functions.
        // Check if both arguments link to the same object.
        // Especially useful on the step where we compare prototypes
        if (x === y) {
            return true;
        }

        // Works in case when functions are created in constructor.
        // Comparing dates is a common scenario. Another built-ins?
        // We can even handle functions passed across iframes
        if ((typeof x === 'function' && typeof y === 'function') ||
            (x instanceof Date && y instanceof Date) ||
            (x instanceof RegExp && y instanceof RegExp) ||
            (x instanceof String && y instanceof String) ||
            (x instanceof Number && y instanceof Number)) {
            return x.toString() === y.toString();
        }

        // At last checking prototypes as good as we can
        if (!(x instanceof Object && y instanceof Object)) {
            return false;
        }

        if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
            return false;
        }

        if (x.constructor !== y.constructor) {
            return false;
        }

        if (x.prototype !== y.prototype) {
            return false;
        }

        // Check for infinitive linking loops
        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
            return false;
        }

        // Quick checking of one object being a subset of another.
        // todo: cache the structure of arguments[0] for performance
        for (p in y) {
            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                return false;
            } else if (typeof y[p] !== typeof x[p]) {
                return false;
            }
        }

        for (p in x) {
            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                return false;
            } else if (typeof y[p] !== typeof x[p]) {
                return false;
            }

            switch (typeof(x[p])) {
                case 'object':
                case 'function':

                    leftChain.push(x);
                    rightChain.push(y);

                    if (!compare2Objects(x[p], y[p])) {
                        return false;
                    }

                    leftChain.pop();
                    rightChain.pop();
                    break;

                default:
                    if (x[p] !== y[p]) {
                        return false;
                    }
                    break;
            }
        }

        return true;
    }

    if (arguments.length < 1) {
        log.warn('Need two or more arguments to compare')
        return true;
    }

    for (i = 1, l = arguments.length; i < l; i++) {
        leftChain = [];
        rightChain = [];

        if (!compare2Objects(arguments[0], arguments[i])) {
            return false;
        }
    }

    return true;
}

/**
 * Determine if the browser supports ReplaceTrack
 * @returns {boolean}
 */
GsRTC.prototype.isReplaceTrackSupport = function() {
    let browserDetails = this.getBrowserDetail()
    let result = false

    switch (browserDetails.browser) {
        case 'chrome':
            result = browserDetails.version >= 72
            break
        case 'opera':
            result = browserDetails.version >= 59
            break
        case 'firefox':
            result = browserDetails.version >= 59
            break
        case 'safari':
            result = browserDetails.version >= '12.1.1'
            break
        default:
            break
    }

    log.info(browserDetails.browser + ' ' + browserDetails.version +' version support replaceTrack : ' + result)
    return result
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
GsRTC.prototype.getBrowserDetail = function () {
    function extractVersion(uastring, expr, pos) {
        let match = uastring.match(expr);
        return match && match.length >= pos && parseInt(match[pos], 10);
    }

    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;
    result.UIVersion = null;
    result.chromeVersion = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
        result.browser = 'Not a browser.';
        return result;
    }

    // Edge.
    if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
        result.browser = 'edge';
        result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        result.UIVersion = navigator.userAgent.match(/Edge\/([\d.]+)/)[1]; //Edge/16.17017

    } // IE
    else if (!navigator.mediaDevices && (!!window.ActiveXObject || 'ActiveXObject' in window || navigator.userAgent.match(/MSIE (\d+)/) || navigator.userAgent.match(/rv:(\d+)/))) {
        result.browser = 'ie';
        if (navigator.userAgent.match(/MSIE (\d+)/)) {
            result.version = extractVersion(navigator.userAgent, /MSIE (\d+).(\d+)/, 1);
            result.UIVersion = navigator.userAgent.match(/MSIE ([\d.]+)/)[1]; //MSIE 10.6

        } else if (navigator.userAgent.match(/rv:(\d+)/)) {
            /*For IE 11*/
            result.version = extractVersion(navigator.userAgent, /rv:(\d+).(\d+)/, 1);
            result.UIVersion = navigator.userAgent.match(/rv:([\d.]+)/)[1]; //rv:11.0
        }

        // Firefox.
    } else if (navigator.mozGetUserMedia) {
        result.browser = 'firefox';
        result.version = extractVersion(navigator.userAgent,
            /Firefox\/(\d+)\./, 1);
        result.UIVersion = navigator.userAgent.match(/Firefox\/([\d.]+)/)[1]; //Firefox/56.0

        // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
        // Chrome, Chromium, Webview, Opera, Vivaldi all use the chrome shim for now
        var isOpera = navigator.userAgent.match(/(OPR|Opera).([\d.]+)/) ? true : false;
        //var isVivaldi = navigator.userAgent.match(/(Vivaldi).([\d.]+)/) ? true : false;
        if (isOpera) {
            result.browser = 'opera';
            result.version = extractVersion(navigator.userAgent, /O(PR|pera)\/(\d+)\./, 2);
            result.UIVersion = navigator.userAgent.match(/O(PR|pera)\/([\d.]+)/)[2]; //OPR/48.0.2685.39
            if (navigator.userAgent.match(/Chrom(e|ium)\/([\d.]+)/)[2]) {
                result.chromeVersion = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            }
        }/* else if (isVivaldi) {
          result.browser = 'vivaldi';
          result.version = extractVersion(navigator.userAgent,
                                            /(Vivaldi)\/(\d+)\./, 2);
          result.UIVersion = navigator.userAgent.match(/Vivaldi\/([\d.]+)/)[1]; //Vivaldi/1.93.955.38
     }*/ else {
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            result.UIVersion = navigator.userAgent.match(/Chrom(e|ium)\/([\d.]+)/)[2]; //Chrome/61.0.3163.100
        }

        // Safari or unknown webkit-based
        // for the time being Safari has support for MediaStreams but not webRTC
        //Safari without webRTC and with partly webRTC support
    } else if ((!navigator.webkitGetUserMedia && navigator.userAgent.match(/AppleWebKit\/([0-9]+)\./)) || (navigator.webkitGetUserMedia && !navigator.webkitRTCPeerConnection)) {
        // Safari UA substrings of interest for reference:
        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)
        // - safari UI version:        Version/9.0.3 (unique to Safari)
        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)
        //
        // if the webkit version and safari UI webkit versions are equals,
        // ... this is a stable version.
        //
        // only the internal webkit version is important today to know if
        // media streams are supported
        //
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
            result.UIVersion = navigator.userAgent.match(/Version\/([\d.]+)/)[1]; //Version/11.0.1

        } else { // unknown webkit-based browser.
            result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.';
            return result;
        }
        // Default fallthrough: not supported.
    } else {
        result.browser = 'Not a supported browser.';
        return result;
    }

    return result;
}

/**
 * Determine if the input string is empty or all spaces
 * @param str
 * @returns {boolean}
 */
GsRTC.prototype.tskStringIsNullOrEmpty = function (str) {
    let result
    if(!str || str === ""){
        result = true
    }else {
        let regu = "^[ ]+$";
        let re = new RegExp(regu);
        result = re.test(str)
    }
    return result;
}

/**
 * is string or not
 * @param str
 * @returns {boolean}
 */
GsRTC.prototype.tskStringIsString = function(str) {
    return (str instanceof String || typeof str == "string");
}
/*Log Debug Start*/
var log = { };
log.debug = window.debug("SipStack:DEBUG");
log.log   = window.debug("SipStack:LOG");
log.info  = window.debug("SipStack:INFO");
log.warn  = window.debug("SipStack:WARN");
log.error = window.debug("SipStack:ERROR");
/*Log Debug End*/

/**
 * Define the SipStack class
 * @param conf
 * @param callback
 * @param gsRTC
 * @returns {SipStack|*}
 * @constructor
 */
let SipStack = function (conf, callback, gsRTC) {
    if(this instanceof SipStack){
        this.initialized = false
        this.conf = {}
        this.gsRTC = gsRTC

        this.jsSipParser = jsSipParser
        this.jsSipInit = jsSipInit
        this.setLogLevel = setLogLevel
        this.jsSipSetConfig = jsSipSetConfig
        this.jsSipStart = jsSipStart
        this.jsSipSendRegister = jsSipSendRegister
        this.jsSipSendInvite = jsSipSendInvite
        this.jsSipSendReInvite = jsSipSendReInvite
        this.jsSipSendRsp = jsSipSendRsp
        this.jsSipSendAck = jsSipSendAck
        this.addHeaderList = addHeaderList
        this.jsSipSendBye = jsSipSendBye

        this.jsSipSendInfo = function (contentType, body) {
            // add header list info first
            addHeaderList(contentType, body);
            jsSipSendInfo()
        }

        this.init(conf, callback)
    }else {
        return new SipStack(conf, callback)
    }
}

/**
 * sip init
 * @param conf: {
 *  userId: userId,
 *  password: password,
 *  proxyuri: proxyuri,
 *  websocketUrl: websocketUrl,
 *  host: host,
 *  userAgent: userAgent,
 *  displayName: displayName,
 *  organization: organization,
 *  allocate: allocate,
 * }
 */
SipStack.prototype.init = function (conf, callback) {
    // Parameter check
    log.info('start sip init!')
    let data = Object.keys(conf);
    if(!data.length){
        throw new Error("ERR_INVALID_PARAMETER_VALUE: null configuration value");
    }

    if (conf.sipRealm && !GsRTC.prototype.tskStringIsString(conf.sipRealm)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof conf.sipRealm + "' not a valid type for sipRealm. String is expected");
    }
    if (conf.sipImpi && !GsRTC.prototype.tskStringIsString(conf.sipImpi)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof conf.sipImpi + "' not a valid type for sipImpi. String is expected");
    }
    if (conf.sipPasswd && !GsRTC.prototype.tskStringIsString(conf.sipPasswd)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof conf.sipPasswd + "' not a valid type for sipPasswd. String is expected");
    }
    if (conf.sipDispalyName && !GsRTC.prototype.tskStringIsString(conf.sipDispalyName)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof conf.sipDispalyName + "' not a valid type for sipDispalyName. String is expected");
    }
    if (conf.userAgent && !GsRTC.prototype.tskStringIsString(conf.userAgent)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof conf.userAgent + "' not a valid type for userAgent. String is expected");
    }
    if (conf.organization && !GsRTC.prototype.tskStringIsString(conf.organization)) {
        log.info(typeof conf.organization + "' not a valid type for organization. set default 'Grandstream' value");
        conf.organization = 'Grandstream'
    }
    if (conf.host && !GsRTC.prototype.tskStringIsString(conf.host)) {
        log.info(typeof conf.host + " not a valid type for host. set default df7jal23ls0d.invalid value")
        conf.host = 'df7jal23ls0d.invalid'
    }

    try {
        /* 初始化 */
        this.jsSipInit()
        /* 设置日志级别 */
        this.setLogLevel(2)
        /* 配置WebSocket URL */
        this.jsSipSetConfig(0, '1')
        /* 配置用户名 */
        this.jsSipSetConfig(1, conf.sipImpi)
        /* 配置密码 */
        this.jsSipSetConfig(2, conf.sipPasswd)
        /* 配置proxy URL */
        this.jsSipSetConfig(3, conf.sipRealm)
        /* 配置host */
        this.jsSipSetConfig(5, conf.host)
        /* 配置User-Agent */
        this.jsSipSetConfig(6, conf.userAgent)
        /* 配置displayName */
        this.jsSipSetConfig(7, conf.sipDispalyName)
        /* 配置organization */
        this.jsSipSetConfig(8, conf.organization)
        /* 开始sip */
        this.jsSipStart()

        this.conf = conf
        this.initialized = true
    }catch (e) {
        callback(e)
        throw new Error(e);
    }
}

/**
 * send sip message
 * @param message content such as sdp
 * @param contentType  default 'application/sdp'
 */
SipStack.prototype.sendSipMessage = function (message, contentType) {
    if(!this.initialized){
        throw new Error("SIP Stack not initialized yet. Please init first");
    }

    contentType = contentType || 'application/sdp'
    if(this.gsRTC.isRecvRequest){
        log.info('send response')
        this.jsSipSendRsp(this.gsRTC.transaction, 200, contentType, message)
        this.gsRTC.isRecvRequest = false
    }else {
        log.info('send request')
        this.gsRTC.inviteProcessing = true
        if(this.gsRTC.isSendReInvite){
            log.warn('send re-invite')
            this.jsSipSendReInvite(contentType, message)
        }else {
            log.warn('send invite')
            this.jsSipSendInvite(this.conf.allocate , contentType, message);
        }
    }
}










/*Log Debug Start*/
var log = {};
log.debug = window.debug("JSEP:DEBUG");
log.log = window.debug("JSEP:LOG");
log.info = window.debug("JSEP:INFO");
log.warn = window.debug("JSEP:WARN");
log.error = window.debug("JSEP:ERROR");
/*Log Debug End*/

/**
 * create PeerConnection instance
 * @param config
 * @param gsRTC
 * @constructor
 */
let PeerConnection = function (config, gsRTC) {
    this.gsRTC = gsRTC
    this.conf = config
    this.deviceId = null
    this.peerConnections = []
}

/**
 * create PeerConnection instance
 */
PeerConnection.prototype.createRTCSession = async function (conf) {
    log.info('Get lo: create webRTC session')
    let This = this
    try {
        let sessionsConfig = conf.sessionsConfig ? conf.sessionsConfig : {}
        if (sessionsConfig) {
            if (!this.peerConnections) {
                this.peerConnections = []
            }
            for (let i = 0; i < sessionsConfig.length; i++) {
                let type = sessionsConfig[i]
                this.peerConnections[type] = this.createPeerConnection(type, conf)
                // for wfu add stream
                // let pc = this.peerConnections[type]
                // let stream
                // if(type === 'audio'){
                //     stream = await navigator.mediaDevices.getUserMedia({audio: true, video: false})
                //     console.warn(pc.type + " add stream: ", stream.id)
                // }else if(type === 'main'){
                //     stream = await navigator.mediaDevices.getUserMedia({audio: false, video: {width: 640, height: 360}})
                //     console.warn(pc.type + " add stream: ", stream.id)
                //
                // }else if(type === 'video1'){
                //     // stream = await navigator.mediaDevices.getUserMedia({audio: false, video: {width: 1280, height: 720}})
                //     // console.warn(pc.type + " add stream: ", stream.id)
                // }else if(type === 'slides'){
                //     let constraints = {
                //         audio: false,
                //         video: {
                //             width: { max: 1920, },
                //             height: { max: 1080,},
                //             frameRate: { max: 15,}
                //         }
                //     };
                //
                //     if('getDisplayMedia' in window.navigator){
                //         stream = await navigator.getDisplayMedia(constraints)
                //     }else if('getDisplayMedia' in window.navigator.mediaDevices){
                //         stream = await navigator.mediaDevices.getDisplayMedia(constraints)
                //     }else {
                //         log.warn("The browser does not support the getDisplayMedia interface.");
                //     }
                //
                // }
                //
                // if(stream){
                //     console.warn(pc.type + ' add stream')
                //     This.setMediaElementStream(stream, type, true)
                //     pc.addStream(stream)
                // }

                if(type === 'main'){
                    log.warn('add '+ type + ' stream')
                    let stream = getCaptureStream(type)
                    log.info('get stream : ', stream.id)
                    This.setStream(stream, type, true)

                    let pc = this.peerConnections[type]
                    pc.addStream(stream)
                }

                if(type === 'slides'){
                    log.warn('add '+ type + ' stream')
                    let stream = getSlidesCaptureStream(type)
                    log.info('get stream : ', stream.id)
                    This.setStream(stream, type, true)

                    let pc = this.peerConnections[type]
                    pc.addStream(stream)
                }

                this.doOffer(this.peerConnections[type])
            }
        } else {
            log.warn('can not create RTCSession with conf is null')
        }
    } catch (e) {
        log.error(e)
    }
}

/**
 * create webRTC multiStream Peer connection
 * @param conf
 */
PeerConnection.prototype.createMultiStreamRTCSession = function(conf){
    log.info('create webRTC multiStream Peer connection')
    try {
        let This = this
        let sessionsConfig = conf.sessionsConfig ? conf.sessionsConfig : ['multiStreamPeer']
        let type = sessionsConfig[0]

        this.peerConnections[type] = This.createPeerConnection(type, conf)
        let pc = this.peerConnections[type]
        // create transceiver
        if(RTCPeerConnection.prototype.addTransceiver){
            log.info('use addTransceiver to add transceiver ');
            // add audio Transceiver to keep audio media first
            pc.addTransceiver('audio')
            pc.addTransceiver('video')
            pc.addTransceiver('video')
        }else {
            log.info('use captureStream to add transceiver ');
            // get two video stream
            let streamArray = this.getCaptureStream(2)
            for(let i = 0; i<streamArray.length; i++){
                let stream = streamArray[i]
                log.info('add stream to peerConnection: ' + stream.id)
                pc.addStream(stream)
                // stream.getTracks().forEach(track => pc.addTrack(track, stream));
            }
        }

        This.doOffer(pc)
    }catch (e) {
        log.error(e)
    }
}

/**
 * Listen for stream change events
 * @param pc
 */
PeerConnection.prototype.subscribeStreamEvents = function (pc) {
    let This = this
    if (this.gsRTC.isReplaceTrackSupport()) {
        pc.ontrack = function (evt) {
            log.info('__on_add_track')
            let type = This.gsRTC.enableMultiStream ? This.getTypeByMid(evt.transceiver.mid) : pc.type
            This.setStream(evt.streams[0], type, false)

            evt.streams[0].onremovetrack = function (evt) {
                log.info('__on_remove_track')
                let type = This.gsRTC.enableMultiStream ? This.getTypeByStreamId(evt.currentTarget.id) : pc.type
                This.setStream(null, type, false)
            }
        }
    } else {
        pc.onaddstream = function (evt) {
            log.info('__on_add_stream')
            let type = pc.type
            This.setStream(evt.stream, type, false)
        }
        pc.onremovestream = function (evt) {
            log.info('__on_remove_stream')
            let type = This.gsRTC.enableMultiStream ? This.getTypeByStreamId(evt.currentTarget.id) : pc.type
            This.setStream(null, type, false)
        }
    }
}

/**
 * create peerConnection
 * @param type
 * @param conf
 * @returns {RTCPeerConnection}
 */
PeerConnection.prototype.createPeerConnection = function (type, conf) {
    log.info("Create peerConnection : " + type)
    let This = this
    let pc
    let config = {iceTransportPolicy: 'all'}
    let iceservers = conf.iceServer;
    let RTCpeerConnectionOptional = this.conf.RTCpeerConnectionOptional;
    // chrome 72 版本默认unified-plan， 65版本开始unified-plan为实验性质标志，通过sdpSemantics: unified-plan 启用
    if (RTCpeerConnectionOptional === null || RTCpeerConnectionOptional === undefined) {
        RTCpeerConnectionOptional = { optional: [ { 'pcName': "PC_" + type + "_" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': false } ] };
    }
    else if(RTCpeerConnectionOptional && RTCpeerConnectionOptional.optional && RTCpeerConnectionOptional.optional.length > 0){
        RTCpeerConnectionOptional.optional.push( { 'pcName': "PC_" + type + "_" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': false });
    }
    // config["sdpSemantics"] = "unified-plan";
    if(iceservers === null || iceservers === undefined || iceservers.length === 0){
        log.info('iceServers is null')
    }else {
        log.info('icesServer ' + This.conf.iceServer)
        config.iceServers = conf.iceServer;
    }
    if(This.gsRTC.getBrowserDetail().browser !== 'firefox'){
        // firefox not support no need set sdpSemantics config
        config.sdpSemantics = "unified-plan";
    }
    log.warn("config: ", config)
    log.warn("RTCpeerConnectionOptional: ", RTCpeerConnectionOptional)

    pc = new window.RTCPeerConnection(config, RTCpeerConnectionOptional)
    pc.type = type;
    pc.pcName = "PC_" + type + "_" + Math.random().toString(36).substr(2)
    pc.peerId = Math.random().toString(36).substr(2)
    pc.action = null
    pc.iceFailureNum = 0
    pc.isIceFailed = false
    pc.isLocalSdpPending = true;
    this.subscribeStreamEvents(pc)

    // 服务器回复的200 ok中，audio默认 sendrecv，不添加流的话会报错："Answer tried to set recv when offer did not set send"
    if((type === 'audio' || type === 'multiStreamPeer') && !This.gsRTC.MEDIA_STREAMS.LOCAL_AUDIO_STREAM){
        if(This.gsRTC.getBrowserDetail().browser === 'firefox' && This.gsRTC.getBrowserDetail().version > 60){
            log.warn('firefox get fake stream')
            function getMediaCallBack(data){
                if(data.stream){
                    log.info('get fake stream success')
                    data.stream.getTracks().forEach(function(track) {
                        track.enabled = false; //Mute this track, incase the audio send out.
                    });
                    This.processAddStream(data.stream , pc, 'audio');
                }else {
                    log.info(data)
                    log.error(data.error)
                }
            }
            let conf = { streamType: 'audio', callback: getMediaCallBack }
            let constraints =  { audio: true, video: false, fake: true }
            this.gsRTC.device.getMedia(conf, constraints)
        }
    }

    pc.onicecandidate = function (event) {
        This.onIceCandidate(pc, event);
    };

    pc.onsignalingstatechange = function () {
        This.onSignalingStateChange(pc)
    }

    pc.onicegatheringstatechange = function () {
        This.onIceGatheringStateChange(pc)
    }

    pc.oniceconnectionstatechange = function () {
        This.onIceConnectionStateChange(pc);
    }

    pc.onconnectionstatechange = function (event) {
        This.onConnectionStateChange(pc, event)
    }

    return pc
}

/**
 * create localDescription: create offer and setLocalDescription
 * @param pc
 * @returns {Promise<void>}
 */
PeerConnection.prototype.doOffer = async function (pc) {
    let This = this
    this.gsRTC.isProcessingInvite = true
    log.info("create sdp( PC: " + pc.type + " )");
    // Added checks to ensure that connection object is defined first
    if (!pc) {
        log.info('RTCSessionDescription offer, Dropping of creating of offer as connection does not exists');
        return;
    }

    // Added checks to ensure that state is "stable" if setting local "offer"
    if (pc.signalingState !== 'stable') {
        log.info("Dropping of creating of offer as signalingState is not " + pc.signalingState);
        return;
    }
    log.info('Creating offer');

    pc.offerConstraints = {
        offerToReceiveAudio: pc.type === 'multiStreamPeer' ? true : pc.type === 'audio',
        offerToReceiveVideo: pc.type === 'multiStreamPeer' ? true : pc.type !== 'audio'
    }

    async function onCreateOfferSuccess(desc) {
        log.log(`Offer from ` + pc.type + ` \n${desc.sdp}`);
        log.info('start setLocalDescription');
        try {
            await pc.setLocalDescription(desc);
            This.setLocalDescriptionSuccess(pc);
        } catch (error) {
            This.onSetLocalDescriptionError(error);
        }
    }

    try {
        log.log(pc.type + ' createOffer start');
        const offer = await pc.createOffer(pc.offerConstraints);
        await onCreateOfferSuccess(offer);
    } catch (error) {
        This.onCreateLocalDescriptionError(error);
    }
}

/***
 * create localDescription: create answer and setLocalDescription
 * @param pc
 * @returns {Promise<void>}
 */
PeerConnection.prototype.doAnswer = async function (pc) {
    let This = this
    pc.isLocalSdpPending = true
    this.gsRTC.isProcessingInvite = true
    log.info("prepare do answer")
    // Added checks to ensure that connection object is defined first
    if (!pc) {
        log.info('RTCSessionDescription offer Dropping of creating of answer as connection does not exists');
        return;
    }

    // Added checks to ensure that state is "stable" if createAnswer
    if (pc.signalingState !== 'have-remote-offer') {
        log.info("Dropping of creating of offer as signalingState is not " + pc.signalingState);
        return;
    }

    async function onCreateAnswerSuccess(desc) {
        log.info(pc.type + `createAnswerSuccess`);
        log.info(pc.type + ' setLocalDescription start');
        try {
            await pc.setLocalDescription(desc);
            This.setLocalDescriptionSuccess(pc);
        } catch (e) {
            This.onSetLocalDescriptionError(error);
        }
    }

    log.info('createAnswer start');
    try {
        const answer = await pc.createAnswer();
        await onCreateAnswerSuccess(answer);
    } catch (e) {
        This.onCreateLocalDescriptionError(e);
    }
}

/**
 * fired when peerConnection set localDescription success
 * @returns {boolean}
 */
PeerConnection.prototype.setLocalDescriptionSuccess = function (pc) {
    log.info('setLocalDescription success ( ' + pc.type + ')')
    // If you don't recollect the dates, you need to judge here whether you can send invite or 200 ok
    if (pc.iceGatheringState === 'complete') {
        pc.isLocalSdpPending = false
        log.info("onSetLocalDescriptionSuccess send invite( PC: " + pc.type + " )");
        this.onIceGatheringCompleted();
    }
}

/**
 * fired when peerConnection set localDescription failed
 * @param error
 */
PeerConnection.prototype.onSetLocalDescriptionError = function (error) {
    log.error(`Failed to set local description: ${error}`);
}

/**
 * fired when peerConnection createOffer or createAnswer failed
 * @param error
 */
PeerConnection.prototype.onCreateLocalDescriptionError = function (error) {
    log.error(`Failed to create session description: ${error}`);
}

/**
 * setRemoteDescription when answer sdp from the server
 * @param sdp
 */
PeerConnection.prototype.setRemote = function (sdp) {
    let This = this

    async function setRo(pc, sdp) {
        try {
            log.info('setRemoteDescription (' + pc.type + ')')
            let roSdp = This.gsRTC.getSdpByType(pc.type, sdp)
            log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)
            let desc = new window.RTCSessionDescription({type: 'answer', sdp: roSdp})
            await pc.setRemoteDescription(desc)
            This.setRemoteDescriptionSuccess(pc)
        } catch (e) {
            This.onSetRemoteDescriptionError(e);
        }
    }

    for (let key in this.peerConnections) {
        let pc = this.peerConnections[key]
        if (pc.signalingState !== 'have-local-offer') {
            log.info(pc.type + " dropping of setRemoteDescription as signalingState is " + pc.signalingState);
            continue;
        }
        setRo(pc, sdp)
    }
}

/**
 * set remote desc success
 * @param pc
 */
PeerConnection.prototype.setRemoteDescriptionSuccess = function (pc) {
    log.info('setRemoteDescription success ( ' + pc.type + ')')
    this.gsRTC.inviteProcessing = false
    let stream = this.getStream(pc.type, true)
    if (pc.type === 'main' && stream && stream.active === true && !window.wfu) {
        log.info(pc.type + " prepare get new stream")
        this.getNewStream(pc)
    }

    // ice restart的时候，处理完前面的invite之后再处理后面的invite
    for(let i = 0; i<this.gsRTC.sendInviteQueue.length; i++){
        let item = this.gsRTC.sendInviteQueue[i]
        if(item.type === pc.type && item.action ===  pc.action){
            this.gsRTC.sendInviteQueue.splice(i, 1)
            pc.action = null
            if(this.gsRTC.sendInviteQueue && this.gsRTC.sendInviteQueue.length > 0){
                this.gsRTC.action = this.gsRTC.sendInviteQueue[0].action
                let type =  this.gsRTC.sendInviteQueue[0].type
                let pc = this.gsRTC.RTCSession.peerConnections[type]
                this.doOffer(pc)
            }
        }
    }
}

/**
 * set remote desc error
 * @param error
 */
PeerConnection.prototype.onSetRemoteDescriptionError = function (error) {
    log.error(`Failed to set remote description: ${error}`);
    console.error(error)
}

/**
 * handle server re-invite
 * @param sdp
 */
PeerConnection.prototype.handleOffer = function (sdp) {
    let This = this

    async function setRo(pc) {
        try {
            log.info('setRemoteDescription (' + pc.type + ')')
            let roSdp = This.gsRTC.getSdpByType(pc.type, sdp)
            log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)
            let desc = new window.RTCSessionDescription({type: 'offer', sdp: roSdp})
            await pc.setRemoteDescription(desc)
            This.setRemoteDescriptionSuccess(pc)
            This.doAnswer(pc)
        } catch (e) {
            This.onSetRemoteDescriptionError(e);
        }
    }

    for (let key in this.peerConnections) {
        let pc = this.peerConnections[key]
        if (pc.signalingState !== 'stable') {
            log.info(pc.type + " dropping of creating of offer as signalingState is not stable");
            continue;
        }

        let newRo = This.gsRTC.getSdpByType(pc.type, sdp)
        let currentRo = pc.currentRemoteDescription ? pc.currentRemoteDescription : pc.remoteDescription
        // Compare the sdp of each peerConnection after receiving sdp each time
        if (!This.gsRTC.isObjectXExactlyEqualToY(newRo, currentRo)) {
            setRo(pc)
        } else {
            log.info('current remote description is not change')
        }
    }
}

/***
 * JSEP rollback operation for 491 invite conflict
 * plan one: setRemoteDescription direct
 */
PeerConnection.prototype.rollbackOperation = async function () {
    log.info('jsep rollback operation')
    var This = this

    // setRemoteDescription direct
    async function setRemote(pc) {
        log.warn(pc.type + " peerConnection signalingState: " + pc.signalingState)
        try {
            let sdp = pc.currentRemoteDescription ? pc.currentRemoteDescription : pc.remoteDescription
            let description = new window.RTCSessionDescription(sdp)
            await pc.setRemoteDescription(description)
            This.setRemoteDescriptionSuccess(pc)
        } catch (e) {
            This.onSetRemoteDescriptionError(error);
        }
    }

    for (let i = 0; i < This.peerConnections.length; i++) {
        let pc = This.peerConnections[i]
        if (pc.signalingState === 'have-local-offer') {
            setRemote(pc)
        }
    }

    log.info('set isProcessingInvite to false')
    This.gsRTC.isProcessingInvite = false
}

/**
 * get all peerConnection combine sdp
 * @returns {*}
 */
PeerConnection.prototype.getDecorateSdp = function () {
    log.info('get local peers combine sdp')
    let This = this
    let sdp
    let sdpArray = [];
    let parseSdp = null

    if(This.gsRTC.enableMultiStream === true){
        log.warn("decorate multi stream Peer sdp ")
        let pc = This.peerConnections['multiStreamPeer']
        let subSDP = pc.localDescription.sdp;
        sdp = This.gsRTC.decorateMultiStreamSdp(subSDP)
    }else {
        for (let i in This.peerConnections) {
            let pc = This.peerConnections[i]
            let subSDP = pc.localDescription.sdp;

            // save original mid before send invite,
            This.gsRTC.saveMidBeforeSendInvite(subSDP, pc.type)

            if(pc) {
                if(pc.type === 'audio'){
                    log.warn('set audio recvonly to sendrecv for test!')
                    subSDP = subSDP.replace(/a=recvonly/g, "a=sendrecv")
                }

                // video1 for wfu
                if(pc.type === 'main' || pc.type === 'video1'){
                    parseSdp = SDPTools.parseSDP(subSDP)
                    SDPTools.removeCodecByPayload(parseSdp, 0, [98, 99,127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])
                    // set resolution of sdp
                    let resolution = this.gsRTC.getVideoResolution('EXPECT_RECV_RESOLUTION')
                    if(resolution.width && resolution.height){
                        // set expected receive resolution
                        parseSdp = This.gsRTC.setResolutionOfSdp(parseSdp, resolution.width, resolution.height)
                    }
                    subSDP = SDPTools.writeSDP(parseSdp)
                    // Add media line identification field
                    subSDP = subSDP + "a=content:main\n"
                }
                if(pc.type === 'slides'){

                    parseSdp = SDPTools.parseSDP(subSDP)
                    SDPTools.removeCodecByPayload(parseSdp, 0, [98, 99, 127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])
                    subSDP = SDPTools.writeSDP(parseSdp)
                    // Add media line identification field
                    subSDP = subSDP + "a=content:slides\n"

                    if(!window.wfu){
                        // set direction recvonly if not share screen
                        let stream = This.getStream('slides', true)
                        if(stream){
                            subSDP = subSDP.replace(/a=sendrecv/g, "a=sendonly");
                            subSDP = subSDP.replace(/a=recvonly/g, "a=sendonly");
                        }else {
                            subSDP = subSDP.replace(/a=sendrecv/g, "a=recvonly");
                        }
                    }
                }
            }
            sdpArray.push(subSDP);
        }
        sdp = SDPTools.mergeSDP(sdpArray);
    }

    return sdp
}

/**
 * decorate remote sdp
 * @param sdp
 */
PeerConnection.prototype.commonDecorateRo  = function(sdp){
    if(!sdp){
        log.error("commonDecorateRo: Invalid Argument");
        return;
    }
    log.info('commonDecorateRo')
    this.setRemote(sdp)
}

/**
 * After receiving 200 ok, adjust the upstream according to the resolution required by the server
 * @param pc
 * @returns {boolean}
 */
PeerConnection.prototype.getNewStream = function (pc) {
    let This = this
    let stream = this.getStream('main', true)
    let isSend = pc.localDescription.sdp.indexOf('sendrecv') >= 0 || pc.localDescription.sdp.indexOf('sendonly') >= 0
    if(stream && stream.active && isSend === true){
        let upResolution = This.gsRTC.getVideoResolution('CURRENT_UP_RESOLUTION')
        let parseSdp = SDPTools.parseSDP(pc.remoteDescription.sdp)
        let askedResolution = This.gsRTC.getResolutionBySdp(parseSdp)

        log.info("resolution(from current sdp): " + askedResolution.height)
        if(upResolution){
            log.info("resolution(from previous sdp): " + upResolution.height);
        }else {
            log.info("resolution(from previous sdp): null");
        }

        let constraints = null
        if(askedResolution && askedResolution.width && askedResolution.height){
            if(!upResolution || upResolution.height !== askedResolution.height){
                let frameRate =  This.gsRTC.getFramerateBySdp(parseSdp)
                let browserDetails = This.gsRTC.getBrowserDetail()
                log.info('adjust resolution!')
                // applyConstraints support chrome64+, firefox all version
                if (stream && stream.active === true && ((
                  browserDetails.browser === 'chrome' && browserDetails.version >= 64)
                  || (browserDetails.browser === 'opera' && browserDetails.chromeVersion >= 64)
                  || browserDetails.browser === 'firefox'))
                {
                    constraints = {
                        frameRate: {
                            max: frameRate ? frameRate: 30,
                            ideal: frameRate ? frameRate: 30
                        },
                        width: {
                            max: askedResolution.width,
                            ideal: askedResolution.width
                        },
                        height: {
                            max: askedResolution.height,
                            ideal: askedResolution.height
                        }
                    }

                    log.info('applyConstraints constraints' + JSON.stringify(constraints, null, '    '))
                    let localVideoTrack = stream.getVideoTracks()[0];
                    localVideoTrack.applyConstraints(constraints).then(function () {
                        log.info('applyConstraints succeed');
                        This.setStream(stream, 'main', true)
                    }).catch(function (error) {
                        log.error("applyConstraints Error: " , error);
                    })
                }else {
                    // getUserMedia 重新取流后需要re-invite，否则视频会loading，因为ssrc已经改变了
                    log.info('getUserMedia')
                    let type = 'main'
                    function getStreamCallback(event){
                        let newStream = event.stream
                        if(newStream){
                            log.info('getUserMedia succeed ', newStream);
                            This.processRemoveStream(stream, pc, type)
                            This.processAddStream(newStream, pc, type)
                            This.setStream(newStream, type, true)
                            This.doOffer(pc)
                        }else if(event.error){
                            log.error(event.error)
                        }
                    }

                    // TODO：这里需要添加deviceId， 因为多个摄像头的时候，取流时可能会换摄像头
                    let gumData = {
                        streamType: 'video',
                        callback: getStreamCallback
                    }
                    let param = {
                        streamType: 'video',
                        constraintsKeyWord: 'exact',
                        deviceId: This.deviceId,
                        frameRate: frameRate,
                        width: askedResolution.width,
                        height: askedResolution.height,
                    }

                    if(this.gsRTC.device){
                        constraints = this.gsRTC.device.getConstraints(param)
                        this.gsRTC.device.getMedia(gumData, constraints)
                    }
                }

                This.gsRTC.setVideoResolution(askedResolution,'CURRENT_UP_RESOLUTION')
            }else {
                log.info("handleOffer: resolution is just right");
            }
        }else {
            log.warn('server asked resolution is null')
            return false
        }

        return true
    }else {
        log.warn('camera is not open, clear local stream')
        This.setStream(null, 'main', true)
        return false
    }
}


GsRTC.prototype.HTML_MEDIA_ELEMENT = {
    localAudio: null,
    localVideo: null,
    localPresentVideo: null,
    localVideoShare: null,
    remoteAudio: null,
    remoteVideo: null,
    remotePresentVideo: null,
    remoteVideoShare: null,
}

/**
 * save local && remote stream
 * @type {{LOCAL_PRESENT_STREAM: null, LOCAL_VIDEO_SHARE_STREAM: null, REMOTE_VIDEO_SHARE_STREAM: null, LOCAL_AUDIO_STREAM: null, REMOTE_PRESENT_STREAM: null, REMOTE_AUDIO_STREAM: null, LOCAL_VIDEO_STREAM: null, REMOTE_VIDEO_STREAM: null}}
 */
GsRTC.prototype.MEDIA_STREAMS = {
    LOCAL_AUDIO_STREAM: null,
    REMOTE_AUDIO_STREAM: null,
    LOCAL_VIDEO_STREAM: null,
    REMOTE_VIDEO_STREAM: null,
    LOCAL_PRESENT_STREAM: null,
    REMOTE_PRESENT_STREAM: null,
    LOCAL_VIDEO_SHARE_STREAM : null,
    REMOTE_VIDEO_SHARE_STREAM : null
};

/**
 * Save upstream or downstream resolution
 * @type {{EXPECT_RECV_RESOLUTION: {}, CURRENT_UP_RESOLUTION: {}}}
 */
GsRTC.prototype.VIDEO_RESOLUTION = {
    CURRENT_UP_RESOLUTION: {},
    EXPECT_RECV_RESOLUTION: {},
}

GsRTC.prototype.MID_OBJ = {
    AUDIO_MID: {
        ORIGINAL_MID: null,
        MODIFIED_MID: null
    },
    MAIN_MID: {
        ORIGINAL_MID: null,
        MODIFIED_MID: null
    },
    SLIDES_MID: {
        ORIGINAL_MID: null,
        MODIFIED_MID: null
    },
}


/**
 * Event registration
 */
GsRTC.prototype.eventBindings = function(){
    log.info('event binding.')
    this.on('onEventStack', this.eventStack)
}

/**
 * event stack 所有回调调用触发的地方
 * @param event
 */
GsRTC.prototype.eventStack = function(event){
    switch (event.type) {
        case 'GET_LO_SUCCESS':
            if(this.inviteProcessing === false){
                let sdp = this.RTCSession.getDecorateSdp()
                // Save the session version, plus one for each re-invite
                this.saveSDPSessionVersion(sdp)
                if(window.wfu){
                    console.warn("sendMessage sdp\n" ,sdp)
                    this.sokect.sendMessage(sdp)
                }else {
                    this.sipStack.sendSipMessage(sdp)
                }
            }else {
                log.info('exist invite in processing..')
            }

            break
        case '491_INVITE_CONFLICT':
            this.RTCSession.rollbackOperation()
            break
        default:
            log.info('eventStack null: ', event.type)
            break
    }
}

GsRTC.prototype.handleIncomingMessage = function (event) {
    /* Server reply message */
    if(event.data.isrsp){
        log.info("receive server response: " + event.data.method + ' , code ' + event.data.code)
        let code = event.data.code
        switch (event.data.method) {
            case 'REGISTER':
                if(this.EVENTS[this.action]){
                    this.trigger(this.action, {codeType: code});
                }
                break
            case 'INVITE':
                if(code === 200){
                    this.sipStack.jsSipSendAck()
                    this.isSendReInvite = true
                    let sdp = event.data.body
                    this.RTCSession.commonDecorateRo(sdp)

                    if(this.EVENTS[this.action]){
                        this.sendInviteQueue.shift()
                        this.trigger(this.action, {codeType: code});
                    }
                }else if(code === 491){
                    this.eventStack({type: '491_INVITE_CONFLICT'})
                }
                break
            case 'INFO':
                if(this.EVENTS[this.action]){
                    this.trigger(this.action,{codeType: code})
                }
                break
            case 'BYE':
                log.info('Receive server bye, location reload.')
                // window.location.reload(true)
                break
            default:
                log.warn('Other method: '+ event.data)
                break
        }
    }else {
        /* Server request message */
        log.info("handle server request: " + event.data.method)
        switch (event.data.method) {
            case 'INVITE':
                this.transaction = event.data.transaction
                this.isRecvRequest = true
                this.RTCSession.handleOffer(event.data.body)
                break
            case 'ACK':
                log.info('handle offer success')
                if(this.EVENTS[this.action]){
                    this.trigger(this.action, {codeType: this.CODE_TYPE.ACTION_SUCCESS});
                }
                break
            case 'BYE':
                log.info('Receive Server BYE!')
                break
            default:
                log.warn('request message.data.method: '+ event.data.method)
                break
        }
    }
}

/**
 * Message sending mechanism:
 * 1、Call sip interface
 * 2、sip interface returns data
 * 3、webSocket send data
 * @param event
 */
GsRTC.prototype.onmessage = function (event) {
    log.info('GsRTC: handle incoming message.')
    let content = event.data

    if( event.data === "\r\n"){
        /* websocket保活包 */
    }else {
        switch (content.cmd) {
            case 'functionReturn':
                break
            case 'sendMessage':
                this.sokect.sendMessage(event.data.msg)
                break
            case 'recvSipMessage':
                this.handleIncomingMessage(event)
                break
            default:
                log.info('handle non sip message: ', event.data)
                break
        }
    }
}



/***
 * Function that clear stream, free resources
 * @param stream
 */
PeerConnection.prototype.closeStream = function(stream){
    if(!stream){
        log.info('closeStream:stream is null');
        return;
    } else{
        log.info("close stream id: " + stream.id);
    }

    try {
        stream.oninactive = null;
        let tracks = stream.getTracks();
        for (let track in tracks) {
            tracks[track].onended = null;
            log.info("close stream");
            tracks[track].stop();
        }
    }
    catch (error) {
        log.info('closeStream: Failed to close stream');
        log.info(error);
    }
    stream = null;
}

/**
 * Bind page media elements after streaming successfully
 * @param type
 * @param stream
 * @param isLocal
 */
PeerConnection.prototype.setMediaElementStream = function (stream, type, isLocal) {
    log.info('get local/remote stream , ' + type)
    let prefix = isLocal === true ? 'local' : 'remote'
    let identify = null
    let isVideo = !(type === 'audio')
    switch (type) {
        case 'audio':
            identify = prefix + 'Audio'
            break;
        case 'main':
            identify = prefix + 'Video'
            break;
        case 'slides':
            identify = prefix + 'PresentVideo'
            break;
        case 'localVideoShare':
            identify = prefix + 'VideoShare'
            break
        case 'multiStreamPeer':
            // 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video
            if(stream.getAudioTracks().length > 0){
                identify = prefix + 'Audio'
            }else if(stream.getVideoTracks().length > 0){
                if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'Video'].srcObject){
                    identify = prefix + 'Video'
                }else if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'PresentVideo'].srcObject){
                    identify = prefix + 'PresentVideo'
                }else if(!this.gsRTC.HTML_MEDIA_ELEMENT[prefix + 'VideoShare'].srcObject){
                    identify = prefix + 'VideoShare'
                }
            }
            break
        default:
            break;
    }

    // Fires when video metadata loading is complete (displays the current video resolution)
    function displayVideoDimensions(e) {
        let className = e.target.id + '_dimensions'
        let dimensions = document.getElementsByClassName(className);
        if(dimensions && dimensions[0]){
            dimensions[0].innerHTML = e.target.videoWidth + ' x ' + e.target.videoHeight
        }
    }

    let target = this.gsRTC.HTML_MEDIA_ELEMENT[identify]
    if (target) {
        target.srcObject = stream;
        log.info('Get ' + identify +' stream');
        // 会覆盖演示流的oninactive监听事件
        // if(stream){
        //     stream.oninactive = function () {
        //         log.info('stream oninactive, clear element source')
        //         target.srcObject = null
        //     }
        // }
        
        if(isVideo){
            log.info('set video _dimensions')
            target.onloadedmetadata = displayVideoDimensions
        }
    }
}

/**
 * get type by stream id
 * 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video
 * @param streamId
 * @returns {string}
 */
PeerConnection.prototype.getTypeByStreamId = function(streamId){
    let type
    for(let key in this.gsRTC.MEDIA_STREAMS){
        if(gsRTC.MEDIA_STREAMS[key] && gsRTC.MEDIA_STREAMS[key].id === streamId){
            type = key
        }
    }
    if(type){
        type = type.split('_')[1].toLowerCase()
    }
    return type
}

/**
 * get current stream type by transceiver mid
 * @param mid
 */
PeerConnection.prototype.getTypeByMid = function(mid){
    let type
    switch (mid) {
        case '0':
            type = 'audio'
            break
        case '1':
            type = 'main'
            break
        case '2':
            type = 'slides'
            break
        default:
            break
    }
    log.info('get type by transceiver mid ' + type)

    return type
}

/**
 * get stream from canvas
 * @param number
 * @returns {Array}
 */
PeerConnection.prototype.getCaptureStream = function(number){
    let captureStreamArray = []
    // add canvass
    let canvas = document.createElement("canvas");
    canvas.id = 'canvasForCaptureStream'
    canvas.style.cssText = "display: none"

    for(let i = 0; i<number; i++){
        let stream = canvas.captureStream();
        log.info("get captureStream: ", stream)
        captureStreamArray.push(stream)
    }
    return captureStreamArray
}

/**
 * get stream type
 * @param type audio/main/slides/localVideo
 * @param isLocal
 * @returns {*}
 */
PeerConnection.prototype.getStreamType = function(type, isLocal){
    let streamType = null
    if(isLocal){
        switch (type) {
            case 'audio':
                streamType = 'LOCAL_AUDIO_STREAM'
                break
            case 'main':
                streamType = 'LOCAL_VIDEO_STREAM'
                break
            case 'slides':
                streamType = 'LOCAL_PRESENT_STREAM'
                break
            case 'localVideoShare':
                streamType = 'LOCAL_VIDEO_SHARE_STREAM'
                break
            default:
                log.info('no match type: '+ type)
                break
        }
    }else {
        switch (type) {
            case 'audio':
                streamType = 'REMOTE_AUDIO_STREAM'
                break
            case 'main':
                streamType = 'REMOTE_VIDEO_STREAM'
                break
            case 'slides':
                streamType = 'REMOTE_PRESENT_STREAM'
                break
            case 'localVideoShare':
                streamType = 'REMOTE_VIDEO_SHARE_STREAM'
                break
            default:
                log.info('no match type: '+ type)
                break
        }
    }
    return streamType
}

/**
 * set stream
 * @param stream
 * @param type: audio, main, slides, localVideoShare
 * @param isLocal :true for the local stream and false for the accepted remote stream
 */
PeerConnection.prototype.setStream = function(stream, type, isLocal){
    if (!type){
        log.warn("setStream: Invalid parameter!");
        return
    }

    let streamId = stream ? stream.id : null
    let streamType = this.getStreamType(type, isLocal)
    // multiStream: Browsers that do not support replaceTrack can only be judged by the type of stream
    if(!streamType && stream){
        if(isLocal){
            if(stream.getAudioTracks().length > 0){
                streamType = 'LOCAL_AUDIO_STREAM'
            }else if(stream.getVideoTracks().length > 0){
                if(!this.gsRTC.MEDIA_STREAMS['LOCAL_VIDEO_STREAM']){
                    streamType = 'LOCAL_VIDEO_STREAM'
                }else {
                    streamType = 'LOCAL_PRESENT_STREAM'
                }
            }
        }else {
            if(stream.getAudioTracks().length > 0){
                streamType = 'REMOTE_AUDIO_STREAM'
            }else if(stream.getVideoTracks().length > 0){
                if(!this.gsRTC.MEDIA_STREAMS['REMOTE_VIDEO_STREAM']){
                    streamType = 'REMOTE_VIDEO_STREAM'
                }else {
                    streamType = 'REMOTE_PRESENT_STREAM'
                }
            }
        }
    }

    log.info('set ' + streamType + ' stream id: ' + streamId)
    this.gsRTC.MEDIA_STREAMS[streamType] = stream

    this.setMediaElementStream(stream, type, isLocal)
}

/***
 * get stream
 * @param isLocal: true for the local stream and false for the accepted remote stream
 * @param type audio, main, slides, localVideoShare
 * @returns {*}
 */
PeerConnection.prototype.getStream = function(type, isLocal){
    if (!type){
        log.warn("getStream: Invalid parameter!");
        return
    }

    let streamType = this.getStreamType(type, isLocal)
    let stream = this.gsRTC.MEDIA_STREAMS[streamType]

    if(stream){
        log.info('get ' + streamType + ' stream id :' + stream.id)
    }else {
        log.info('stream null')
    }
    return stream
}

/***
 * Function that stream mute and unmute switch
 * @param data 示例{
 *		stream: stream
 *	  type: 'audio'
 *	  mute: true
 * }
 */
PeerConnection.prototype.streamMuteSwitch = function(data){

    if(data.stream != null && data.stream !== undefined){
        log.info("MuteStream: stream id = " + data.stream.id);
    }else {
        log.warn("stream is not exist!")
        return
    }

    if ( data && data.stream && data.type === 'audio' && data.stream.getAudioTracks().length > 0 ){
        for ( let i = 0; i < data.stream.getAudioTracks().length; i++ ) {
            if (data.mute){
                if ( data.stream.getAudioTracks()[i].enabled === true ) {
                    log.info("MuteStream exec mute audio");
                    data.stream.getAudioTracks()[i].enabled = false;
                }
            }
            else{
                if ( data.stream.getAudioTracks()[i].enabled === false ) {
                    log.info("MuteStream exec unmute audio");
                    data.stream.getAudioTracks()[i].enabled = true;
                }
            }
        }
    } else if( (data.type === 'video' || data.type === 'slides') && data.stream.getVideoTracks().length > 0 ){
        for ( let j = 0; j < data.stream.getVideoTracks().length; j++ ) {
            if (data.mute){
                if ( data.stream.getVideoTracks()[j].enabled === true ) {
                    log.info("MuteStream exec mute video/slides");
                    data.stream.getVideoTracks()[j].enabled = false;
                }
            }
            else{
                if ( data.stream.getVideoTracks()[j].enabled === false ) {
                    log.info("MuteStream exec unmute video/slides");
                    data.stream.getVideoTracks()[j].enabled = true;
                }
            }
        }
    }
}

/**
 * get transceiver mid main for multiStream
 * @param pc
 * @param type
 * @returns {*}
 */
PeerConnection.prototype.getTransceiverMid = function(pc, type){
    log.info('get transceiver')
    let mid = 0

    if(pc.getTransceivers){
        if(type && pc.getTransceivers().length > 0){
            let transceiver = pc.getTransceivers()
            for(let i = 0; i<transceiver.length; i++){
                if((type === 'audio' && transceiver[i].mid === '0') || (type === 'main' && transceiver[i].mid === '1') || (type === 'slides' && transceiver[i].mid === '2')) {
                    mid = i
                    log.info('get transceiver mid' + mid)
                }
            }
        }
    }

    return mid
}

/***
 * Function that add stream
 * @param stream
 * @param pc
 * @param type
 */
PeerConnection.prototype.processAddStream = function (stream, pc, type) {
    log.info('process add stream')
    let This = this

    let mid = this.gsRTC.enableMultiStream ? this.getTransceiverMid(pc, type) : 0
    if(This.gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){
        if (!RTCRtpTransceiver.prototype.setDirection){
            /** Direction setting occasionally does not trigger onnegotiationneeded */
            pc.getTransceivers()[mid].direction = 'sendonly';
            pc.getTransceivers()[mid].direction = 'inactive';

            pc.getSenders()[mid].replaceTrack(stream.getTracks()[0])
              .then(function () {
                  log.info('use replaceTrack to add stream ');
              })
              .catch(function (error) {
                  console.error(error)
                  log.error(error.toString());
              });
            pc.getTransceivers()[mid].direction = 'sendrecv';
        }else{
            log.info('use replaceTrack to add stream ');
            pc.getTransceivers()[mid].setDirection('sendrecv');
        }
    }else {
        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */
        let browserDetail = this.gsRTC.getBrowserDetail()
        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === "11.0.2" || browserDetail.UIVersion === "11.1.2") && pc.getSenders().length > 0){
            pc.getSenders()[mid].replaceTrack(stream.getTracks()[0])
                .then(function () {
                    log.info('use replaceTrack to add stream ');
                })
                .catch(function (error) {
                    log.error(error.toString());
                });
        }else if(stream){
            log.info('use addStream to add stream.');
            pc.addStream(stream);
        }
    }
}

/***
 * Function that remove stream
 * @param stream
 * @param pc
 * @param type
 */
PeerConnection.prototype.processRemoveStream = function (stream, pc, type) {
    let This = this
    log.info('process remove stream')

    let mid = this.gsRTC.enableMultiStream ? this.getTransceiverMid(pc, type) : 0
    if(This.gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){
        if (!RTCRtpTransceiver.prototype.setDirection){
            /** Direction setting occasionally does not trigger onnegotiationneeded */
            pc.getTransceivers()[mid].direction = 'sendonly';
            pc.getTransceivers()[mid].direction = 'inactive';

            pc.getTransceivers()[mid].direction = 'recvonly';
            pc.getSenders()[mid].replaceTrack(null)
                .then(function () {
                    log.info('use replaceTrack to add stream ');
                })
                .catch(function (error) {
                    log.error(error.toString());
                })
        }else{
            log.info('use replaceTrack to remove stream.');
            pc.getTransceivers()[mid].setDirection('recvonly');
        }
    }else {
        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */
        let browserDetail = this.gsRTC.getBrowserDetail()
        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === "11.0.2" || browserDetail.UIVersion === "11.1.2") && pc.getSenders().length > 0){
            pc.getSenders()[mid].track.enablsed = false;
        }else if(stream){
            pc.removeStream(stream);
        }
        log.info('use removeStream to remove stream ');
    }
}




PeerConnection.prototype.onConnectionStateChange = function(pc){
    log.info('onConnectionStateChange type: ' + pc.type + ', connectionState: ' + pc.connectionState)

    let browserDetails = this.gsRTC.getBrowserDetail()
    if(pc.connectionState === 'failed' && ((browserDetails.browser === 'chrome' && browserDetails.version >= 76) || (browserDetails.browser === 'opera' &&browserDetails.chromeVersion >= 76))){
        this.iceConnectFailed(pc);
    }
}

PeerConnection.prototype.onIceConnectionStateChange = function(pc){
    if (!pc) {
        log.warn('Ignoring of ICE candidate event as Peer connection does not exists ->');
        return
    }

    let iceState =  pc.iceConnectionState
    log.info("onIceConnectionStateChange this type: " + pc.type + ", iceConnectionState: " + iceState);
    switch (iceState) {
        case 'new':
        case 'starting':
        case 'checking':
            break
        case 'connected':
            if(pc.isIceFailed){
                log.info("iceRestartSuccess alter web");
                this.onIceRestartSuccess(pc)
            }
            break
        case 'failed':
            this.iceConnectFailed(pc)
            break
        case 'completed':
        case 'closed':
        case 'disconnected':
            break
        default:
            break
    }
}

PeerConnection.prototype.onSignalingStateChange = function(pc){
    if (!pc) {
        log.info('PeerConnection is null: unexpected')
        return
    }
    log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)
}

PeerConnection.prototype.onIceGatheringStateChange = function(pc){
    if (!pc) {
        log.info('PeerConnection is null: unexpected')
        return
    }

    log.info('onicegatheringstatechange type: ' + pc.type + ', iceGatheringState: ' + pc.iceGatheringState)
}

PeerConnection.prototype.iceConnectFailed = function(pc){
    log.warn("iceConnectFailed, o_failure_num: " + pc.iceFailureNum + "  (PC:" + pc.type + ")");
    pc.action = 'iceRestart'
    // Re-connected three times without success is considered a failure
    if(pc.iceFailureNum >= 3){
        log.error("Failed to do ice restart(PC: " + pc.type + ")");
        if(!pc.isIceFailed){
            pc.isIceFailed = true
        }
        this.onIceRestartFailed();
    }else {
        log.info('Prepare start do ice restart！')
        pc.isIceFailed = true
        this.gsRTC.sendInviteQueue.push({
            action: 'iceRestart',
            sdp: null,
            type: pc.type
        })

        this.doOffer(pc)
        pc.iceFailureNum ++
    }
}

PeerConnection.prototype.onIceRestartSuccess = function (pc) {
    log.info("ice restart success" + "  (PC:" + pc.type + ")")
    pc.iceFailureNum = 0
    pc.isIceFailed = false
}

PeerConnection.prototype.onIceRestartFailed = function (pc) {
    log.error("ice restart failed")
    pc.iceFailureNum = 0
    pc.isIceFailed = true
    this.gsRTC.sipStack.jsSipSendBye()
    log.info('close peer')
    for (let key in this.RTCSession.peerConnections) {
        let pc = this.RTCSession.peerConnections[key];
        // close peerConnection
        pc.getSenders().forEach(sender => {
            delete sender.track
            sender.replaceTrack(null)
        })
        pc.close()
    }
}

PeerConnection.prototype.onIceCandidate = function (pc, event) {
    let iceState = pc.iceGatheringState
    if(iceState === "completed" || iceState === "complete" || (event && !event.candidate)){
        log.warn("onIceCandidate: ICE GATHERING COMPLETED( PC: " + pc.type + ")");
        pc.isLocalSdpPending = false
        this.onIceGatheringCompleted();
    }else {
        log.info(`${ pc.type } ICE candidate:\n${event.candidate ? event.candidate.candidate : '(null)'}`);
    }
}

PeerConnection.prototype.onIceGatheringCompleted = function () {
    if(!this.gsRTC.isProcessingInvite){
        return
    }

    if(this.peerConnections){
        for (let key in this.peerConnections){
            let pc = this.peerConnections[key]
            if(pc.isLocalSdpPending === true){
                log.info('MyOnIceGatheringCompleted not ready( ' + pc.type + " )")
                return false;
            }
        }
    }

    log.warn("__MyOnIceGatheringCompleted be ready to send INVITE or 200OK");
    this.gsRTC.isProcessingInvite = false
    this.gsRTC.eventStack({type: 'GET_LO_SUCCESS'})
}









/**
 * get sdp by type
 * @param type
 * @param sdp
 * @returns {*}
 */
GsRTC.prototype.getSdpByType = function (type, sdp) {
    if(!type || !sdp){
        log.warn('invalid parameters remote sdp or type!')
        return
    }
    let This = this
    let result = null
    let parseSdp
    let mid

    // 这里setRemote 之前修改一下mid
    if(this.enableMultiStream === true){
        log.info('get multi stream sdp')
        result = sdp
    }else {
        let sdpArray = SDPTools.splitSDP(sdp);
        for(let i = 0; i<sdpArray.length; i++) {
            if (type === 'audio' && sdpArray[i].indexOf('m=audio') >= 0) {
                result = sdpArray[i]
                mid = This.MID_OBJ.AUDIO_MID.ORIGINAL_MID
            // video1 for wfu
            } else if ((type === 'main' || type === 'video1') && sdpArray[i].indexOf('a=content:main') >= 0) {
                result = sdpArray[i]
                mid = This.MID_OBJ.MAIN_MID.ORIGINAL_MID
            } else if (type === 'slides' && sdpArray[i].indexOf('a=content:slides') >= 0) {
                mid = This.MID_OBJ.SLIDES_MID.ORIGINAL_MID
                result = sdpArray[i]
            }

            if(result){
                parseSdp = SDPTools.parseSDP(result)
                parseSdp = This.modifiedMidOfSdp(parseSdp, mid)
                result = SDPTools.writeSDP(parseSdp)
            }
        }
    }

    return result
}

/**
 * set sdp session version
 * @param localSdp
 */
GsRTC.prototype.saveSDPSessionVersion = function (localSdp) {
    log.info('set local sdp session version value')
    if(!localSdp){
        log.warn('invalid parameters local sdp!')
        return
    }

    let This = this
    let parseSdp = SDPTools.parseSDP(localSdp)

    if(This.isSendReInvite){
        parseSdp.origin.sessionVersion = This.sessionVersion + 1
        This.sessionVersion = parseSdp.origin.sessionVersion
    }else {
        This.sessionVersion = parseSdp.origin.sessionVersion
    }
}

/**
 * get resolution bu given level idc
 * @param levelIdc
 * @returns {*}
 */
GsRTC.prototype.getResolutionByLevelIdc = function(levelIdc){
    if(!levelIdc){
        log.warn('getResolutionByLevelIdc: levelIdc is null')
        return null
    }
    let resolution
    switch (levelIdc) {
        case '33':
            log.info('levelIdc ' + levelIdc + ', 3840 * 2160 ')
            resolution = { width: 3840, height: 2160 }
            break
        case '28':
            log.info('levelIdc ' + levelIdc + ', 1920 * 1080 ')
            resolution = { width: 1920, height: 1080 }
            break
        case '1f':
            log.info('levelIdc ' + levelIdc + ', 1280 * 720 ')
            resolution = { width: 1280, height: 720 }
            break
        case '1e':
            log.info('levelIdc ' + levelIdc + ', 848 * 480 ')
            resolution = { width: 848, height: 480 }
            break
        case '16':
            log.info('levelIdc ' + levelIdc + ', 640 * 360 ')
            resolution = { width: 640, height: 360 }
            break
        case '15':
            log.info('levelIdc ' + levelIdc + ', 480 * 272 ')
            resolution = { width: 480, height: 272 }
            break
        default:
            log.info('levelIdc ' + levelIdc + ', get default 640 * 360 ')
            resolution = { width: 640, height: 360 }
            break
    }

    return resolution
}

/**
 * get resolution bu given max-fs
 * @param maxFs
 * @returns {*}
 */
GsRTC.prototype.getResolutionByMaxfs = function(maxFs){
    if(!maxFs){
        log.warn('getResolutionByMaxfs: maxFs is null')
        return null
    }
    let resolution

    maxFs = parseInt(maxFs)
    switch (maxFs) {
        case 32400:
            log.info('maxFs ' + maxFs + ', 3840 * 2160 ')
            resolution = { width: 3840, height: 2160 }
            break
        case 8160:
            log.info('maxFs ' + maxFs + ', 1920 * 1080 ')
            resolution = { width: 1920, height: 1080 }
            break
        case 3600:
            log.info('maxFs ' + maxFs + ', 1280 * 720 ')
            resolution = { width: 1280, height: 720 }
            break
        case 1590:
            log.info('maxFs ' + maxFs + ', 848 * 480 ')
            resolution = { width: 848, height: 480 }
            break
        case 920:
            log.info('maxFs ' + maxFs + ', 640 * 360 ')
            resolution = { width: 640, height: 360 }
            break
        case 510:
            log.info('maxFs ' + maxFs + ', 480 * 272 ')
            resolution = { width: 480, height: 272 }
            break
        default:
            log.info('maxFs ' + maxFs + ', get default 640 * 360 ')
            resolution = { width: 640, height: 360 }
            break
    }

    return resolution
}

/**
 *  get resolution by given height
 * @param height
 * @returns {*}
 */
GsRTC.prototype.getResolutionByHeight = function(height){
    if(!height){
        log.warn('getResolutionByHeight: height is null')
        return null
    }
    let resolution

    height = parseInt(height)
    switch (height) {
        case 2160:
            log.info('3840 * 2160')
            resolution = {width: 3840, height: 2160}
            break
        case 1080:
            log.info('1920 * 1080')
            resolution = {width: 1920, height: 1080}
            break
        case 720:
            log.info('1280 * 720')
            resolution = {width: 1280, height: 720}
            break;
        case 480:
            log.info('848 * 480')
            resolution= {width: 848, height: 480}
            break;
        case 360:
            log.info('640 * 360')
            resolution= {width: 640, height: 360}
            break;
        default:
            log.info(' Unknown resolution ' + height + ', default 640 * 360')
            resolution = {width: 640, height: 360}
            break;
    }

    return resolution
}

/**
 * save video resolution
 * @param resolution
 * @param type
 */
GsRTC.prototype.setVideoResolution = function (resolution, type) {
    if(!resolution || !type){
        log.warn('setVideoResolution: INVALID PARAMETERS')
        return
    }
    let This = this

    switch (type) {
        case 'EXPECT_RECV_RESOLUTION':
            log.info('save expect receive resolution ' + resolution.height)
            This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION = resolution
            break
        case 'CURRENT_UP_RESOLUTION':
            log.info('save current up resolution ' + resolution.height)
            This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION = resolution
            break
        default:
            log.info('unknown resolution: ' + type)
          break
    }
}

/**
 * get saved video resolution
 * @param type
 * @returns {*|GsRTC.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION|{}|GsRTC.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION}
 */
GsRTC.prototype.getVideoResolution = function (type) {
    if(!type){
        log.warn('getVideoResolution: INVALID PARAMETER')
        return
    }
    let This = this
    let resolution

    switch (type) {
        case 'EXPECT_RECV_RESOLUTION':
            resolution = This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION
            log.info('get expect receive resolution')
            break
        case 'CURRENT_UP_RESOLUTION':
            resolution = This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION
            log.info('get current up resolution')
            break
        default:
            log.info('unknown resolution :' + type)
            break
    }

    return resolution
}


/**
 * Get the codec name corresponding to the highest priority PT in the sdp
 * @param sdp: parseSDP
 * @returns {*}
 */
GsRTC.prototype.getPriorityCodecBySdp = function(sdp){
    let codec = null
   try {
       if(sdp.media && sdp.media[0] && sdp.media[0].rtp){
           let rtp = sdp.media[0].rtp
           if(rtp && rtp.length > 0){
               codec = rtp[0].codec
           }
       }
   }catch (e) {
       log.error(e.toString())
   }
    log.info('get priority payload, ' + codec)
    return codec
}

/**
 * get framerate
 * order: framerate first, max-fr second
 * @param sdp: parseSDP
 * @returns {*}
 */
GsRTC.prototype.getFramerateBySdp = function (sdp) {
    let framerate = null
    if(sdp.media && sdp.media[0]){
        if(sdp.media[0].framerate){
            framerate = sdp.media[0].framerate
            log.info('framerate, ' + framerate)
        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){
            let fmtp = sdp.media[0].fmtp
            for(let i = 0; i<fmtp.length; i++){
                let pos_max_fr = fmtp[i].config.indexOf('max-fr')
                if (pos_max_fr >= 0) {
                    var max_fr = fmtp[i].config.substring(pos_max_fr + 7);
                    var end = max_fr.indexOf(';');
                    if (end >= 0) {
                        max_fr = max_fr.substring(0, end);
                    }
                    log.info('max-fr, ' + max_fr)
                    framerate =  parseInt(max_fr);
                }
            }
        }
    }
    log.info('get framerate, ' + framerate)
    return framerate
}

/**
 * get resolution from profile-level-id
 * @param sdp: parseSDP
 */
GsRTC.prototype.getH264ResolutionBySdp = function(sdp){
    if(!sdp){
        log.warn('getH264ResolutionBySdp: Invalid argument!')
        return
    }

    let subSDP = SDPTools.writeSDP(sdp)
    let index = subSDP.indexOf('profile-level-id')
    let resolution = {}
    if(index >= 0){
        let levelIdc = subSDP.substr(index + 21, 2)
        levelIdc = levelIdc.toLocaleLowerCase()
        switch (levelIdc) {
            case '15':
                resolution = { width: 480, height: 272 }
                break;
            case '16':
                resolution = { width: 640, height: 360 }
                break;
            case '1e':
                resolution = { width: 848, height: 480 }
                break;
            case '1f':
                resolution = { width: 1280, height: 720 }
                break;
            case '28':
                resolution = { width: 1920, height: 1080 }
                break;
            case '33':
                resolution = { width: 3840, height: 2160 }
                break
            default:
                resolution = { width: 640, height: 360 }
                log.info('return default value 640 * 360')
                log.info("getH264ResolutionBySdp: The value is out of the range, " + levelIdc);
                break;
        }
    }

    if(resolution && resolution.width && resolution.height){
        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)
    }else {
        log.info('get resolution {}')
    }
    return resolution
}

/**
 * get vp8 resolution from max-fs
 * @param sdp: parseSDP
 */
GsRTC.prototype.getVp8ResolutionBySdp = function(sdp){
    if(!sdp){
        log.warn('getVp8ResolutionBySdp: Invalid argument!')
        return
    }

    let subSDP = SDPTools.writeSDP(sdp)
    let index = subSDP.indexOf('max-fs')
    let resolution  = {}
    if(index >= 0){
        let maxFs = subSDP.substring(index + 7)
        maxFs = parseInt(maxFs.substring(0,maxFs.indexOf(';')))
        log.info('VP8, ' + maxFs)
        switch (maxFs) {
            case 520:
                resolution = { width: 480, height: 272 }
                break;
            case  920:
            case  900:
                resolution = { width: 640, height: 360 }
                break;
            case 1596:
                resolution = { width: 848, height: 480 }
                break;
            case 3600:
                resolution = { width: 1280, height: 720 }
                break;
            case 8192:
            case 8160:
            case 8100:
                resolution = { width: 1920, height: 1080 }
                break;
            case 32400:
                resolution = { width: 3840, height: 2160 }
                break
            default:
                resolution = { width: 640, height: 360 }
                log.info('return default value 640 * 360')
                log.info("get_vp8_resolution: The value is out of the range or invalid, " + maxFs);
                break;
        }
    }

    if(resolution && resolution.width && resolution.height){
        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)
    }else {
        log.info('get resolution {}')
    }
    return resolution
}

/**
 * get resolution
 * @param sdp : parseSDP
 */
GsRTC.prototype.getResolutionBySdp = function (sdp) {
    log.info('get resolution')
    if(!sdp){
        log.warn('getResolutionBySdp: Invalid argument!')
        return
    }
    let codec = this.getPriorityCodecBySdp(sdp)
    let resolution = {}

    if(codec === 'H264'){
        resolution = this.getH264ResolutionBySdp(sdp)
    }
    if(codec === 'VP8'){
        resolution = this.getVp8ResolutionBySdp(sdp)
    }

    if(resolution && resolution.width && resolution.height){
        log.info('resolution ' + resolution.width + " * " + resolution.height)
    }else {
        log.info('resolution {}')
    }

    return resolution
}

/**
 * set frameRate of sdp
 * order: framerate first ,max-fr second
 * @param sdp: parseSDP
 * @param framerate
 */
GsRTC.prototype.setFrameRateOfSdp = function(sdp, framerate){
    if(!sdp || !framerate){
        log.warn('setFrameRate: Invalid argument!')
        return
    }

    if(sdp.media && sdp.media[0]){
        if(sdp.media[0].framerate){
            log.info('change framerate ' + sdp.media[0].framerate + ' to ' + framerate)
            sdp.media[0].framerate = framerate
        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){
            let fmtp = sdp.media[0].fmtp
            for(let i = 0; i<fmtp.length; i++){
                let index = fmtp[i].config.indexOf('max-fr')
                if (index >= 0) {
                    let replacement =  'max-fr=' + framerate ;
                    fmtp[i].config = fmtp[i].config.replace(/max-fr=([a-zA-Z0-9]{1,2})/, replacement);
                    log.info('change max-fr to ' + framerate)
                }
            }
        }
    }

    return sdp
}

/**
 * Modify level-idc of sdp
 * @param sdp: parseSDP
 * @param width
 * @param height
 * @returns {*}
 */
GsRTC.prototype.setH264ResolutionOfSdp = function(sdp, width, height){
    if(!sdp || !width || !height){
        log.warn('setH264ResolutionOfSdp: Invalid argument!')
        return
    }
    let levelIdc = null
    switch (height) {
        case 2160:
            levelIdc = '33'
            break
        case 1080:
            levelIdc = '28'
            break
        case 720:
            levelIdc = '1f'
            break
        case 480:
            levelIdc = '1e'
            break
        case 360:
            levelIdc = '16'
            break
        case 272:
            levelIdc = '15'
            break
        default:
            levelIdc = 16
            log.info('set default levelIdc, ' + levelIdc)
            break
    }

    log.info('set levelId of local sdp ' + levelIdc)

    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp){
        let fmtp = sdp.media[0].fmtp
        if(fmtp.length > 0){
            for(let i = 0; i < fmtp.length; i++){
                let index  = fmtp[i].config.indexOf('profile-level-id')
                if(index >= 0){
                    let str = fmtp[i].config.substr(index, 21);
                    let replacement =  str + levelIdc ;
                    fmtp[i].config = fmtp[i].config.replace(/profile-level-id=([a-zA-Z0-9]{6})/, replacement);
                }
            }
        }
    }else {
        log.info('profile-level-id fmtp filed has not been find')
    }

    return sdp
}

/**
 * Modify max-fs of sdp
 * @param sdp: parseSDP
 * @param width
 * @param height
 * @returns {*}
 */
GsRTC.prototype.setVp8ResolutionOfSdp = function(sdp, width, height){
    if(!sdp || !width || !height){
        log.warn('setVp8ResolutionOfSdp: Invalid argument!')
        return
    }
    let mbWidth = (parseInt(width, 10) + 15) / 16;
    let mbHeight = (parseInt(height, 10) + 15) / 16;
    let maxFs = Math.floor(mbWidth) * Math.floor(mbHeight);
    log.info('set mas-fs ,' + maxFs)

    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp) {
        let fmtp = sdp.media[0].fmtp
        for (let i = 0; i < fmtp.length; i++) {
            let index = fmtp[i].config.indexOf('max-fs')
            if (index >= 0) {
                let replacement = 'max-fs=' + maxFs;
                fmtp[i].config = fmtp[i].config.replace(/max-fs=([a-zA-Z0-9]{3,5})/, replacement);
            }
        }
    }else {
        log.warn('max-fs fmtp filed has not been find')
    }

    return sdp
}

/**
 * modified mid of sdp
 * @param sdp
 * @param mid
 * @returns {*}
 */
GsRTC.prototype.modifiedMidOfSdp = function(sdp, mid){
    log.info('modified mid of sdp')
    if(sdp.media && sdp.media[0]){
        sdp.media[0].mid = mid
    }

    return sdp
}

/**
 * save original and modified mid before send invites
 * @param sdp
 * @param type
 */
GsRTC.prototype.saveMidBeforeSendInvite = function(sdp, type){
    log.info('save mid')
    let This = this
    let mid
    let parseSDP = SDPTools.parseSDP(sdp)
    if(parseSDP.media && parseSDP.media[0] && parseSDP.media[0]){
        mid = parseSDP.media[0].mid
    }

    switch (type) {
        case 'audio':
            This.MID_OBJ.AUDIO_MID.ORIGINAL_MID = mid
            This.MID_OBJ.AUDIO_MID.MODIFIED_MID = 0
            break
        case 'main':
            This.MID_OBJ.MAIN_MID.ORIGINAL_MID = mid
            This.MID_OBJ.MAIN_MID.MODIFIED_MID = 1
            break
        case 'slides':
            This.MID_OBJ.SLIDES_MID.ORIGINAL_MID = mid
            This.MID_OBJ.SLIDES_MID.MODIFIED_MID = 2
            break
        default:
            break
    }
}

/**
 * get modified mid before set remote
 * @param type
 * @returns {*}
 */
GsRTC.prototype.getModifiedMid = function(type){
    let This = this
    let mid;
    if(type === "audio"){
        mid = This.MID_OBJ.AUDIO_MID.MODIFIED_MID ? This.MID_OBJ.AUDIO_MID.MODIFIED_MID : 0;
    }else if(type === "main"){
        mid = This.MID_OBJ.MAIN_MID.MODIFIED_MID ? This.MID_OBJ.MAIN_MID.MODIFIED_MID : 1;
    }else if(type === "slides"){
        mid = This.MID_OBJ.SLIDES_MID.MODIFIED_MID ? This.MID_OBJ.SLIDES_MID.MODIFIED_MID : 2;
    }
    log.info('get ' + type + ' mid of ' + mid)
    return mid;
}

/**
 * change resolution of sdp
 * @param width
 * @param height
 * @param sdp: parseSDP
 * @returns {*}
 */
GsRTC.prototype.setResolutionOfSdp = function (sdp, width, height) {
    if (!sdp || !width || !height) {
        log.error("Invalid argument");
        return null;
    }

    try {
        sdp = this.setH264ResolutionOfSdp(sdp, width, height)
        sdp = this.setVp8ResolutionOfSdp(sdp, width, height)
    }catch (e) {
        log.error(e)
    }
    return sdp
}

/**
 * Processing sdp when multistream
 * @param subSDP
 * @returns {string}
 */
GsRTC.prototype.decorateMultiStreamSdp  = function(subSDP) {
    let This = this
    var sdp
    let sdpArray = []
    let lines = subSDP.split('\n')

    // modified BUNDLE and content
    for(let i = 0; i<lines.length; i++){
        if(lines[i].indexOf('a=group:BUNDLE') >= 0){
            lines.splice(i, 2, "a=msid-semantic: WMS\na=msid-semantic: WMS\na=msid-semantic: WMS\na=group:BUNDLE 0\na=group:BUNDLE 1\na=group:BUNDLE 2");
        }
        if(lines[i].indexOf('a=mid:1') >= 0){
            lines.splice(i+1, 0, "a=content:main");
            i++
        }
        if(lines[i].indexOf('a=mid:2') >= 0){
            lines.splice(i+1, 0, "a=content:slides");
            i++
        }
    }

    // get all media line
    function getPositions(arr){
        // get all media line
        let pos = []
        for(let i = 0; i<arr.length; i++){
            if(arr[i].indexOf('m=') >= 0){
                pos.push(i)
            }
        }
        return pos
    }
    let positions = getPositions(lines)

    let target
    let index = 0
    // get audio main slides sdp array
    if(positions.length > 0){
        for(let j = 0; j <= positions.length; j++){
            if(j === positions.length){
                target = lines.slice(positions[index], lines.length).join('\n')
            }else {
                target = lines.slice(positions[j-1], positions[j]).join('\n')
            }
            sdpArray.push(target)
            index = j
        }
    }

    sdpArray[0] = sdpArray[0].concat(['\n'])
    let audioSdp = sdpArray[0].concat(sdpArray[1])
    let mainSdp = sdpArray[0].concat(sdpArray[2])
    let slidesSdp = sdpArray[0].concat(sdpArray[3])

    // delete useless PT number for main
    let mainSdp_ = SDPTools.parseSDP(mainSdp)
    SDPTools.removeCodecByPayload(mainSdp_, 0, [98, 99,127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])
    // set resolution of sdp
    let resolution = This.getVideoResolution('EXPECT_RECV_RESOLUTION')
    if(resolution.width && resolution.height){
        // set expected receive resolution
        mainSdp_ = This.setResolutionOfSdp(mainSdp_, resolution.width, resolution.height)
    }
    mainSdp = SDPTools.writeSDP(mainSdp_)
    // delete useless PT number for slides
    let slidesSdp_ = SDPTools.parseSDP(slidesSdp)
    SDPTools.removeCodecByPayload(slidesSdp_, 0, [98, 99, 127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116])
    slidesSdp = SDPTools.writeSDP(slidesSdp_)

    // delete ssrc if no stream to send
    function removeSSRC(sdp){
        let sdpArray = sdp.split('\n');
        for(let k = 0; k<sdpArray.length; k++){
            if(sdpArray[k].indexOf('a=ssrc-group:') >= 0 || sdpArray[k].indexOf('a=ssrc') >= 0 || sdpArray[k].indexOf('a=msid:-') >= 0){
                sdpArray.splice(k, 1)
                k--
            }
        }
        return sdpArray.join('\n')
    }

    // modified direction for three media
    let audioStream = This.RTCSession.getStream('audio', true)
    if(!audioStream){
        audioSdp = audioSdp.replace(/a=sendrecv/g, "a=recvonly")
        audioSdp = removeSSRC(audioSdp)
    }
    let mainStream = This.RTCSession.getStream('main', true)
    if(!mainStream){
        mainSdp = mainSdp.replace(/a=sendrecv/g, "a=recvonly")
        mainSdp = removeSSRC(mainSdp)
    }
    // set direction recvonly if not share screen
    let stream = This.RTCSession.getStream('slides', true)
    if(stream){
        slidesSdp = slidesSdp.replace(/a=sendrecv/g, "a=sendonly");
        slidesSdp = slidesSdp.replace(/a=recvonly/g, "a=sendonly");
    }else {
        slidesSdp = slidesSdp.replace(/a=sendrecv/g, "a=recvonly");
        slidesSdp = removeSSRC(slidesSdp)
    }

    function deleteHead(sdp) {
        let lines = sdp.split('\n')
        for(var k = 0; k<lines.length; k++){
            if(lines[k].indexOf('m=') >= 0){
                sdpArray[0] = lines.slice(0, k)
                sdp = lines.slice(k, lines.length).join('\n')
            }
        }
        return sdp
    }

    audioSdp = deleteHead(audioSdp)
    mainSdp = deleteHead(mainSdp)
    slidesSdp = deleteHead(slidesSdp)
    let head =  sdpArray[0].join('\n')
    sdp = head + '\n' + audioSdp + '\n'+ mainSdp + slidesSdp
    return sdp
}
/*Log Debug Start*/
/**
 * @param {Function} debug The function that handles the DEBUG level logs.
 * @param {Function} log The function that handles the LOG level logs.
 * @param {Function} info The function that handles the INFO level logs.
 * @param {Function} warn The function that handles the WARN level logs.
 * @param {Function} error The function that handles the ERROR level logs.
 * @type {{warn: *, debug: *, log: *, error: *, info: *}}
 */
var log = {
    debug: window.debug("WebSocket:DEBUG"),
    log: window.debug("WebSocket:LOG"),
    info: window.debug("WebSocket:INFO"),
    warn: window.debug("WebSocket:WARN"),
    error: window.debug("WebSocket:ERROR")
};
/*Log Debug End*/

/**
 * create webSocket instance
 * @param url
 * @param protocol such as sip
 * @returns {WebSocket|*}
 * @constructor
 */
let WebSocketInstance = function (url, protocol) {
    log.info('create new webSocket.')
    if (GsRTC.prototype.tskStringIsNullOrEmpty(url)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + url + "' is not valid as webSocket url value");
    }
    if (GsRTC.prototype.tskStringIsNullOrEmpty(protocol)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + protocol + "' is not valid as protocol value");
    }

    if(this instanceof WebSocketInstance){
        this.isChannelOpen = false
        this.ws = this.createWebSocket(url, protocol)
    }else {
        return new WebSocketInstance()
    }
}

/**
 * create new webSocket
 * @param url
 * @param protocols
 * @returns {WebSocket}
 */
WebSocketInstance.prototype.createWebSocket = function(url, protocols){
    log.info('create webSocket')
    if (GsRTC.prototype.tskStringIsNullOrEmpty(url)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + url + "' is not valid as webSocket url value");
    }

    let This = this
    log.info('Connecting to \'' + url);
    let ws = new WebSocket(url, protocols)
    ws.onopen = function (event) {
        log.info('websocket onopen')
        This.isChannelOpen = true;
    }

    ws.onmessage = function (event) {
        // if (typeof (event.data) === 'string') {
        //     jsSipParser(event.data, 0)
        // }

        // for wfu
        if (isJsonString(event.data)) {
            let parseDate = JSON.parse(event.data)
            console.warn("************ onmessage parseDate: ", parseDate)
            if (parseDate.createMediaSessionRet && parseDate.createMediaSessionRet.sdp && parseDate.createMediaSessionRet.sdp.data) {
                role = ''
                let sdp  = parseDate.createMediaSessionRet.sdp.data
                console.warn('get createMediaSessionRet sdp: \n', sdp)
                gsRTC.RTCSession.commonDecorateRo(sdp)
            }
        } else {
            let type = typeJudgement(event.data)
            console.warn("event.data type: ", type)
        }
    }

    ws.onclose = function (event) {
        log.info('websocket onclose')
        console.warn(event)
        This.isChannelOpen = false
    }

    ws.onerror = function (event) {
        log.info('websocket onerror')
        console.warn(event)
    }

    return ws
}


/**
 * send message
 * @param message
 */
WebSocketInstance.prototype.sendMessage = function (message) {
    try {
        if(!this.ws){
            log.warn('websocket has not been created yet to send message')
            return
        }

        // for wfu
        if(window.wfu === true){
            let reqId = parseInt(Math.round(Math.random()*100));
            console.warn("random req id is" + reqId);
            let data = {
                createMediaSession: {
                    userName: "wfu_test",
                    reqId: reqId,
                    sdp: {
                        length: message.length,
                        data: message,
                    }
                }
            }
            log.warn("ws send message: " , data);
            this.ws.send(JSON.stringify(data))
        }else {
            this.ws.send(message)
        }
    }catch (e) {
        console.error(e)
        log.error(e)
    }
}



//# sourceMappingURL=gsRTC.min.js.map
