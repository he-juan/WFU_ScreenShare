{"version":3,"names":[],"mappings":"","sources":["gsRTC.min.js"],"sourcesContent":["\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.debug = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){},{\r\n\r\n}],2:[function(require,module,exports){\r\n/* global window, exports, define */\r\n    !function() {\r\n            'use strict';\r\n\r\n            var re = {\r\n                not_string: /[^s]/,\r\n                not_bool: /[^t]/,\r\n                not_type: /[^T]/,\r\n                not_primitive: /[^v]/,\r\n                number: /[diefg]/,\r\n                numeric_arg: /[bcdiefguxX]/,\r\n                json: /[j]/,\r\n                not_json: /[^j]/,\r\n                text: /^[^\\x25]+/,\r\n                modulo: /^\\x25{2}/,\r\n                placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\r\n                key: /^([a-z_][a-z_\\d]*)/i,\r\n                key_access: /^\\.([a-z_][a-z_\\d]*)/i,\r\n                index_access: /^\\[(\\d+)\\]/,\r\n                sign: /^[\\+\\-]/\r\n            }\r\n\r\n            function sprintf(key) {\r\n                // `arguments` is not an array, but should be fine for this call\r\n                return sprintf_format(sprintf_parse(key), arguments)\r\n            }\r\n\r\n            function vsprintf(fmt, argv) {\r\n                return sprintf.apply(null, [fmt].concat(argv || []))\r\n            }\r\n\r\n            function sprintf_format(parse_tree, argv) {\r\n                var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign\r\n                for (i = 0; i < tree_length; i++) {\r\n                    if (typeof parse_tree[i] === 'string') {\r\n                        output += parse_tree[i]\r\n                    }\r\n                    else if (Array.isArray(parse_tree[i])) {\r\n                        match = parse_tree[i] // convenience purposes only\r\n                        if (match[2]) { // keyword argument\r\n                            arg = argv[cursor]\r\n                            for (k = 0; k < match[2].length; k++) {\r\n                                if (!arg.hasOwnProperty(match[2][k])) {\r\n                                    throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\r\n                                }\r\n                                arg = arg[match[2][k]]\r\n                            }\r\n                        }\r\n                        else if (match[1]) { // positional argument (explicit)\r\n                            arg = argv[match[1]]\r\n                        }\r\n                        else { // positional argument (implicit)\r\n                            arg = argv[cursor++]\r\n                        }\r\n\r\n                        if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {\r\n                            arg = arg()\r\n                        }\r\n\r\n                        if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {\r\n                            throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\r\n                        }\r\n\r\n                        if (re.number.test(match[8])) {\r\n                            is_positive = arg >= 0\r\n                        }\r\n\r\n                        switch (match[8]) {\r\n                            case 'b':\r\n                                arg = parseInt(arg, 10).toString(2)\r\n                                break\r\n                            case 'c':\r\n                                arg = String.fromCharCode(parseInt(arg, 10))\r\n                                break\r\n                            case 'd':\r\n                            case 'i':\r\n                                arg = parseInt(arg, 10)\r\n                                break\r\n                            case 'j':\r\n                                arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\r\n                                break\r\n                            case 'e':\r\n                                arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\r\n                                break\r\n                            case 'f':\r\n                                arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\r\n                                break\r\n                            case 'g':\r\n                                arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)\r\n                                break\r\n                            case 'o':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(8)\r\n                                break\r\n                            case 's':\r\n                                arg = String(arg)\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 't':\r\n                                arg = String(!!arg)\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'T':\r\n                                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'u':\r\n                                arg = parseInt(arg, 10) >>> 0\r\n                                break\r\n                            case 'v':\r\n                                arg = arg.valueOf()\r\n                                arg = (match[7] ? arg.substring(0, match[7]) : arg)\r\n                                break\r\n                            case 'x':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(16)\r\n                                break\r\n                            case 'X':\r\n                                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\r\n                                break\r\n                        }\r\n                        if (re.json.test(match[8])) {\r\n                            output += arg\r\n                        }\r\n                        else {\r\n                            if (re.number.test(match[8]) && (!is_positive || match[3])) {\r\n                                sign = is_positive ? '+' : '-'\r\n                                arg = arg.toString().replace(re.sign, '')\r\n                            }\r\n                            else {\r\n                                sign = ''\r\n                            }\r\n                            pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\r\n                            pad_length = match[6] - (sign + arg).length\r\n                            pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\r\n                            output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\r\n                        }\r\n                    }\r\n                }\r\n                return output\r\n            }\r\n\r\n            var sprintf_cache = Object.create(null)\r\n\r\n            function sprintf_parse(fmt) {\r\n                if (sprintf_cache[fmt]) {\r\n                    return sprintf_cache[fmt]\r\n                }\r\n\r\n                var _fmt = fmt, match, parse_tree = [], arg_names = 0\r\n                while (_fmt) {\r\n                    if ((match = re.text.exec(_fmt)) !== null) {\r\n                        parse_tree.push(match[0])\r\n                    }\r\n                    else if ((match = re.modulo.exec(_fmt)) !== null) {\r\n                        parse_tree.push('%')\r\n                    }\r\n                    else if ((match = re.placeholder.exec(_fmt)) !== null) {\r\n                        if (match[2]) {\r\n                            arg_names |= 1\r\n                            var field_list = [], replacement_field = match[2], field_match = []\r\n                            if ((field_match = re.key.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1])\r\n                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\r\n                                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {\r\n                                        field_list.push(field_match[1])\r\n                                    }\r\n                                    else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\r\n                                        field_list.push(field_match[1])\r\n                                    }\r\n                                    else {\r\n                                        throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                            }\r\n                            match[2] = field_list\r\n                        }\r\n                        else {\r\n                            arg_names |= 2\r\n                        }\r\n                        if (arg_names === 3) {\r\n                            throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\r\n                        }\r\n                        parse_tree.push(match)\r\n                    }\r\n                    else {\r\n                        throw new SyntaxError('[sprintf] unexpected placeholder')\r\n                    }\r\n                    _fmt = _fmt.substring(match[0].length)\r\n                }\r\n                return sprintf_cache[fmt] = parse_tree\r\n            }\r\n\r\n            /**\r\n             * export to either browser or node.js\r\n             */\r\n            /* eslint-disable quote-props */\r\n            if (typeof exports !== 'undefined') {\r\n                exports['sprintf'] = sprintf\r\n                exports['vsprintf'] = vsprintf\r\n            }\r\n            if (typeof window !== 'undefined') {\r\n                window['sprintf'] = sprintf\r\n                window['vsprintf'] = vsprintf\r\n\r\n                if (typeof define === 'function' && define['amd']) {\r\n                    define(function() {\r\n                        return {\r\n                            'sprintf': sprintf,\r\n                            'vsprintf': vsprintf\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n            /* eslint-enable quote-props */\r\n        }()\r\n},{}],3:[function(require,module,exports){\r\nvar sprintf = require(\"sprintf-js\").sprintf;\r\n\r\nvar argsToString = function(args) {\r\n            //sprintf-js did not support %o / %O\r\n            args[0] = args[0].replace(/%o/g, \"%s\");\r\n\r\n            switch (args.length) {\r\n                case 1:\r\n                    return args[0];\r\n                case 2:\r\n                    return sprintf(args[0], args[1]);\r\n                case 3:\r\n                    return sprintf(args[0], args[1], args[2]);\r\n                case 4:\r\n                    return sprintf(args[0], args[1], args[2], args[3]);\r\n                case 5:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4]);\r\n                case 6:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n                case 7:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\r\n                case 8:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\r\n                case 9:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\r\n                case 10:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\r\n                case 11:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\r\n                case 12:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\r\n                case 13:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12]);\r\n                case 14:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13]);\r\n                case 15:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14]);\r\n                case 16:\r\n                    return sprintf(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]);\r\n                default:\r\n                    return null;\r\n            }\r\n        };\r\n\r\n\r\nfunction beautyDate(date) {\r\n    var yyyy = date.getFullYear();\r\n    var m = date.getMonth() + 1; // getMonth() is zero-based\r\n    var d = date.getDate();\r\n    var h = date.getHours();\r\n    var mi = date.getMinutes();\r\n    var sec = date.getSeconds();\r\n    var msec = date.getMilliseconds();\r\n\r\n    var mm  = m < 10 ? \"0\" + m : m;\r\n    var dd  = d < 10 ? \"0\" + d : d;\r\n    var hh  = h < 10 ? \"0\" + h : h;\r\n    var min = mi < 10 ? \"0\" + mi : mi;\r\n    var ss  = sec < 10 ? \"0\" + sec : sec;\r\n    var mss = msec < 10 ? \"00\" + msec : ( msec < 100 ? \"0\" + msec : msec );\r\n\r\n    return \"\".concat(yyyy).concat(\"-\").concat(mm).concat(\"-\").concat(dd).concat(\"@\").concat(hh).concat(\":\").concat(min).concat(\":\").concat(ss).concat(\".\").concat(mss);\r\n};\r\n\r\n//For catch browser console error events\r\nself.onerror = function(msg, url, lineNo, columnNo, error) {\r\n    var message = [\r\n        'Message: ' + msg,\r\n        'URL: ' + url,\r\n        'Line: ' + lineNo,\r\n        'Column: ' + columnNo,\r\n        'Error object: ' + JSON.stringify(error)\r\n    ].join('\\n');\r\n\r\n    this.debug('Console:ERROR')(message);\r\n    return false;\r\n};\r\n\r\n/***\r\n * indexedDB Class Model\r\n * @type {self.DBmanager}\r\n */\r\nself.DBmanager = class DBmanager {\r\n    constructor(dbName, storeName, version, index) {\r\n        this.dbName = dbName;\r\n        this.storeName = storeName;\r\n        this.version = version || 1;\r\n        this.index = index;\r\n        this.currentDB = null;\r\n    }\r\n\r\n    /***\r\n     * create database\r\n     */\r\n    openDB() {\r\n        var request = self.indexedDB.open(this.dbName, this.version);\r\n        request.onerror = function (e) {\r\n            console.log(e.currentTarget.error.message);\r\n        }.bind(this);\r\n\r\n        request.onsuccess = function (e) {\r\n            this.currentDB = e.target.result;\r\n            console.log(this.currentDB.name + ' database is already opened!');\r\n        }.bind(this);\r\n\r\n        request.onupgradeneeded = function (e) {\r\n            console.log('database version is already upgrade to ' + this.version);\r\n            this.currentDB = e.target.result;\r\n            if (!this.currentDB.objectStoreNames.contains(this.storeName)) {\r\n                var objectStore = this.currentDB.createObjectStore(this.storeName, {keyPath: \"id\", autoIncrement: true});\r\n\r\n                // create index\r\n                if(this.index && this.index.length > 0){\r\n                    this.index.forEach(function (item) {\r\n                        objectStore.createIndex(item, item);\r\n                    })\r\n                }\r\n            }\r\n        }.bind(this);\r\n    }\r\n\r\n    /***\r\n     * get store by storeName\r\n     * @returns {IDBObjectStore}\r\n     */\r\n    getStoreByName() {\r\n        return this.currentDB.transaction(this.storeName, 'readwrite').objectStore(this.storeName);\r\n    }\r\n\r\n    /***\r\n     * add one data\r\n     * data should be an object\r\n     * @param data\r\n     */\r\n    setItem(data) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        store.add(data);\r\n\r\n        store.onsuccess = function (event) {\r\n            console.log('Data write succeeded');\r\n        };\r\n\r\n        store.onerror = function (event) {\r\n            console.log('Data write failed');\r\n        }\r\n    }\r\n\r\n    /***\r\n     * add more than one data\r\n     * data should be array\r\n     * @param items\r\n     */\r\n    setItems(items){\r\n        var store = this.getStoreByName(this.storeName);\r\n        for(var i = 0; i < items.length; i++){\r\n            store.put(items[i]);\r\n        }\r\n    }\r\n\r\n    /***\r\n     * Get a piece of data by key value\r\n     * @param key  Index name\r\n     * @param value\r\n     */\r\n    getItem (key, value) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var index = store.index(key);\r\n        var request = index.get(value);\r\n\r\n        request.onsuccess = function( e) {\r\n            if ( request.result) {\r\n                console.log(request.result);\r\n            } else {\r\n                console.log('未获得数据记录');\r\n            }\r\n        };\r\n    }\r\n\r\n    /***\r\n     * get all items\r\n     */\r\n    getAllItems() {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var request = store.openCursor();\r\n\r\n        request.onsuccess = function (event) {\r\n            var cursor = event.target.result;\r\n\r\n            if (cursor) {\r\n                console.log(cursor.value);\r\n                cursor.continue();\r\n            } else {\r\n                console.log('没有更多数据了！');\r\n            }\r\n        };\r\n    }\r\n\r\n    /***\r\n     * update data\r\n     * @param newItem\r\n     */\r\n    update(newItem) {\r\n        var store = this.getStoreByName(this.storeName);\r\n        store.put(newItem);\r\n\r\n        store.onsuccess = function (event) {\r\n            console.log('data update success');\r\n        };\r\n\r\n        store.onerror = function (event) {\r\n            console.log('data update failed');\r\n        }\r\n    }\r\n\r\n    clear () {\r\n        var store = this.getStoreByName(this.storeName);\r\n        var request = store.clear();\r\n\r\n        request.onsuccess = function (event) {\r\n            console.log('clear Success');\r\n        };\r\n        request.onerror = function (event) {\r\n            console.log('clear Error');\r\n        };\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * This is the common logic for both the Node.js and web browser implementations of `debug()`.\r\n */\r\nmodule.exports = function setup(env) {\r\n    createDebug.debug = createDebug['default'] = createDebug;\r\n    createDebug.coerce = coerce;\r\n    createDebug.disable = disable;\r\n    createDebug.enable = enable;\r\n    createDebug.enabled = enabled;\r\n    createDebug.sessionStorageSave = sessionStorageSave();\r\n    createDebug.enabledLocalLog = enabledLocalLog;\r\n    createDebug.enableLocalLog = enableLocalLog;\r\n    createDebug.disableLocalLog = disableLocalLog;\r\n    createDebug.getLocalLogs = getLocalLogs;\r\n    createDebug.getLocalDBName = getLocalDBName;\r\n    createDebug.exportLog = exportLog;\r\n\r\n    //The currently state of Local Log.\r\n    createDebug.localLogState = true;\r\n    createDebug.createdDBList = false; //marked the DB List is saved.\r\n    createDebug.logBuffer = [];\r\n\r\n    // Function is converted to a function under createDebug, eg useColors、formatArgs ect.\r\n    Object.keys(env).forEach(function(key) {\r\n        createDebug[key] = env[key];\r\n    });\r\n\r\n    // create dataBase\r\n    createDebug.dataBaseListDB = new self.DBmanager('DatabaseLists', \"keyvaluepairs\", 1, [\"dbName\", \"TS\"]);\r\n    createDebug.localLogsDB = new self.DBmanager(env.sessionStorage.dbName, \"localLogs\", 1, [\"cseqNumber\", \"moduleName\", \"logLevel\", \"TS\", \"content\"]);\r\n    createDebug.dataBaseListDB.openDB();\r\n    createDebug.localLogsDB.openDB();\r\n\r\n\r\n   // Active `debug` instances.\r\n    createDebug.instances = [ ];\r\n    // The currently active debug mode names, and names to skip.\r\n    createDebug.names = [ ];\r\n    createDebug.skips = [ ];\r\n\r\n\r\n     // Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n     // Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n    createDebug.formatters = { };\r\n\r\n    /**\r\n     * Select a color.\r\n     * @param {String} namespace\r\n     * @return {Number}\r\n     * @api private\r\n     */\r\n    function selectColor(namespace) {\r\n        var hash = 0, i;\r\n\r\n        for (i in namespace) {\r\n            hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\r\n            hash |= 0; // Convert to 32bit integer\r\n        }\r\n\r\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n    }\r\n    createDebug.selectColor = selectColor;\r\n\r\n    /**\r\n     * Select a background color.\r\n     * @param {String} namespace\r\n     * @return {Number}\r\n     * @api private\r\n     */\r\n\r\n    function selectBGColor(namespace) {\r\n        var hash = 0, i;\r\n\r\n        var level = namespace.match(/:(\\w+)/)[1];\r\n        switch (level) {\r\n        case 'DEBUG':\r\n            i = 0;\r\n            break;\r\n        case 'LOG':\r\n            i = 1;\r\n            break;\r\n        case 'INFO':\r\n            i = 2;\r\n            break;\r\n        case 'WARN':\r\n            i = 3;\r\n            break;\r\n        case 'ERROR':\r\n            i = 4;\r\n            break;\r\n        case 'FATAL':\r\n            i = 5;\r\n            break;\r\n        default:\r\n            i = 2;\r\n            break;\r\n        }\r\n\r\n        return createDebug.bgColors[i];\r\n    }\r\n    createDebug.selectBGColor = selectBGColor;\r\n\r\n    function destroy() {\r\n        var index = createDebug.instances.indexOf(this);\r\n        if (index !== -1) {\r\n            createDebug.instances.splice(index, 1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a debug mode by namespaces. This can include modes\r\n     * separated by a colon and wildcards.\r\n     *\r\n     * @param {String} namespaces\r\n     * @api public\r\n     */\r\n    function enable(namespaces) {\r\n        createDebug.save(namespaces);\r\n\r\n        createDebug.names = [ ];\r\n        createDebug.skips = [ ];\r\n\r\n        var i;\r\n        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n        var len = split.length;\r\n\r\n        for (i = 0; i < len; i++) {\r\n            if (!split[i]) continue; // ignore empty strings\r\n            namespaces = split[i].replace(/\\*/g, '.*?');\r\n            if (namespaces[0] === '-') {\r\n                createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\r\n            } else {\r\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < createDebug.instances.length; i++) {\r\n            var instance = createDebug.instances[i];\r\n            instance.enabled = createDebug.enabled(instance.namespace);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable debug output.\r\n     *\r\n     * @api public\r\n     */\r\n\r\n    function disable() {\r\n        createDebug.enable('');\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given mode name is enabled, false otherwise.\r\n     *\r\n     * @param {String} name\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n\r\n    function enabled(name) {\r\n        if (name[name.length - 1] === '*') {\r\n            return true;\r\n        }\r\n        var i, len;\r\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n            if (createDebug.skips[i].test(name)) {\r\n                return false;\r\n            }\r\n        }\r\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\r\n            if (createDebug.names[i].test(name)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Create a debugger with the given `namespace`.\r\n     * @param {String} namespace\r\n     * @return {Function}\r\n     * @api public\r\n     */\r\n    function createDebug(namespace) {\r\n        //var prevTime;\r\n        function debug() {\r\n\r\n            var date = new Date();\r\n            // turn the `arguments` into a proper Array\r\n            var args = new Array(arguments.length);\r\n            for (var i = 0; i < args.length; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n            args[0] = createDebug.coerce(args[0]);\r\n\r\n            if ('string' !== typeof args[0]) {\r\n                // anything else let's inspect with %O\r\n                args.unshift('%O');\r\n            }\r\n\r\n            if (createDebug.localLogState === true) {\r\n                //Save log into localforage whatever debug is disabled or not.\r\n                var logTime = beautyDate(date);\r\n                var logList = {\r\n                    cseqNumber: createDebug.logIndex,\r\n                    moduleName: namespace.split(\":\")[0],\r\n                    logLevel: namespace.split(\":\")[1],\r\n                    TS: (new Date()).getTime(),\r\n                    content: argsToString(args)\r\n                }\r\n\r\n                createDebug.logBuffer.push(logList);\r\n\r\n                // To avoid writing too often, write data to the database for every 20 data.\r\n                if (createDebug.logBuffer.length >= 20) {\r\n                    createDebug.localLogsDB.setItems(createDebug.logBuffer);\r\n                    createDebug.logBuffer = [ ];\r\n\r\n                    // save the databaseName into DatabaseLists database if not exist\r\n                    if (!createDebug.createdDBList) {\r\n                        var key = env.sessionStorage.dbName;\r\n                        var store = createDebug.dataBaseListDB.getStoreByName();\r\n                        var request = store.index('dbName').get(key);\r\n                        var infoJson = {};\r\n\r\n                        request.onsuccess = function( e) {\r\n                            if ( !request.result) {\r\n                                infoJson = {\r\n                                    TS: [ (new Date()).getTime() ],\r\n                                    dbName: env.sessionStorage.dbName,\r\n                                    data: {\r\n                                        confID: env.sessionStorage.confID,\r\n                                        userName: self.localStorage.userName,\r\n                                        email: self.localStorage.email\r\n                                    }\r\n                                };\r\n                            } else {\r\n                                infoJson = request.result;\r\n                                var ts = request.result.TS;\r\n                                if (ts) {\r\n                                    infoJson.TS.push((new Date()).getTime());\r\n                                }\r\n                            }\r\n                            createDebug.dataBaseListDB.update(infoJson);\r\n                            createDebug.createdDBList = true;\r\n                        };\r\n                    }\r\n                }\r\n                createDebug.logIndex++;\r\n\r\n                self.logIndex = createDebug.logIndex;\r\n                self.sessionStorage.dbIndex = self.logIndex;\r\n            }\r\n\r\n            // apply env-specific formatting (colors, etc.)\r\n            if (debug.enabled){\r\n            createDebug.logFormatters(args, debug)\r\n            }\r\n        }\r\n\r\n        debug.namespace = namespace;\r\n        debug.enabled = createDebug.enabled(namespace);\r\n        debug.useColors = createDebug.useColors();\r\n        debug.color = selectColor(namespace);\r\n        debug.bgColor = selectBGColor(namespace);\r\n        debug.destroy = destroy;\r\n\r\n        // env-specific initialization logic for debug instances\r\n        if ('function' === typeof createDebug.init) {\r\n            createDebug.init(debug);\r\n        }\r\n\r\n        createDebug.instances.push(debug);\r\n        return debug;\r\n    }\r\n\r\n    /**\r\n     * Log formatted output, add color, etc.\r\n     * @param args\r\n     * @param debug\r\n     */\r\n    function logFormatters(args, debug) {\r\n        var self = debug;\r\n        var index = 0;\r\n\r\n        args[0] = args[0].replace(/%[a-zA-Z%]/g,function(match, format) {\r\n            // if we encounter an escaped % then don't increase the array index\r\n            if (match === '%%') return match;\r\n            index++;\r\n            var formatter = createDebug.formatters[format];\r\n            if ('function' === typeof formatter) {\r\n                var val = args[index];\r\n                match = formatter.call(self, val);\r\n\r\n                // now we need to remove `args[index]` since it's inlined in the `format`\r\n                args.splice(index, 1);\r\n                index--;\r\n            }\r\n            return match;\r\n        });\r\n\r\n        // apply env-specific formatting (colors, etc.)\r\n        createDebug.formatArgs.call(self, args);\r\n\r\n        var logFn = self.log || createDebug.log;\r\n        logFn.apply(self, args);\r\n    }\r\n    createDebug.logFormatters = logFormatters;\r\n\r\n    /***\r\n     * 本地会话存储\r\n     */\r\n    function sessionStorageSave() {\r\n        var tabID = (env.sessionStorage.tabID && env.sessionStorage.closedLastTab !== '2') ? env.sessionStorage.tabID : (env.sessionStorage.tabID = Math.random().toString(36).substr(2));\r\n\r\n        env.sessionStorage.closedLastTab = '2';\r\n        self.onunload = self.onbeforeunload = function() {\r\n            env.sessionStorage.closedLastTab = '1';\r\n        };\r\n\r\n        if (!env.sessionStorage.dbName || !env.sessionStorage.dbName.match(tabID) ) {\r\n            console.log(\"Create dbName !!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\r\n            // env.sessionStorage.setItem(\"dbName\", \"db_\" + tabID);\r\n            env.sessionStorage.setItem(\"dbName\", tabID + \"_db\");\r\n            env.sessionStorage.setItem(\"dbIndex\", \"0\");\r\n        }\r\n\r\n        if (!env.sessionStorage.dbIndex) {\r\n            createDebug.logIndex = 0;\r\n        } else {\r\n            createDebug.logIndex = env.sessionStorage.dbIndex;\r\n        }\r\n        self.logIndex = createDebug.logIndex;\r\n    }\r\n\r\n    /**\r\n   * Enable LocalLog\r\n   *\r\n   * @api public\r\n   */\r\n    function enableLocalLog() {\r\n        createDebug.saveLocalLogState(true);\r\n        createDebug.localLogState = true;\r\n    }\r\n\r\n    /**\r\n     * Disable LocalLog.\r\n     *\r\n     * @api public\r\n     */\r\n\r\n    function disableLocalLog() {\r\n        createDebug.saveLocalLogState(false);\r\n        createDebug.localLogState = false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the LocalLog is enabled, false otherwise.\r\n     *\r\n     * @return {Boolean}\r\n     * @api public\r\n     */\r\n\r\n    function enabledLocalLog() {\r\n        return createDebug.localLogState;\r\n    }\r\n\r\n    /**\r\n     * Get the local log\r\n     *\r\n     * @param dbName\r\n     * @param {String} filter  {String} dbName (null means current\r\n     *        DB) {function} callback(logs)\r\n     * @param callback\r\n     * @return {Array} logs self.logs =\r\n     *         self.logs.filter(function(x){return (x !==\r\n     *         (undefined || null || ''));});\r\n     * @api public\r\n     */\r\n\r\n    function getLocalLogs(dbName, filter, callback) {\r\n        var localLogs = [];\r\n        var skips = [ ];\r\n        var names = [ ];\r\n        var db;\r\n\r\n        function enabled(name, skips, names) {\r\n            if (name[name.length - 1] === '*') {\r\n                return true;\r\n            }\r\n            var i, len;\r\n\r\n            for (i = 0, len = skips.length; i < len; i++) {\r\n                if (skips[i].test(name)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            for (i = 0, len = names.length; i < len; i++) {\r\n                if (names[i].test(name)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (dbName && dbName !== createDebug.sessionStorage.dbName) {\r\n            db = new self.DBmanager(dbName, \"localLogs\", 1, [\"cseqNumber\", \"moduleName\", \"logLevel\", \"TS\", \"content\"]);\r\n        } else {\r\n            db = createDebug.localLogsDB;\r\n        }\r\n        db.openDB();\r\n\r\n        if (filter !== '*') {\r\n            //Process filter\r\n            var i = 0;\r\n            var split = (typeof filter === 'string' ? filter : '').split(/[\\s,]+/);\r\n            var len = split.length;\r\n\r\n            for (i = 0; i < len; i++) {\r\n                if (!split[i]) continue; // ignore empty strings\r\n                filter = split[i].replace(/\\*/g, '.*?');\r\n                if (filter[0] === '-') {\r\n                    skips.push(new RegExp('^' + filter.substr(1) + '$'));\r\n                } else {\r\n                    names.push(new RegExp('^' + filter + '$'));\r\n                }\r\n            }\r\n\r\n            //Filter all keys\r\n            db.keys().then(function(keys) {\r\n                    for (var i = 0; i < keys.length; i++) {\r\n\r\n                        //Remove the logIndex first \"index-REALKEY\"\r\n                        var index = parseInt(keys[i]);\r\n                        var key = keys[i].substr(index.toString().length + 1);\r\n\r\n                        if (enabled(key, skips, names)) {\r\n                            db.getItem(keys[i]).then(function(log) {\r\n                                    var index = parseInt(log);\r\n                                    localLogs[index] = '[' + index + ']' + log.substr(index.toString().length) + \"\\r\\n\";\r\n                                }).catch(function(err) {})\r\n                        }\r\n                    }\r\n                }).catch(function(err) {});\r\n\r\n        } else {\r\n            var request = self.indexedDB.open(db.dbName);\r\n\r\n            request.onsuccess = function (e) {\r\n                var transaction = db.currentDB.transaction(db.storeName, 'readwrite');\r\n                var store = transaction.objectStore(db.storeName);\r\n\r\n                store.openCursor().onsuccess = function (event) {\r\n                    var cursor = event.target.result;\r\n\r\n                    if (cursor) {\r\n                        var string =  JSON.stringify(cursor.value);\r\n                        var cseqNumber  = cursor.value.cseqNumber;\r\n                        localLogs[cseqNumber] = '[' + cseqNumber + ']' + string + \"\\r\\n\";\r\n                        cursor.continue();\r\n                    } else {\r\n                        callback(localLogs);\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all Database name list\r\n     * @api public\r\n     */\r\n\r\n    function getLocalDBName(callback) {\r\n        var localDBs = [];\r\n        var request = self.indexedDB.open(createDebug.dataBaseListDB.dbName);\r\n\r\n        request.onsuccess = function (e) {\r\n            var dbName = createDebug.dataBaseListDB.storeName;\r\n            var transaction = createDebug.dataBaseListDB.currentDB.transaction(dbName, 'readwrite');\r\n            var objectStore = transaction.objectStore(dbName);\r\n            objectStore.openCursor().onsuccess = function (event) {\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    localDBs.push(cursor.value);\r\n                    cursor.continue();\r\n                } else {\r\n                    console.log('no more data!');\r\n                    callback(localDBs);\r\n                }\r\n            };\r\n            objectStore.openCursor().onerror = function (error) {\r\n                console.error(error)\r\n            }\r\n        }.bind(this);\r\n\r\n        request.onerror = function (e) {\r\n            console.log(e.currentTarget.error.message);\r\n        }.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Update the sipID and confSEQ in dbInformation in database\r\n     * \"DatabaseList\" .\r\n     * info should be { sipID: XXX, confSEQ: xxx, userName: aaa,\r\n     * email: bbb }\r\n     *\r\n     */\r\n    function updateConfInfo(confInfo) {\r\n        try {\r\n            var store = createDebug.dataBaseListDB.getStoreByName(createDebug.sessionStorage.dbName);\r\n            var index = store.index(\"dbName\");\r\n            var request = index.get(createDebug.sessionStorage.dbName);\r\n            var infoJson;\r\n\r\n            request.onsuccess = function( e) {\r\n                if ( request.result) {\r\n                    if (request.result != null && request.result !== \"[object Object]\") { //Todo: figure out why info is [object Object], when dbName is not exisit.\r\n                        infoJson = request.result;\r\n                        infoJson.data.confID = createDebug.sessionStorage.confID;\r\n                    } else {\r\n                        infoJson = {\r\n                            TS: [ (new Date()).getTime() ],\r\n                            dbName: createDebug.sessionStorage.dbName,\r\n                            data: {\r\n                                confID: createDebug.sessionStorage.confID,\r\n                                userName: self.localStorage.userName,\r\n                                email: self.localStorage.email\r\n                            }\r\n                        };\r\n                    }\r\n\r\n                    if (confInfo.sipID) {\r\n                        if (!infoJson.sipID) {\r\n                            infoJson.data.sipID = [ ];\r\n                        }\r\n                        infoJson.data.sipID.push(confInfo.sipID);\r\n                    }\r\n\r\n                    if (confInfo.confSEQ) {\r\n                        if (!infoJson.data.confSEQ) {\r\n                            infoJson.data.confSEQ = [ ];\r\n                        }\r\n                        infoJson.data.confSEQ.push(confInfo.confSEQ);\r\n                    }\r\n\r\n                    if (confInfo.userName) {\r\n                        infoJson.data.userName = confInfo.userName;\r\n                    }\r\n\r\n                    if (confInfo.email) {\r\n                        infoJson.data.email = confInfo.email;\r\n                    }\r\n\r\n                    if (confInfo.confTitle) {\r\n                        infoJson.data.confTitle = confInfo.confTitle;\r\n                    }\r\n\r\n                    createDebug.dataBaseListDB.update(infoJson);\r\n                    createDebug.createdDBList = true;\r\n                }\r\n            };\r\n        } catch (e) {}\r\n    }\r\n    createDebug.updateConfInfo = updateConfInfo;\r\n\r\n    /**\r\n     * Flush buffer into DB\r\n     *将缓冲区刷新到database里\r\n     */\r\n    function flushLogBuffer() {\r\n        try {\r\n            if (createDebug.logBuffer.length > 0) {\r\n                createDebug.logBuffer.push( createDebug.logBuffer);\r\n                createDebug.logBuffer = [ ];\r\n            }\r\n\r\n        } catch (e) {}\r\n    }\r\n    createDebug.flushLogBuffer = flushLogBuffer;\r\n\r\n    /**\r\n     * Coerce `val`.\r\n     *\r\n     * @param {Mixed} val\r\n     * @return {Mixed}\r\n     * @api private\r\n     */\r\n\r\n    function coerce(val) {\r\n        if (val instanceof Error) return val.stack || val.message;\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Export the local log\r\n     * 导出日志文件\r\n     * @api public\r\n     */\r\n\r\n    function exportLog() {\r\n\r\n        var fileName = 'meetingLog.txt';\r\n\r\n        debug.getLocalLogs(null, \"*\",\r\n           function(logs) {\r\n               if ( navigator.userAgent.match('(rv:11.0|Edge)') ) {\r\n                   /*IE 11 or Edge*/\r\n\r\n                   var log_file;\r\n                   try {\r\n                       log_file = new Blob(logs, { type: 'text/plain' });\r\n                   } catch (e) {\r\n                       // Old browser, need to use blob builder\r\n                       self.BlobBuilder = self.BlobBuilder || self.MSBlobBuilder;\r\n                       if (self.BlobBuilder) {\r\n                           var tmp = new BlobBuilder('text/plain');\r\n                           tmp.append(logs);\r\n                           log_file = tmp.getBlob();\r\n                       }\r\n\r\n                   }\r\n\r\n                   if (self.navigator && self.navigator.msSaveBlob) {\r\n                       self.navigator.msSaveBlob(log_file, fileName);\r\n                   }\r\n\r\n                   delete log_file;\r\n\r\n               } else {\r\n\r\n                   var log_file = new Blob(logs, { type: 'text/plain' });\r\n                   var b = document.createElement('a');\r\n                   var ev = document.createEvent('MouseEvents');\r\n                   ev.initEvent(\"click\", false, false);\r\n                   b.href = URL.createObjectURL(log_file);\r\n                   b.download = fileName;\r\n                   b.dispatchEvent(ev)\r\n\r\n                   delete b;\r\n                   delete log_file;\r\n               }\r\n           });\r\n    }\r\n\r\n    createDebug.enable(createDebug.load());\r\n\r\n    createDebug.localLogState = createDebug.loadLocalLogState() !== \"false\" ;\r\n\r\n    return createDebug;\r\n}\r\n\r\n},{\"sprintf-js\":2}],4:[function(require,module,exports){\r\n/**\r\n * This is the web browser implementation of `debug()`.   这是`debug()`的Web浏览器实现。\r\n */\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = 'undefined' != typeof chrome\r\n               && 'undefined' != typeof chrome.storage\r\n                  ? chrome.storage.local\r\n                  : localstorage();\r\nexports.log = log;\r\nexports.saveLocalLogState = saveLocalLogState;\r\nexports.loadLocalLogState = loadLocalLogState;\r\nexports.sessionStorage = self.sessionStorage;\r\n/*-------------------------------------------*/\r\n\r\nexports.colors = [\r\n    '#295288'\r\n   //'#46A7C9'\r\n    ];\r\n\r\n/**\r\n * Background Colors\r\n */\r\nexports.bgColors = [\r\n  'inherit', //DEBUG\r\n  'inherit', //LOG\r\n  '#46A7C9', //INFO\r\n  '#D08005;font-size:14px', //WARN\r\n  '#F64863;font-size:16px', //ERROR\r\n  '#F64863;font-size:18px'  //FATAL\r\n];\r\n\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n\r\nfunction useColors() {\r\n  // NB: In an Electron preload script, document will be defined but not fully\r\n  // initialized. Since we know we're in Chrome, we'll just detect this case\r\n  // explicitly\r\n  if (typeof window !== 'undefined' && self.process && self.process.type === 'renderer') {\r\n    return true;\r\n  }\r\n\r\n  // Internet Explorer do not support colors.\r\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/trident\\/(\\d+)/)) {\r\n      return false;\r\n  }\r\n\r\n  // Rzhang: Edge supports colors since 16215\r\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/edge\\/(\\d+)/)\r\n      && (parseInt(navigator.userAgent.toLowerCase().match(/edge\\/\\d+.(\\d+)/)[1]) < 16215)) {\r\n      return false;\r\n  }\r\n\r\n  // is webkit? http://stackoverflow.com/a/16459606/376773\r\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\r\n    // is firebug? http://stackoverflow.com/a/398120/376773\r\n    (typeof window !== 'undefined' && self.console && (self.console.firebug || (self.console.exception && self.console.table))) ||\r\n    // is firefox >= v31?\r\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\r\n    // double check webkit in userAgent just in case we are in a worker\r\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\r\n}\r\n\r\n/**\r\n * Colorize log arguments if enabled.\r\n * @api public\r\n */\r\n\r\nfunction formatArgs(args) {\r\n  var useColors = this.useColors;\r\n\r\n  args[0] = (useColors ? '%c' : '')\r\n    + this.namespace\r\n    + (useColors ? ' %c' : ' ')\r\n    + args[0]\r\n    + (useColors ? '%c ' : ' ');\r\n    //+ '+' + module.exports.humanize(this.diff);\r\n\r\n  if (!useColors) return;\r\n\r\n  var c = 'color: ' + this.color;\r\n  args.splice(1, 0, c, 'color: ' + this.bgColor)\r\n\r\n  // the final \"%c\" is somewhat tricky, because there could be other\r\n  // arguments passed either before or after the %c, so we need to\r\n  // figure out the correct index to insert the CSS into\r\n  var index = 0;\r\n  var lastC = 0;\r\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\r\n    if ('%%' === match) return;\r\n    index++;\r\n    if ('%c' === match) {\r\n      // we only are interested in the *last* %c\r\n      // (the user may have provided their own)\r\n      lastC = index;\r\n    }\r\n  });\r\n\r\n  args.splice(lastC, 0, c);\r\n}\r\n\r\n/**\r\n * Invokes `console.log()` when available.\r\n * No-op when `console.log` is not a \"function\".\r\n *\r\n * @api public\r\n */\r\n\r\nfunction log() {\r\n  // this hackery is required for IE8/9, where\r\n  // the `console.log` function doesn't have 'apply'\r\n  if (this.bgColor !== debug.bgColors[4]) {\r\n    return 'object' === typeof console\r\n    && console.log\r\n    && Function.prototype.apply.call(console.log, console, arguments);\r\n  } else {\r\n    return 'object' === typeof console\r\n           && console.error\r\n           && Function.prototype.apply.call(console.error, console, arguments);\r\n\r\n  }\r\n}\r\n\r\n/**\r\n * Save `namespaces`.\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\n\r\nfunction save(namespaces) {\r\n  try {\r\n    if (null == namespaces) {\r\n      exports.storage.removeItem('debug');\r\n    } else {\r\n      exports.storage.debug = namespaces;\r\n    }\r\n  } catch(e) {}\r\n}\r\n\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\n\r\nfunction load() {\r\n  var r;\r\n  try {\r\n    r = exports.storage.debug;\r\n  } catch(e) {}\r\n\r\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n  //if (!r && typeof process !== 'undefined' && 'env' in process) {\r\n  //  r = process.env.DEBUG;\r\n  //}\r\n\r\n  if ( !r ) {\r\n      //Set default namespaces\r\n      r = '*:INFO,*:WARN,*:ERROR';\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/**\r\n * Save LocalLog enable state.\r\n * @param {Bool} state\r\n * @api private\r\n */\r\nfunction saveLocalLogState(state) {\r\n  try {\r\n    if (null == state || state != false) {\r\n      exports.storage.setItem('localLog', true);\r\n    } else {\r\n      exports.storage.setItem('localLog', false);\r\n    }\r\n  } catch (e) {\r\n  }\r\n}\r\n\r\n/**\r\n * Load `localLog` setting.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\n\r\nfunction loadLocalLogState() {\r\n  var r = true;\r\n  try {\r\n      r = exports.storage.localLog;\r\n  } catch (e) {\r\n  }\r\n\r\n  // If debug isn't set in LS\r\n  if (!r ) {\r\n    r = true;\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\nfunction localstorage() {\r\n  try {\r\n    return self.localStorage;\r\n  } catch (e) {}\r\n}\r\n\r\nmodule.exports = require('./common')(exports);\r\n\r\nvar formatters = module.exports.formatters;\r\n\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function(v) {\r\n  try {\r\n    return JSON.stringify(v);\r\n  } catch (err) {\r\n    return '[UnexpectedJSONParseError]: ' + err.message;\r\n  }\r\n};\r\n\r\n},{\"./common\":3}]},{},[4])(4)\r\n});\nconst grammar = {\r\n    v: [{\r\n        name: 'version',\r\n        reg: /^(\\d*)$/\r\n    }],\r\n    o: [{\r\n        // o=- 20518 0 IN IP4 203.0.113.1\r\n        // NB: sessionId will be a String in most cases because it is huge\r\n        name: 'origin',\r\n        reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\r\n        names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\r\n        format: '%s %s %d %s IP%d %s'\r\n    }],\r\n    // default parsing of these only (though some of these feel outdated)\r\n    s: [{ name: 'name' }],\r\n    i: [{ name: 'description' }],\r\n    u: [{ name: 'uri' }],\r\n    e: [{ name: 'email' }],\r\n    p: [{ name: 'phone' }],\r\n    z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\r\n    r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\r\n    // k: [{}], // outdated thing ignored\r\n    t: [{\r\n        // t=0 0\r\n        name: 'timing',\r\n        reg: /^(\\d*) (\\d*)/,\r\n        names: ['start', 'stop'],\r\n        format: '%d %d'\r\n    }],\r\n    c: [{\r\n        // c=IN IP4 10.47.197.26\r\n        name: 'connection',\r\n        reg: /^IN IP(\\d) (\\S*)/,\r\n        names: ['version', 'ip'],\r\n        format: 'IN IP%d %s'\r\n    }],\r\n    b: [{\r\n        // b=AS:4000\r\n        push: 'bandwidth',\r\n        reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\r\n        names: ['type', 'limit'],\r\n        format: '%s:%s'\r\n    }],\r\n    m: [{\r\n        // m=video 51744 RTP/AVP 126 97 98 34 31\r\n        // NB: special - pushes to session\r\n        // TODO: rtp/fmtp should be filtered by the payloads found here?\r\n        reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\r\n        names: ['type', 'port', 'protocol', 'payloads'],\r\n        format: '%s %d %s %s'\r\n    }],\r\n    a: [\r\n        {\r\n            // a=rtpmap:110 opus/48000/2\r\n            push: 'rtp',\r\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\r\n            names: ['payload', 'codec', 'rate', 'encoding'],\r\n            format: function (o) {\r\n                return (o.encoding)\r\n                    ? 'rtpmap:%d %s/%s/%s'\r\n                    : o.rate\r\n                        ? 'rtpmap:%d %s/%s'\r\n                        : 'rtpmap:%d %s'\r\n            }\r\n        },\r\n        {\r\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\r\n            // a=fmtp:111 minptime=10; useinbandfec=1\r\n            push: 'fmtp',\r\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\r\n            names: ['payload', 'config'],\r\n            format: 'fmtp:%d %s'\r\n        },\r\n        {\r\n            // a=control:streamid=0\r\n            name: 'control',\r\n            reg: /^control:(.*)/,\r\n            format: 'control:%s'\r\n        },\r\n        {\r\n            // a=rtcp:65179 IN IP4 193.84.77.194\r\n            name: 'rtcp',\r\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\r\n            names: ['port', 'netType', 'ipVer', 'address'],\r\n            format: function (o) {\r\n                return (o.address != null)\r\n                    ? 'rtcp:%d %s IP%d %s'\r\n                    : 'rtcp:%d'\r\n            }\r\n        },\r\n        {\r\n            // a=rtcp-fb:98 trr-int 100\r\n            push: 'rtcpFbTrrInt',\r\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\r\n            names: ['payload', 'value'],\r\n            format: 'rtcp-fb:%d trr-int %d'\r\n        },\r\n        {\r\n            // a=rtcp-fb:98 nack rpsi\r\n            push: 'rtcpFb',\r\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\r\n            names: ['payload', 'type', 'subtype'],\r\n            format: function (o) {\r\n                return (o.subtype != null)\r\n                    ? 'rtcp-fb:%s %s %s'\r\n                    : 'rtcp-fb:%s %s'\r\n            }\r\n        },\r\n        {\r\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n            // a=extmap:1/recvonly URI-gps-string\r\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\r\n            push: 'ext',\r\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\r\n            names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\r\n            format: function (o) {\r\n                return (\r\n                    'extmap:%d' +\r\n                    (o.direction ? '/%s' : '%v') +\r\n                    (o['encrypt-uri'] ? ' %s' : '%v') +\r\n                    ' %s' +\r\n                    (o.config ? ' %s' : '')\r\n                )\r\n            }\r\n        },\r\n        {\r\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\r\n            push: 'crypto',\r\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\r\n            names: ['id', 'suite', 'config', 'sessionConfig'],\r\n            format: function (o) {\r\n                return (o.sessionConfig != null)\r\n                    ? 'crypto:%d %s %s %s'\r\n                    : 'crypto:%d %s %s'\r\n            }\r\n        },\r\n        {\r\n            // a=setup:actpass\r\n            name: 'setup',\r\n            reg: /^setup:(\\w*)/,\r\n            format: 'setup:%s'\r\n        },\r\n        {\r\n            // a=connection:new\r\n            name: 'connectionType',\r\n            reg: /^connection:(new|existing)/,\r\n            format: 'connection:%s'\r\n        },\r\n        {\r\n            // a=mid:1\r\n            name: 'mid',\r\n            reg: /^mid:([^\\s]*)/,\r\n            format: 'mid:%s'\r\n        },\r\n        {\r\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\r\n            name: 'msid',\r\n            reg: /^msid:(\\S*) (\\S*)/,\r\n            names: ['msid', 'trackid'],\r\n            format: 'msid:%s %s'\r\n        },\r\n        {\r\n            // a=ptime:20\r\n            name: 'ptime',\r\n            reg: /^ptime:(\\d*)/,\r\n            format: 'ptime:%d'\r\n        },\r\n        {\r\n            // a=maxptime:60\r\n            name: 'maxptime',\r\n            reg: /^maxptime:(\\d*)/,\r\n            format: 'maxptime:%d'\r\n        },\r\n        {\r\n            // a=sendrecv\r\n            name: 'direction',\r\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\r\n        },\r\n        {\r\n            // a=ice-lite\r\n            name: 'icelite',\r\n            reg: /^(ice-lite)/\r\n        },\r\n        {\r\n            // a=ice-ufrag:F7gI\r\n            name: 'iceUfrag',\r\n            reg: /^ice-ufrag:(\\S*)/,\r\n            format: 'ice-ufrag:%s'\r\n        },\r\n        {\r\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\r\n            name: 'icePwd',\r\n            reg: /^ice-pwd:(\\S*)/,\r\n            format: 'ice-pwd:%s'\r\n        },\r\n        {\r\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\r\n            name: 'fingerprint',\r\n            reg: /^fingerprint:(\\S*) (\\S*)/,\r\n            names: ['type', 'hash'],\r\n            format: 'fingerprint:%s %s'\r\n        },\r\n        {\r\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\r\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\r\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\r\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\r\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\r\n            push: 'candidates',\r\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\r\n            names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\r\n            format: function (o) {\r\n                let str = 'candidate:%s %d %s %d %s %d typ %s'\r\n\r\n                str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v'\r\n\r\n                // NB: candidate has three optional chunks, so %void middles one if it's missing\r\n                str += (o.tcptype != null) ? ' tcptype %s' : '%v'\r\n\r\n                if (o.generation != null) {\r\n                    str += ' generation %d'\r\n                }\r\n\r\n                str += (o['network-id'] != null) ? ' network-id %d' : '%v'\r\n                str += (o['network-cost'] != null) ? ' network-cost %d' : '%v'\r\n                return str\r\n            }\r\n        },\r\n        {\r\n            // a=end-of-candidates (keep after the candidates line for readability)\r\n            name: 'endOfCandidates',\r\n            reg: /^(end-of-candidates)/\r\n        },\r\n        {\r\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\r\n            name: 'remoteCandidates',\r\n            reg: /^remote-candidates:(.*)/,\r\n            format: 'remote-candidates:%s'\r\n        },\r\n        {\r\n            // a=ice-options:google-ice\r\n            name: 'iceOptions',\r\n            reg: /^ice-options:(\\S*)/,\r\n            format: 'ice-options:%s'\r\n        },\r\n        {\r\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\r\n            push: 'ssrcs',\r\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\r\n            names: ['id', 'attribute', 'value'],\r\n            format: function (o) {\r\n                let str = 'ssrc:%d'\r\n                if (o.attribute != null) {\r\n                    str += ' %s'\r\n                    if (o.value != null) {\r\n                        str += ':%s'\r\n                    }\r\n                }\r\n                return str\r\n            }\r\n        },\r\n        {\r\n            // a=ssrc-group:FEC 1 2\r\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\r\n            push: 'ssrcGroups',\r\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\r\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\r\n            names: ['semantics', 'ssrcs'],\r\n            format: 'ssrc-group:%s %s'\r\n        },\r\n        {\r\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\r\n            push: 'msidSemantics', /*Modified by rzhang, for merge/split SDP*/\r\n            //name: 'msidSemantic',\r\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\r\n            names: ['semantic', 'token'],\r\n            format: 'msid-semantic: %s %s' // space after ':' is not accidental\r\n        },\r\n        {\r\n            // a=group:BUNDLE audio video\r\n            push: 'groups',\r\n            reg: /^group:(\\w*) (.*)/,\r\n            names: ['type', 'mids'],\r\n            format: 'group:%s %s'\r\n        },\r\n        {\r\n            // a=rtcp-mux\r\n            name: 'rtcpMux',\r\n            reg: /^(rtcp-mux)/\r\n        },\r\n        {\r\n            // a=rtcp-rsize\r\n            name: 'rtcpRsize',\r\n            reg: /^(rtcp-rsize)/\r\n        },\r\n        {\r\n            // a=sctpmap:5000 webrtc-datachannel 1024\r\n            name: 'sctpmap',\r\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\r\n            names: ['sctpmapNumber', 'app', 'maxMessageSize'],\r\n            format: function (o) {\r\n                return (o.maxMessageSize != null)\r\n                    ? 'sctpmap:%s %s %s'\r\n                    : 'sctpmap:%s %s'\r\n            }\r\n        },\r\n        {\r\n            // a=x-google-flag:conference\r\n            name: 'xGoogleFlag',\r\n            reg: /^x-google-flag:([^\\s]*)/,\r\n            format: 'x-google-flag:%s'\r\n        },\r\n        {\r\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\r\n            push: 'rids',\r\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\r\n            names: ['id', 'direction', 'params'],\r\n            format: function (o) {\r\n                return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s'\r\n            }\r\n        },\r\n        {\r\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\r\n            // a=imageattr:* send [x=800,y=640] recv *\r\n            // a=imageattr:100 recv [x=320,y=240]\r\n            push: 'imageattrs',\r\n            reg: new RegExp(\r\n                // a=imageattr:97\r\n                '^imageattr:(\\\\d+|\\\\*)' +\r\n                // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\r\n                '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\r\n                // recv [x=330,y=250]\r\n                '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\r\n            ),\r\n            names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\r\n            format: function (o) {\r\n                return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '')\r\n            }\r\n        },\r\n        {\r\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\r\n            // a=simulcast:recv 1;4,5 send 6;7\r\n            name: 'simulcast',\r\n            reg: new RegExp(\r\n                // a=simulcast:\r\n                '^simulcast:' +\r\n                // send 1,2,3;~4,~5\r\n                '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\r\n                // space + recv 6;~7,~8\r\n                '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\r\n                // end\r\n                '$'\r\n            ),\r\n            names: ['dir1', 'list1', 'dir2', 'list2'],\r\n            format: function (o) {\r\n                return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '')\r\n            }\r\n        },\r\n        {\r\n            // old simulcast draft 03 (implemented by Firefox)\r\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\r\n            // a=simulcast: recv pt=97;98 send pt=97\r\n            // a=simulcast: send rid=5;6;7 paused=6,7\r\n            name: 'simulcast_03',\r\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\r\n            names: ['value'],\r\n            format: 'simulcast: %s'\r\n        },\r\n        {\r\n            // a=framerate:25\r\n            // a=framerate:29.97\r\n            name: 'framerate',\r\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\r\n            format: 'framerate:%s'\r\n        },\r\n        {\r\n            // RFC4570\r\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\r\n            name: 'sourceFilter',\r\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\r\n            names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\r\n            format: 'source-filter: %s %s %s %s %s'\r\n        },\r\n        {\r\n            // a=bundle-only\r\n            name: 'bundleOnly',\r\n            reg: /^(bundle-only)/\r\n        },\r\n        {\r\n            // a=label:1\r\n            name: 'label',\r\n            reg: /^label:(.+)/,\r\n            format: 'label:%s'\r\n        },\r\n        {\r\n            // RFC version 26 for SCTP over DTLS\r\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\r\n            name: 'sctpPort',\r\n            reg: /^sctp-port:(\\d+)$/,\r\n            format: 'sctp-port:%s'\r\n        },\r\n        {\r\n            // RFC version 26 for SCTP over DTLS\r\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\r\n            name: 'maxMessageSize',\r\n            reg: /^max-message-size:(\\d+)$/,\r\n            format: 'max-message-size:%s'\r\n        },\r\n        {\r\n            // a=keywds:keywords\r\n            name: 'keywords',\r\n            reg: /^keywds:(.+)$/,\r\n            format: 'keywds:%s'\r\n        },\r\n        {\r\n            // RFC4796 The Content Attribute\r\n            // a=content:slides,main,sl,speaker\r\n            name: 'content',\r\n            reg: /^content:(.+)$/,\r\n            format: 'content:%s'\r\n        },\r\n        {\r\n            // a=quality:quality\r\n            name: 'quality',\r\n            reg: /^quality:(.+)$/,\r\n            format: 'quality:%s'\r\n        },\r\n        {\r\n            // any a= that we don't understand is kept verbatim on media.invalid\r\n            push: 'invalid',\r\n            names: ['value']\r\n        }\r\n    ]\r\n}\r\n// set sensible defaults to avoid polluting the grammar with boring details\r\nObject.keys(grammar).forEach(function (key) {\r\n    let objs = grammar[key]\r\n    objs.forEach(function (obj) {\r\n        if (!obj.reg) {\r\n            obj.reg = /(.*)/\r\n        }\r\n        if (!obj.format) {\r\n            obj.format = '%s'\r\n        }\r\n    })\r\n})\r\n\r\n// customized util.format - discards excess arguments and can void middle ones\r\nlet formatRegExp = /%[sdv%]/g\r\nlet format = function (formatStr) {\r\n    let i = 1\r\n    let args = arguments\r\n    let len = args.length\r\n    return formatStr.replace(formatRegExp, function (x) {\r\n        if (i >= len) {\r\n            return x // missing argument\r\n        }\r\n        let arg = args[i]\r\n        i += 1\r\n        switch (x) {\r\n            case '%%':\r\n                return '%'\r\n            case '%s':\r\n                return String(arg)\r\n            case '%d':\r\n                return Number(arg)\r\n            case '%v':\r\n                return ''\r\n        }\r\n    })\r\n    // NB: we discard excess arguments - they are typically undefined from makeLine\r\n}\r\n\r\nfunction getType (obj) {\r\n    if (Object.prototype.toString.call(obj) === '[object Object]') {\r\n        return 'Object'\r\n    } else if (Object.prototype.toString.call(obj) === '[object Array]') {\r\n        return 'Array'\r\n    } else {\r\n        return 'nomal'\r\n    }\r\n}\r\n\r\nfunction deepCopy (obj) {\r\n    if (getType(obj) === 'nomal') {\r\n        return obj\r\n    } else {\r\n        var newObj = getType(obj) === 'Object' ? {} : []\r\n        for (let key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                newObj[key] = deepCopy(obj[key])\r\n            }\r\n        }\r\n    }\r\n    return newObj\r\n}\r\n\r\nlet makeLine = function (type, obj, location) {\r\n    let str = obj.format instanceof Function ? (obj.format(obj.push ? location : location[obj.name])) : obj.format\r\n    let args = [type + '=' + str]\r\n\r\n    if (obj.names) {\r\n        for (let i = 0; i < obj.names.length; i += 1) {\r\n            let n = obj.names[i]\r\n            if (obj.name) {\r\n                args.push(location[obj.name][n])\r\n            } else { // for mLine and push attributes\r\n                args.push(location[obj.names[i]])\r\n            }\r\n        }\r\n    } else {\r\n        args.push(location[obj.name])\r\n    }\r\n    return format.apply(null, args)\r\n}\r\n\r\n// RFC specified order\r\n// TODO: extend this with all the rest\r\nlet defaultOuterOrder = [\r\n    'v', 'o', 's', 'i',\r\n    'u', 'e', 'p', 'c',\r\n    'b', 't', 'r', 'z', 'a'\r\n]\r\nlet defaultInnerOrder = ['i', 'c', 'b', 'a']\r\n\r\nlet toIntIfInt = function (v) {\r\n    return String(Number(v)) === v ? Number(v) : v\r\n}\r\n\r\nlet attachProperties = function (match, location, names, rawName) {\r\n    if (rawName && !names) {\r\n        location[rawName] = toIntIfInt(match[1])\r\n    } else {\r\n        for (let i = 0; i < names.length; i += 1) {\r\n            if (match[i + 1] != null) {\r\n                location[names[i]] = toIntIfInt(match[i + 1])\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlet parseReg = function (obj, location, content) {\r\n    let needsBlank = obj.name && obj.names\r\n    if (obj.push && !location[obj.push]) {\r\n        location[obj.push] = []\r\n    } else if (needsBlank && !location[obj.name]) {\r\n        location[obj.name] = {}\r\n    }\r\n    // blank object that will be pushed\r\n    let keyLocation = obj.push ? {} : needsBlank ? location[obj.name] : location // otherwise, named location or root\r\n\r\n    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name)\r\n\r\n    if (obj.push) {\r\n        location[obj.push].push(keyLocation)\r\n    }\r\n}\r\n\r\nlet validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/)\r\n\r\nlet paramReducer = function (acc, expr) {\r\n    let s = expr.split(/=(.+)/, 2)\r\n    if (s.length === 2) {\r\n        acc[s[0]] = toIntIfInt(s[1])\r\n    } else if (s.length === 1 && expr.length > 1) {\r\n        acc[s[0]] = undefined\r\n    }\r\n    return acc\r\n}\r\n\r\nlet SDPTools = {\r\n    midMap: [], /*Save SDP mid mapping: msid:xxx(The original msid), mid:xx(The original mid), mappedMID:XX(The mapped mid)*/\r\n    msidMap: [], /*Save SDP msid mapping: msid:xxx(The original msid), pcName:XXX(The mapped msid) */\r\n    sessionVersion: 0, /*SDP o line session version*/\r\n    resolutionToLevelIdcMap: {\r\n        2160: '33',\r\n        1080: '28',\r\n        720: '1f',\r\n        480: '1e',\r\n        360: '16',\r\n        272: '15',\r\n    },\r\n    levelIdcToReSolutionMap: {\r\n        '15':  { width: 480, height: 272 },\r\n        '16': { width: 640, height: 360 },\r\n        '1e': { width: 848, height: 480 },\r\n        '1f': { width: 1280, height: 720 },\r\n        '28': { width: 1920, height: 1080 },\r\n        '33': { width: 3840, height: 2160 }\r\n    },\r\n    maxFsToResolutionMap: {\r\n        520: { width: 480, height: 272 },\r\n        920: { width: 640, height: 360 },\r\n        1596: { width: 848, height: 480 },\r\n        3600: { width: 848, height: 480 },\r\n        8160: { width: 848, height: 480 },\r\n        32400: { width: 3840, height: 2160 }\r\n    },\r\n\r\n    /**\r\n     * Increase SDP Session version\r\n     * @param session\r\n     */\r\n    increaseSessionVersion: function (session) {\r\n        if(session && session.origin){\r\n            let sessionVersion = session['origin']['sessionVersion']\r\n            sessionVersion += 1\r\n            session['origin']['sessionVersion'] = sessionVersion\r\n        }\r\n    },\r\n\r\n    /**\r\n     * SDPTools.writeSDP(parsedSdp)\r\n     * @param session\r\n     * @param opts\r\n     * @returns {string}\r\n     */\r\n    writeSDP: function (session, opts) {\r\n        opts = opts || {}\r\n        // ensure certain properties exist\r\n        if (session.version == null) {\r\n            session.version = 0 // 'v=0' must be there (only defined version atm)\r\n        }\r\n        if (session.name == null) {\r\n            session.name = ' ' // 's= ' must be there if no meaningful name set\r\n        }\r\n        session.media.forEach(function (mLine) {\r\n            if (mLine.payloads == null) {\r\n                mLine.payloads = ''\r\n            }\r\n        })\r\n\r\n        let outerOrder = opts.outerOrder || defaultOuterOrder\r\n        let innerOrder = opts.innerOrder || defaultInnerOrder\r\n        let sdp = []\r\n\r\n        // loop through outerOrder for matching properties on session\r\n        outerOrder.forEach(function (type) {\r\n            grammar[type].forEach(function (obj) {\r\n                if (obj.name in session && session[obj.name] != null) {\r\n                    sdp.push(makeLine(type, obj, session))\r\n                } else if (obj.push in session && session[obj.push] != null) {\r\n                    session[obj.push].forEach(function (el) {\r\n                        sdp.push(makeLine(type, obj, el))\r\n                    })\r\n                }\r\n            })\r\n        })\r\n\r\n        // then for each media line, follow the innerOrder\r\n        session.media.forEach(function (mLine) {\r\n            sdp.push(makeLine('m', grammar.m[0], mLine))\r\n\r\n            innerOrder.forEach(function (type) {\r\n                grammar[type].forEach(function (obj) {\r\n                    if (obj.name in mLine && mLine[obj.name] != null) {\r\n                        sdp.push(makeLine(type, obj, mLine))\r\n                    } else if (obj.push in mLine && mLine[obj.push] != null) {\r\n                        mLine[obj.push].forEach(function (el) {\r\n                            sdp.push(makeLine(type, obj, el))\r\n                        })\r\n                    }\r\n                })\r\n            })\r\n        })\r\n\r\n        return sdp.join('\\r\\n') + '\\r\\n'\r\n    },\r\n\r\n    /**\r\n     * SDPTools.parseSDP(sdp)\r\n     * @param sdp\r\n     */\r\n    parseSDP: function (sdp) {\r\n        let session = {}\r\n        let media = []\r\n        let location = session // points at where properties go under (one of the above)\r\n\r\n        // parse lines we understand\r\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (line) {\r\n            let type = line[0]\r\n            let content = line.slice(2)\r\n            if (type === 'm') {\r\n                media.push({ rtp: [], fmtp: [] })\r\n                location = media[media.length - 1] // point at latest media line\r\n            }\r\n\r\n            for (let j = 0; j < (grammar[type] || []).length; j += 1) {\r\n                let obj = grammar[type][j]\r\n                if (obj.reg.test(content)) {\r\n                    return parseReg(obj, location, content)\r\n                }\r\n            }\r\n        })\r\n\r\n        session.media = media // link it up\r\n        if (this.sessionVersion <= 0) {\r\n            this.sessionVersion = session['origin']['sessionVersion']\r\n        }\r\n        return session\r\n    },\r\n\r\n    /**\r\n     * Adjust the order of m lines (when using getCaptureStream to create multiple m lines, audio will not stay in front)\r\n     * SDPTools.adjustMLineOrder(parsedSdp)\r\n     */\r\n    adjustMLineOrder: function(session, order){\r\n        if(order){\r\n            // Restore the m line order of setLocalDescription\r\n            let media = []\r\n            for(let i=0; i< session.media.length; i++){\r\n                let type = session.media[i].content || session.media[i].type\r\n                for(let j in order){\r\n                    if(type === order[j]){\r\n                        media[j] = session.media[i]\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(media && media.length){\r\n                session.media = media\r\n            }\r\n        }else {\r\n            // keep audio first\r\n            let audioArray = []\r\n            let videoArray = []\r\n            for (let i = 0; i < session.media.length; i++) {\r\n                if (session.media[i].type === 'audio') {\r\n                    audioArray.push(session.media[i])\r\n                } else {\r\n                    videoArray.push(session.media[i])\r\n                }\r\n            }\r\n\r\n            session.media = audioArray.concat(videoArray)\r\n        }\r\n    },\r\n\r\n    /**\r\n     *  SDPTools.setGroups(parsedSdp)\r\n     *      a=group:BUNDLE 0\r\n     *      a=group:BUNDLE 1\r\n     *      a=group:BUNDLE 2\r\n     * @param session\r\n     */\r\n    setBundleMaxCompat: function(session){\r\n        session.groups = []\r\n        for(let i=0; i< session.media.length; i++){\r\n            session.groups.push({type: \"BUNDLE\", mids: session.media[i].mid})\r\n        }\r\n    },\r\n\r\n    /**\r\n     * add Media a=content type\r\n     * let contentType = ['main', 'slides']\r\n     * SDPTools.setMediaContentType(sdp, contentType)\r\n     * @param session\r\n     * @param contentType\r\n     * @returns {*|string}\r\n     */\r\n    setMediaContentType: function (session, contentType) {\r\n        if(!session || !contentType){\r\n            console.error('invalid error..')\r\n            return\r\n        }\r\n\r\n        if(session.media && session.media.length){\r\n            for(let i = 0; i<session.media.length; i++){\r\n                let media = session.media[i]\r\n                if(media.type === 'video' && !media.content){\r\n                    media['content'] = contentType.shift()\r\n                }\r\n            }\r\n        }\r\n    },\r\n    modifyBundleGroups: function (session,mid) {\r\n        session.groups = []\r\n        session.groups.mids = []\r\n        for (let i = 0; i < session.media.length; i++) {\r\n            let media = session.media[i]\r\n            if (media.mid !== mid) {\r\n                session.groups.mids.push(session.media[i].mid)\r\n            }\r\n        }\r\n        session.groups.push({type: 'BUNDLE', mids: session.groups.mids.join(' ')})\r\n        delete session.groups.mids\r\n    },\r\n    getMediaByType: function(session, type){\r\n        if(!session || !type){\r\n            console.error('invalid error..')\r\n            return\r\n        }\r\n\r\n        let target\r\n        if(session.media && session.media.length){\r\n            for(let i = 0; i<session.media.length; i++){\r\n                let media = session.media[i]\r\n                if(media.type === 'video' && media.content === type){\r\n                    target = media\r\n                    break\r\n                }\r\n            }\r\n        }\r\n        return target\r\n    },\r\n\r\n    /**\r\n     * payloads must be a array of NUMBERS\r\n     * let deletePTArray = [98, 99, 127]\r\n     * SDPTools.removeCodecByPayload(parsedSdp, 0, deletePTArray)\r\n     * @param session\r\n     * @param index\r\n     * @param payloads\r\n     */\r\n    removeCodecByPayload: function (session, index, payloads) {\r\n        if (index >= session.media.length) {\r\n            console.log('Error index')\r\n            return\r\n        }\r\n\r\n        let mediaSession = session.media[index]\r\n\r\n        /*Check relative fmtp payload*/\r\n        for (let i = 0; i < payloads.length; i += 1) {\r\n            for (let j = 0; j < mediaSession.fmtp.length; j += 1) {\r\n                if (mediaSession.fmtp[j].config.match('apt=' + payloads[i]) != null) {\r\n                    if (payloads.indexOf(mediaSession.fmtp[j].payload) === -1) {\r\n                        /*Added relative payload which also need to be removed*/\r\n                        payloads.push(mediaSession.fmtp[j].payload)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Process payloads: Delete the pt value corresponding to m-line  */\r\n        if(mediaSession.payloads && mediaSession.payloads.split) {\r\n            let sessionPayloads = mediaSession.payloads.split(' ')\r\n            for (let i = 0; i < payloads.length; i++) {\r\n                for (let j = 0; j < sessionPayloads.length; j++) {\r\n                    if (parseInt(payloads[i]) === parseInt(sessionPayloads[j])) {\r\n                        sessionPayloads.splice(j, 1)\r\n                        j--\r\n                    }\r\n                }\r\n            }\r\n            mediaSession.payloads = sessionPayloads.join(' ')\r\n        }\r\n\r\n        payloads.forEach(pt => {\r\n            if (mediaSession.rtp !== undefined) {\r\n                /*Process rtp*/\r\n                for (let i = 0; i < mediaSession.rtp.length;) {\r\n                    if (mediaSession.rtp[i].payload === pt) {\r\n                        mediaSession.rtp.splice(i, 1)\r\n                        break\r\n                    } else {\r\n                        i += 1\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (mediaSession.fmtp !== undefined) {\r\n                /*Process fmtp*/\r\n                for (let i = 0; i < mediaSession.fmtp.length;) {\r\n                    if (mediaSession.fmtp[i].payload === pt) {\r\n                        mediaSession.fmtp.splice(i, 1)\r\n                        //break; maybe there more than one fmtp for some payload.\r\n                    } else {\r\n                        i += 1\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (mediaSession.rtcpFb !== undefined) {\r\n                /*Process rtcpFb*/\r\n                for (let i = 0; i < mediaSession.rtcpFb.length;) {\r\n                    if (mediaSession.rtcpFb[i].payload === pt) {\r\n                        mediaSession.rtcpFb.splice(i, 1)\r\n                        //break; more than one rtcpFb for some payload.\r\n                    } else {\r\n                        i += 1\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n        /*Process payloads blanks*/\r\n        if (typeof (mediaSession.payloads) === 'string') {\r\n            mediaSession.payloads = mediaSession.payloads.replace(/[ ]+/g, ' ').replace(/^\\s*|\\s*$/g,\"\")\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Delete the codec according to the given codec list,\r\n     *  or delete the codec other than the given codec\r\n     *  SDPTools.removeCodecByName(parsedSdp, i, ['telephone-event', 'ISAC'])\r\n     * @param session\r\n     * @param index\r\n     * @param codecList\r\n     * @param keep\r\n     *      {\r\n     *          false: remove given codec （default）\r\n     *          true: remove other codec outside the given codec\r\n     *      }\r\n     *\r\n     */\r\n    removeCodecByName: function (session, index, codecList, keep) {\r\n        if (index >= session.media.length) {\r\n            console.log('Error index')\r\n            return\r\n        }\r\n\r\n        let payloads = []\r\n        let mediaSession = session.media[index]\r\n        let codecPtList = []\r\n\r\n        /*Get payloads by names*/\r\n        mediaSession.rtp.forEach(item => {\r\n            if(!keep){\r\n                // Delete given codec\r\n                codecList.forEach(codec => {\r\n                    if (item.codec === codec) {\r\n                        payloads.push(item.payload)\r\n                    }\r\n                })\r\n            }else {\r\n                // Delete the codec outside the given codec\r\n                if(!codecList.includes(item.codec)){\r\n                    payloads.push(item.payload)\r\n                } else {\r\n                    codecPtList.push(item.payload)\r\n                }\r\n            }\r\n        })\r\n\r\n        // 保存保留编码pt关联的的rtx行\r\n        codecPtList.map(item => {\r\n            mediaSession.fmtp.forEach(itemIn => {\r\n                if(itemIn.config.match('apt=' + item)){\r\n                    let rtxPtIndex = payloads.indexOf(itemIn.payload)\r\n                    if(rtxPtIndex >= 0){\r\n                        payloads.splice(rtxPtIndex, 1)\r\n                    }\r\n                }\r\n            })\r\n        });\r\n\r\n        this.removeCodecByPayload(session, index, payloads)\r\n    },\r\n\r\n    removeInvalidCode: function(sdp){\r\n        let parsedSdp = SDPTools.parseSDP(sdp)\r\n        let payloadUpdate = false\r\n\r\n        for (let i = 0; i < parsedSdp.media.length; i++){\r\n            let media = parsedSdp.media[i]\r\n            let removePayloads = []\r\n\r\n            if(media.type === 'video'){\r\n                if(media.payloads && media.payloads.split){  // There is no split if only one PT\r\n                    let mediaPayloads = media.payloads.split(' ')\r\n\r\n                    // 1.If fmtp or apt payload does not exist in m-section, delete fmtp and apt\r\n                    if(media.fmtp && media.fmtp.length){\r\n                        for(let j = 0; j<media.fmtp.length; j++){\r\n                            let fmtpPT = String(media.fmtp[j].payload)\r\n                            let aptPT\r\n                            if(media.fmtp[j].config && media.fmtp[j].config.match('apt=')){\r\n                                aptPT = media.fmtp[j].config.split('=')[1]\r\n                            }\r\n\r\n                            if((aptPT && mediaPayloads.indexOf(aptPT) < 0) || mediaPayloads.indexOf(fmtpPT) < 0){\r\n                                if(aptPT){\r\n                                    console.log('invalid apt payload: ', aptPT)\r\n                                    removePayloads.push(aptPT)\r\n                                }\r\n                                removePayloads.push(fmtpPT)\r\n                                console.log('invalid fmtp payload: ', fmtpPT)\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // 2.If rtp does not exist, delete\r\n                    if(media.rtp && media.rtp.length){\r\n                        for(let K = 0; K<media.rtp.length; K++){\r\n                            let rtpPT = String(media.rtp[K].payload)\r\n                            if(mediaPayloads.indexOf(rtpPT) < 0){\r\n                                console.log('invalid rtp payload: ', rtpPT)\r\n                                removePayloads.push(rtpPT)\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // 3.If rtcpFb does not exist, delete\r\n                    if(media.rtcpFb && media.rtcpFb.length){\r\n                        for(let K = 0; K<media.rtcpFb.length; K++){\r\n                            let rtcpFbPT = String(media.rtcpFb[K].payload)\r\n                            if(mediaPayloads.indexOf(rtcpFbPT) < 0){\r\n                                console.log('invalid rtcpFb payload: ', rtcpFbPT)\r\n                                removePayloads.push(rtcpFbPT)\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(removePayloads.length){\r\n                    removePayloads = (function(){\r\n                        return Array.from(new Set(removePayloads))\r\n                    })()\r\n                    for(let k = 0; k<removePayloads.length; k++){\r\n                        removePayloads[k] = parseInt(removePayloads[k])  // need int type payload\r\n                    }\r\n\r\n                    console.log(\"Delete invalid payload \", removePayloads)\r\n                    this.removeCodecByPayload(parsedSdp, i, removePayloads)\r\n                    payloadUpdate = true\r\n                }\r\n            }\r\n        }\r\n\r\n        if(payloadUpdate){\r\n            sdp = SDPTools.writeSDP(parsedSdp)\r\n        }\r\n        return sdp\r\n    },\r\n\r\n    /**\r\n     * get the capabilities of media\r\n     * @param sdp\r\n     * @param excludeList\r\n     * @returns {null|{audioCodecs: [], videoCodecs: []}}\r\n     */\r\n    getRTCRtpCapabilities: function(sdp, excludeList){\r\n        if (!sdp) {\r\n            console.warn('no sdp')\r\n            return null\r\n        }\r\n        if(!excludeList || !excludeList.length){\r\n            console.error('excludeList is not allowed to be empty')\r\n            return null\r\n        }\r\n        /* Define the static rtp payload mappings */\r\n        let staticPayloads = {\r\n            '0': 'PCMU',\r\n            '3': 'GSM',\r\n            '4': 'G723',\r\n            '5': 'DVI4',\r\n            '6': 'DVI4',\r\n            '7': 'LPC',\r\n            '8': 'PCMA',\r\n            '9': 'G722',\r\n            '10': 'L16',\r\n            '11': 'L16',\r\n            '12': 'QCELP',\r\n            '13': 'CN',\r\n            '14': 'MPA',\r\n            '15': 'G728',\r\n            '16': 'DVI4',\r\n            '17': 'DVI4',\r\n            '18': 'G729',\r\n            '25': 'CelB',\r\n            '26': 'JPEG',\r\n            '28': 'nv',\r\n            '31': 'H261',\r\n            '32': 'MPV',\r\n            '33': 'MP2T',\r\n            '34': 'H263',\r\n        }\r\n\r\n        let capabilities = { haveAudio: false, haveVideo: false }\r\n        // Only one video media line is parsed\r\n        let hasVideoGet = false\r\n        let session = SDPTools.parseSDP(sdp)\r\n        if (session && session.media && session.media.length) {\r\n            for (let i = 0; i < session.media.length; i++) {\r\n                let media = session.media[i]\r\n                if (media.type === 'audio') {\r\n                    capabilities.haveAudio = true\r\n                    if(!capabilities.audioCodecs){\r\n                        capabilities.audioCodecs = []\r\n                    }\r\n\r\n                    if (media.rtp && media.rtp.length) {\r\n                        for (let j = 0; j < media.rtp.length; j++) {\r\n                            let rtp = media.rtp[j]\r\n                            // get audio dynamic encoding\r\n                            if (rtp.codec && !excludeList.includes(rtp.codec) && !capabilities.audioCodecs.includes(rtp.codec)) {\r\n                                capabilities.audioCodecs.push(rtp.codec)\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    let payloads = media.payloads && media.payloads.split(' ')\r\n                    if(payloads && payloads.length){\r\n                        console.info('find static payloads')\r\n                        payloads.forEach(function(pt){\r\n                            // get audio static coding: Only static payload a=fmtp can be defaulted width SIP compression head\r\n                            if(pt<96 && !capabilities.audioCodecs.includes(staticPayloads[pt])){\r\n                                capabilities.audioCodecs.push(staticPayloads[pt])\r\n                            }\r\n                        })\r\n                    }\r\n                } else if (media.type === 'video' && !hasVideoGet) {\r\n                    capabilities.haveVideo = true\r\n                    if(!capabilities.videoCodecs){\r\n                        capabilities.videoCodecs = []\r\n                    }\r\n\r\n                    if (media.rtp && media.rtp.length) {\r\n                        for (let j = 0; j < media.rtp.length; j++) {\r\n                            let rtp = media.rtp[j]\r\n                            // get video dynamic coding\r\n                            if (rtp.codec && !excludeList.includes(rtp.codec) && !capabilities.videoCodecs.includes(rtp.codec)) {\r\n                                capabilities.videoCodecs.push(rtp.codec)\r\n                            }\r\n                        }\r\n                    }\r\n                    hasVideoGet = true\r\n                }\r\n            }\r\n        }\r\n\r\n        return capabilities\r\n    },\r\n\r\n    /**\r\n     * get PT by codec name\r\n     * @param session\r\n     * @param index\r\n     * @param codecList\r\n     * @returns {*}\r\n     */\r\n    getCodecByName: function(session, index, codecList){\r\n        if (index >= session.media.length) {\r\n            console.log('Error index')\r\n            return\r\n        }\r\n\r\n        let payloads = []\r\n        let mediaSession = session.media[index]\r\n\r\n        /*Get payloads by names*/\r\n        mediaSession.rtp.forEach(item => {\r\n            codecList.forEach(codec => {\r\n                if (item.codec === codec) {\r\n                    payloads.push(item.payload)\r\n                }\r\n            })\r\n        })\r\n\r\n        return payloads\r\n    },\r\n\r\n    /**\r\n     * set h264 level-id\r\n     * @param session\r\n     * @param index\r\n     * @param height\r\n     */\r\n    setH264Resolution: function(session, index, height){\r\n        if(!session || !height){\r\n            console.warn('h264 res: Invalid argument!')\r\n            return\r\n        }\r\n        let levelIdc = this.resolutionToLevelIdcMap[height] || '16'\r\n        let h264Codec = this.getCodecByName(session, index, ['H264'])\r\n        let media = session.media[index]\r\n\r\n        if(media){\r\n            let fmtp = media.fmtp\r\n            if(fmtp.length > 0){\r\n                for(let i = 0; i < fmtp.length; i++){\r\n                    let index  = fmtp[i].config.indexOf('profile-level-id')\r\n                    if(index >= 0){\r\n                        let str = fmtp[i].config.substr(index, 21);\r\n                        let replacement =  str + levelIdc ;\r\n                        fmtp[i].config = fmtp[i].config.replace(/profile-level-id=([a-zA-Z0-9]{6})/, replacement);\r\n                    }else{\r\n                        let rtxApt\r\n                        if (fmtp[i].config.indexOf('apt=') >= 0) {\r\n                            rtxApt = parseInt(fmtp[i].config.match('apt=[0-9]+')[0].split('=')[1])\r\n                        }\r\n\r\n                        if(h264Codec.includes(fmtp[i].payload) || h264Codec.includes(rtxApt)){\r\n                            fmtp[i].config =  fmtp[i].config + ';profile-level-id=42e0' + levelIdc\r\n                        }\r\n                    }\r\n                }\r\n            }else {\r\n                console.info('profile-level-id fmtp filed has not been find')\r\n            }\r\n        }else {\r\n            console.log('no media')\r\n        }\r\n    },\r\n\r\n    /**\r\n     * set VP8 max-fs\r\n     * @param session\r\n     * @param index\r\n     * @param width\r\n     * @param height\r\n     */\r\n    setVp8Resolution: function(session, index, width, height){\r\n        if(!session || !width || !height){\r\n            console.warn('VP8 res: Invalid argument!')\r\n            return\r\n        }\r\n        let mbWidth = (parseInt(width, 10) + 15) / 16;\r\n        let mbHeight = (parseInt(height, 10) + 15) / 16;\r\n        let maxFs = Math.floor(mbWidth) * Math.floor(mbHeight);\r\n\r\n        let vp8Codec = this.getCodecByName(session, index, ['VP8'])\r\n        let media = session.media[index]\r\n        if(media){\r\n            let fmtp = media.fmtp\r\n            for (let i = 0; i < fmtp.length; i++) {\r\n                let index = fmtp[i].config.indexOf('max-fs')\r\n                if (index >= 0) {\r\n                    let replacement = 'max-fs=' + maxFs;\r\n                    fmtp[i].config = fmtp[i].config.replace(/max-fs=([a-zA-Z0-9]{3,5})/, replacement);\r\n                }else {\r\n                    let rtxApt\r\n                    if (fmtp[i].config.indexOf('apt=') >= 0) {\r\n                        rtxApt = parseInt(fmtp[i].config.match('apt=[0-9]+')[0].split('=')[1])\r\n                    }\r\n\r\n                    if(vp8Codec.includes(fmtp[i].payload) || vp8Codec.includes(rtxApt)){\r\n                        fmtp[i].config = fmtp[i].config + ';max-fs=' + maxFs\r\n                    }\r\n                }\r\n            }\r\n        }else {\r\n            console.warn('no media found')\r\n        }\r\n    },\r\n\r\n    /**\r\n     * set resolution vp8 and h264\r\n     * @param session\r\n     * @param index\r\n     * @param width\r\n     * @param height\r\n     * @returns {null}\r\n     */\r\n    setResolution: function(session, index, width, height){\r\n        if (!session || !width || !height) {\r\n            console.error(\"Invalid argument\");\r\n            return null;\r\n        }\r\n\r\n        this.setH264Resolution(session, index, height)\r\n        this.setVp8Resolution(session, index, width, height)\r\n    },\r\n\r\n    /**\r\n     * get H264 resolution\r\n     * @param session\r\n     * @param index\r\n     * @returns {{width: number, height: number}}\r\n     */\r\n    getH264Resolution: function(session, index){\r\n        let resolution\r\n        let levelIdc\r\n\r\n        let media = session.media[index]\r\n        if(media){\r\n            for(let i = 0; i<media.fmtp.length; i++){\r\n                let index = media.fmtp[i].config.indexOf('profile-level-id=')\r\n                if(index >= 0){\r\n                    let levelId = media.fmtp[i].config.match('profile-level-id=[a-zA-Z0-9]{6}')[0].split('=')[1]\r\n                    levelIdc = levelId.substr(4, 2).toLocaleLowerCase()\r\n                    break\r\n                }\r\n            }\r\n            resolution = this.levelIdcToReSolutionMap[levelIdc] || { width: 640, height: 360 }\r\n        }\r\n\r\n        return resolution\r\n    },\r\n\r\n    /**\r\n     * get vp8 resolution\r\n     * @param session\r\n     * @param index\r\n     * @returns {{width: number, height: number}}\r\n     */\r\n    getVp8Resolution: function(session, index){\r\n        let resolution\r\n        let maxFs\r\n\r\n        let media = session.media[index]\r\n        if(media){\r\n            for(let i = 0; i<media.fmtp.length; i++){\r\n                let index = media.fmtp[i].config.indexOf('max-fs=')\r\n                let resolution\r\n                if(index >= 0){\r\n                    maxFs = parseInt(media.fmtp[i].config.match('max-fs=[0-9]+')[0].split('=')[1])\r\n                    break\r\n                }\r\n            }\r\n\r\n            maxFs = parseInt(maxFs)\r\n            resolution = this.maxFsToResolutionMap[maxFs] || { width: 640, height: 360 }\r\n        }\r\n\r\n        return resolution\r\n    },\r\n\r\n    /**\r\n     * get Priority code resolution\r\n     *  SDPTools.getResolution(parsedSdp, 1, 'VP8') or SDPTools.getResolution(parsedSdp, 1)\r\n     * @param session\r\n     * @param index\r\n     * @param codec\r\n     * @returns {*|string|{width: number, height: number}}\r\n     */\r\n    getResolution: function(session, index, codec){\r\n        if(!session || (!index && index !== 0)){\r\n            console.error(\"Invalid argument\");\r\n            return\r\n        }\r\n\r\n        codec = codec || this.getPriorityCodec(session, index)\r\n        let resolution\r\n        if(codec === 'H264'){\r\n            resolution = this.getH264Resolution(session, index)\r\n        }else if(codec === 'VP8'){\r\n            resolution = this.getVp8Resolution(session, index)\r\n        }\r\n\r\n        return resolution\r\n    },\r\n\r\n    /**\r\n     * Get the first PT value in SDP\r\n     * @param session\r\n     * @param index\r\n     * @returns {*}\r\n     */\r\n    getPriorityCodec: function(session, index){\r\n        if(!session){\r\n            console.warn('setFrameRate: Invalid argument!')\r\n            return\r\n        }\r\n\r\n        let media = session.media[index]\r\n        let codec\r\n        if(media){\r\n            if(media.rtp && media.rtp.length){\r\n                for(let i = 0; i<media.rtp.length; i++){\r\n                    if(media.rtp[i].codec && media.rtp[i].codec !== 'rtx'){\r\n                        codec = media.rtp[i].codec\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return codec\r\n    },\r\n\r\n    /**\r\n     * set frameRate\r\n     * framerate calculation order: framerate > max-fr\r\n     * @param session\r\n     * @param index\r\n     * @param framerate\r\n     */\r\n    setFrameRate: function(session, index, framerate){\r\n        if(!session || !framerate){\r\n            console.warn('setFrameRate: Invalid argument!')\r\n            return\r\n        }\r\n\r\n        let media = session.media[index]\r\n        if(media){\r\n            if(media.framerate){\r\n                media.framerate = framerate\r\n            }else if(media.fmtp && media.fmtp.length > 0){\r\n                let fmtp = media.fmtp\r\n                for(let i = 0; i < fmtp.length; i++){\r\n                    let index = fmtp[i].config.indexOf('max-fr')\r\n                    if (index >= 0) {\r\n                        let replacement =  'max-fr=' + framerate ;\r\n                        fmtp[i].config = fmtp[i].config.replace(/max-fr=([a-zA-Z0-9]{1,2})/, replacement);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get frameRate\r\n     * framerate calculation order: framerate > max-fr\r\n     * @param session\r\n     * @param index\r\n     * @returns {*}\r\n     */\r\n    getFramerate: function(session, index){\r\n        let media = session.media[index]\r\n        let framerate = null\r\n\r\n        if(media){\r\n            if(media.framerate){\r\n                framerate = media.framerate\r\n            }else if(media.fmtp && media.fmtp.length > 0){\r\n                let fmtp = media.fmtp\r\n                for(let i = 0; i<fmtp.length; i++){\r\n                    let pos_max_fr = fmtp[i].config.indexOf('max-fr')\r\n                    if (pos_max_fr >= 0) {\r\n                        var max_fr = fmtp[i].config.substring(pos_max_fr + 7);\r\n                        var end = max_fr.indexOf(';');\r\n                        if (end >= 0) {\r\n                            max_fr = max_fr.substring(0, end);\r\n                        }\r\n                        framerate =  parseInt(max_fr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return framerate\r\n    },\r\n\r\n    /**\r\n     * Process bandwidth relative: b line\r\n     * AS = TIAS/1000 + 192\r\n     * @param session\r\n     * @param index\r\n     * @param bitRate\r\n     */\r\n    setMediaBandwidth: function (session, index, bitRate) {\r\n        if(!session || !bitRate){\r\n            return\r\n        }\r\n\r\n        // There will be problems when the bandwidth 172 is less than 192\r\n        let bandwidth = {AS: bitRate/1000 + 192, TIAS: bitRate}\r\n        let media = session.media[index]\r\n        if(media){\r\n            if(media.bandwidth && media.bandwidth.length){\r\n                media.bandwidth.forEach(function (item){\r\n                    item.limit = bandwidth[item.type]\r\n                })\r\n            }else {\r\n                media.bandwidth = []\r\n                Object.keys(bandwidth).forEach(function (key) {\r\n                    if(key){\r\n                        media.bandwidth.push({\r\n                            type: key,\r\n                            limit: bandwidth[key]\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    },\r\n\r\n    setXgoogle: function(media, h264Codec, bitrate){\r\n        if(media.type === 'audio'){\r\n            return\r\n        }\r\n\r\n        if(media.fmtp && media.fmtp.length) {\r\n            for (let i = 0; i < media.fmtp.length; i++) {\r\n                if (h264Codec.includes(media.fmtp[i].payload)) {\r\n                    let config = media.fmtp[i].config\r\n                    if (config.indexOf('x-google-min-bitrate=') >= 0) {\r\n                        config = config.replace(/x-google-min-bitrate=([a-zA-Z0-9]{1,8})/, 'x-google-min-bitrate=' + bitrate)\r\n                    } else {\r\n                        config = config + ';x-google-min-bitrate=' + bitrate\r\n                    }\r\n\r\n                    if (config.indexOf('x-google-start-bitrate=') >= 0) {\r\n                        config = config.replace(/x-google-start-bitrate=([a-zA-Z0-9]{1,8})/, 'x-google-start-bitrate=' + bitrate)\r\n                    } else {\r\n                        config = config + ';x-google-start-bitrate=' + bitrate\r\n                    }\r\n\r\n                    if (config.indexOf('x-google-max-bitrate=') >= 0) {\r\n                        config = config.replace(/x-google-max-bitrate=([a-zA-Z0-9]{1,8})/, 'x-google-max-bitrate=' + bitrate)\r\n                    } else {\r\n                        config = config + ';x-google-max-bitrate=' + bitrate\r\n                    }\r\n                    media.fmtp[i].config = config\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * set x-google-min-bitrate;x-google-start-bitrate;x-google-max-bitrate\r\n     * @param session\r\n     * @param bitrate\r\n     * @param index\r\n     */\r\n    setXgoogleBitrate: function(session, bitrate, index){\r\n        if(index || index === 0){\r\n            let h264Codec = this.getCodecByName(session, index, ['H264'])\r\n            let media = session.media[index]\r\n            this.setXgoogle(media, h264Codec, bitrate)\r\n        }else {\r\n            // When the index parameter does not exist, modify all media rows\r\n            for(let i = 0; i<session.media.length; i++){\r\n                let h264Codec = this.getCodecByName(session, i, ['H264'])\r\n                let media = session.media[i]\r\n                this.setXgoogle(media, h264Codec, bitrate)\r\n            }\r\n        }\r\n    },\r\n\r\n    removeRembAndTransportCC: function(session, index){\r\n        let deleteRembTransportCC = function (media){\r\n            if(media.rtcpFb && media.rtcpFb.length){\r\n                for(let j = 0; j<media.rtcpFb.length; j++){\r\n                    let type = media.rtcpFb[j].type\r\n                    if(type && (type.indexOf('goog-remb') >= 0 || type.indexOf('transport-cc') >= 0)){\r\n                        media.rtcpFb.splice(j, 1)\r\n                        j--\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(index !== undefined){\r\n            let media = session.media[index]\r\n            deleteRembTransportCC(media)\r\n        }else {\r\n            // When the index parameter does not exist, modify all media rows\r\n            for(let i = 0; i<session.media.length; i++){\r\n                deleteRembTransportCC(session.media[i])\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * add candidate\r\n     * @param media\r\n     * @param candidate: candidate:956527311 1 udp 2122260223 192.168.9.9 9 typ host generation 0\r\n     */\r\n    addCandidate: function(media, candidate){\r\n        if(!media || !candidate){\r\n            return\r\n        }\r\n\r\n        if(!media.candidates || !media.candidates.length){\r\n            media.candidates = []\r\n        }\r\n\r\n        let type = candidate[0]\r\n        let content = candidate.slice(2)\r\n        for (let j = 0; j < (grammar[type] || []).length; j += 1) {\r\n            let obj = grammar[type][j]\r\n            if (obj.reg.test(content)) {\r\n                let keyLocation = {}\r\n                attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name)\r\n                if(keyLocation && !keyLocation.value){\r\n                    media.candidates.push(keyLocation)\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    parseFmtpConfig: function (str) {\r\n        return str.split(/;\\s?/).reduce(paramReducer, {})\r\n    },\r\n\r\n    parsePayloads: function (str) {\r\n        return str.toString().split(' ').map(Number)\r\n    },\r\n\r\n    parseRemoteCandidates: function (str) {\r\n        let candidates = []\r\n        let parts = str.split(' ').map(toIntIfInt)\r\n        for (let i = 0; i < parts.length; i += 3) {\r\n            candidates.push({\r\n                component: parts[i],\r\n                ip: parts[i + 1],\r\n                port: parts[i + 2]\r\n            })\r\n        }\r\n        return candidates\r\n    },\r\n\r\n    parseImageAttributes: function (str) {\r\n        return str.split(' ').map(function (item) {\r\n            return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {})\r\n        })\r\n    },\r\n\r\n    parseSimulcastStreamList: function (str) {\r\n        return str.split(';').map(function (stream) {\r\n            return stream.split(',').map(function (format) {\r\n                let scid\r\n                let paused = false\r\n\r\n                if (format[0] !== '~') {\r\n                    scid = toIntIfInt(format)\r\n                } else {\r\n                    scid = toIntIfInt(format.substring(1, format.length))\r\n                    paused = true\r\n                }\r\n\r\n                return { scid: scid, paused: paused }\r\n            })\r\n        })\r\n    },\r\n\r\n    /*Merge SDP, SDPs must be a SDP STRING array*/\r\n    mergeSDP: function (SDPs) {\r\n        let mergedSDP\r\n        let mergedSession\r\n        let sessions = []\r\n\r\n        for (let i = 0; i < SDPs.length; i += 1) {\r\n            sessions[i] = this.parseSDP(SDPs[i])\r\n        }\r\n\r\n        /***Process msid mapping***/\r\n        //for ( let i = 0; i < SDPs.length; i += 1 ) {\r\n        //    sessions[i].media.msid\r\n        //}\r\n\r\n        /***Process mid mapping***/\r\n        let id = 0\r\n        for (let i = 0; i < SDPs.length; i += 1) {\r\n            for (let j = 0; j < sessions[i].media.length; j += 1) {\r\n                let item = {}\r\n                item['msid'] = sessions[i].media[j].msid\r\n                item['mid'] = sessions[i].media[j].mid\r\n                item['mappedMID'] = id\r\n                this.midMap.push(item)\r\n\r\n                /*Modified the group a line*/\r\n                if (typeof (sessions[i].groups[0].mids) === 'string') {\r\n                    sessions[i].groups[0].mids = sessions[i].groups[0].mids.replace(sessions[i].media[j].mid, id)\r\n                } else if (typeof (sessions[i].groups[0].mids) === 'number') {\r\n                    sessions[i].groups[0].mids = id\r\n                } else {\r\n                    console.log('ERROR on Process mid mapping')\r\n                }\r\n\r\n                /*Modified the mid*/\r\n                sessions[i].media[j].mid = id\r\n\r\n                id += 1\r\n            }\r\n        }\r\n\r\n        /***Merge session level part***/\r\n        if (sessions[0].groups === undefined) {\r\n            sessions[0].groups = []\r\n        }\r\n\r\n        if (sessions[0].msidSemantics === undefined) {\r\n            sessions[0].msidSemantics = []\r\n        }\r\n\r\n        for (let i = 0; i < SDPs.length; i += 1) {\r\n            console.log('Session ' + i + 'th:\\n' + sessions[i])\r\n            /*Process ssesion fingerprint a line*/\r\n            if (sessions[i].fingerprint !== undefined) {\r\n                sessions[i].media.forEach(\r\n                    function (m) {\r\n                        m['fingerprint'] = deepCopy(sessions[i].fingerprint)\r\n                    })\r\n\r\n                delete sessions[i].fingerprint\r\n            }\r\n\r\n            /*Process copy all groups a line*/\r\n            if (sessions[i].groups !== undefined) {\r\n                if (i > 0) {\r\n                    sessions[i].groups.forEach(\r\n                        function (g) {\r\n                            sessions[0].groups.push(deepCopy(g))\r\n                        })\r\n                }\r\n            }\r\n\r\n            /*Process MSID a line*/\r\n            if (sessions[i].msidSemantics !== undefined) {\r\n                if (i > 0) {\r\n                    sessions[i].msidSemantics.forEach(\r\n                        function (msid) {\r\n                            sessions[0].msidSemantics.push(deepCopy(msid))\r\n                        })\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /***Merge media level part***/\r\n        for (let i = 0; i < SDPs.length; i += 1) {\r\n            if (sessions[i].media !== undefined) {\r\n                if (i > 0) {\r\n                    sessions[i].media.forEach(\r\n                        function (m) {\r\n                            sessions[0].media.push(deepCopy(m))\r\n                        })\r\n                }\r\n            }\r\n        }\r\n\r\n        /***Process C line and port of M line, if has ICE candidate***/\r\n        mergedSDP = this.writeSDP(sessions[0])\r\n        return mergedSDP\r\n    },\r\n\r\n    /*Split SDP, return SDP STRING array*/\r\n    splitSDP: function (SDP) {\r\n        let sdpArray = []\r\n        let session = this.parseSDP(SDP)\r\n        if (session.groups === undefined) {\r\n            console.log('No GROUP information, need to split m lines to each pc')\r\n            session.groups = []\r\n            this.midMap = []\r\n            for (let i = 0; i < session.media.length; i += 1) {\r\n                /*Make fake groups*/\r\n                session.groups.push({ type: 'BUNDLE', mids: session.media[i].mid })\r\n                let item = {}\r\n                item['msid'] = session.media[i].msid\r\n                item['mid'] = 0\r\n                item['mappedMID'] = session.media[i].mid\r\n                this.midMap.push(item)\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < session.groups.length; i += 1) {\r\n            let sdp\r\n            let sess = deepCopy(session)\r\n\r\n            sess.groups = new Array(sess.groups[i])\r\n            if (sess.msidSemantics !== undefined) {\r\n                sess.msidSemantics = new Array(sess.msidSemantics[i])\r\n            } else {\r\n                delete sess.msidSemantics\r\n            }\r\n            let media = []\r\n\r\n            if (typeof (sess.groups[i].mids) === 'number') {\r\n                for (let j = 0; j < sess.media.length; j += 1) {\r\n                    if (sess.media[j].mid === sess.groups[i].mids) {\r\n                        media.push(sess.media[j])\r\n                        break\r\n                    }\r\n                }\r\n            } else if (typeof (sess.groups[i].mids) === 'string') {\r\n                sess.groups[0].mids.split(' ').forEach(mid => {\r\n                    for (let j = 0; j < sess.media.length; j += 1) {\r\n                        if (sess.media[j].mid === mid) {\r\n                            media.push(sess.media[j])\r\n                            break\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            sess.media = media\r\n\r\n            /***Revert the mid mapping***/\r\n            for (let k = 0; k < sess.media.length; k += 1) {\r\n                for (let l = 0; l < this.midMap.length; l += 1) {\r\n                    if (sess.media[k].mid === this.midMap[l].mappedMID) {\r\n                        sess.media[k].mid = this.midMap[l].mid\r\n\r\n                        if (typeof (sess.groups[0].mids) === 'string') {\r\n                            sess.groups[0].mids = sess.groups[0].mids.replace(sess.media[k].mid, this.midMap[l].mid)\r\n                        } else if (typeof (sess.groups[0].mids) === 'number') {\r\n                            sess.groups[0].mids = this.midMap[l].mid\r\n                        } else {\r\n                            console.log('ERROR on Process mid mapping')\r\n                        }\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            /***Revert the msid mapping***/\r\n            sdp = this.writeSDP(sess)\r\n            sdpArray.push(sdp)\r\n        }\r\n        return sdpArray\r\n    }\r\n}\r\n\n/**\r\n * AMD, CommonJS, Global compatible Script Wrapper\r\n * https://github.com/umdjs/umd\r\n */\r\n(function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n        define([], factory);\r\n        /* istanbul ignore next */\r\n    } else if (typeof exports === 'object') {\r\n        // Node. Does not work with strict CommonJS, but\r\n        // only CommonJS-like environments that support module.exports,\r\n        // like Node.\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals (root is window)\r\n        root.MediaDevice = factory();\r\n    }\r\n}(this, function () {\r\n\r\n\r\n    function MediaDevice() {\r\n        this.deviceCheckTimer = null\r\n    }\r\n\r\n    /***\r\n     * 获取分辨率扫描列表\r\n     */\r\n    MediaDevice.prototype.getQuickScanList = function () {\r\n        return [\r\n            {\r\n                \"label\": \"4K(UHD)\",\r\n                \"width\": 3840,\r\n                \"height\": 2160,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"4K(UHD)\",\r\n                \"width\": 3840,\r\n                \"height\": 2160,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"1080p(FHD)\",\r\n                \"width\": 1920,\r\n                \"height\": 1080,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"1080p(FHD)\",\r\n                \"width\": 1920,\r\n                \"height\": 1080,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"UXGA\",\r\n                \"width\": 1600,\r\n                \"height\": 1200,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"UXGA\",\r\n                \"width\": 1600,\r\n                \"height\": 1200,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"720p(HD)\",\r\n                \"width\": 1280,\r\n                \"height\": 720,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"720p(HD)\",\r\n                \"width\": 1280,\r\n                \"height\": 720,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"SVGA\",\r\n                \"width\": 800,\r\n                \"height\": 600,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"SVGA\",\r\n                \"width\": 800,\r\n                \"height\": 600,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"VGA\",\r\n                \"width\": 640,\r\n                \"height\": 480,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"VGA\",\r\n                \"width\": 640,\r\n                \"height\": 480,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"360p(nHD)\",\r\n                \"width\": 640,\r\n                \"height\": 360,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"360p(nHD)\",\r\n                \"width\": 640,\r\n                \"height\": 360,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"CIF\",\r\n                \"width\": 352,\r\n                \"height\": 288,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"CIF\",\r\n                \"width\": 352,\r\n                \"height\": 288,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QVGA\",\r\n                \"width\": 320,\r\n                \"height\": 240,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QVGA\",\r\n                \"width\": 320,\r\n                \"height\": 240,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"180p?\",\r\n                \"width\": 320,\r\n                \"height\": 180,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"180p?\",\r\n                \"width\": 320,\r\n                \"height\": 180,\r\n                \"ratio\": \"16:9\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QCIF\",\r\n                \"width\": 176,\r\n                \"height\": 144,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QCIF\",\r\n                \"width\": 176,\r\n                \"height\": 144,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            },\r\n            {\r\n                \"label\": \"QQVGA\",\r\n                \"width\": 160,\r\n                \"height\": 120,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 30\r\n            },\r\n            {\r\n                \"label\": \"QQVGA\",\r\n                \"width\": 160,\r\n                \"height\": 120,\r\n                \"ratio\": \"4:3\",\r\n                \"frameRate\": 15\r\n            }\r\n        ];\r\n    }\r\n\r\n    /***\r\n     * 获取音视频设备并进行分类\r\n     * @param deviceInfoCallback\r\n     * @param error\r\n     */\r\n    MediaDevice.prototype.enumDevices = function (deviceInfoCallback, error) {\r\n        if (navigator.mediaDevices === undefined || navigator.mediaDevices.enumerateDevices === undefined) {\r\n            if (error) {\r\n                error(\"browser don't support enumerate devices\")\r\n            }\r\n            return\r\n        }\r\n        navigator.mediaDevices.enumerateDevices().then(function (deviceInfos) {\r\n            var microphone = []\r\n            var speaker = []\r\n            var camera = []\r\n            var screenResolution = []\r\n            var isConstraintsKeywordSupport = true\r\n            for (var i = 0; i < deviceInfos.length; i++) {\r\n                var deviceInfo = deviceInfos[i]\r\n                if(deviceInfo.deviceId === 'default' || deviceInfo.deviceId === 'communications'){\r\n                    continue\r\n                }\r\n                if (deviceInfo.kind === 'audioinput') {\r\n                    microphone.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                    })\r\n                }\r\n                if (deviceInfo.kind === 'audiooutput') {\r\n                    speaker.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                    })\r\n                }\r\n                if (deviceInfo.kind === 'videoinput') {\r\n                    camera.push({\r\n                        label: deviceInfo.label,\r\n                        deviceId: deviceInfo.deviceId,\r\n                        groupId: deviceInfo.groupId,\r\n                        status: 'available',\r\n                        capability: []\r\n                    })\r\n                }\r\n            }\r\n\r\n            screenResolution.push({\r\n                width: window.screen.width,\r\n                height: window.screen.height,\r\n            })\r\n\r\n            if (deviceInfoCallback) {\r\n                deviceInfoCallback({\r\n                    microphones: microphone,\r\n                    speakers: speaker,\r\n                    cameras: camera,\r\n                    screenResolution: screenResolution,\r\n                    isConstraintsKeywordSupport: isConstraintsKeywordSupport\r\n                })\r\n            } else {\r\n                return {\r\n                    microphones: microphone,\r\n                    speakers: speaker,\r\n                    cameras: camera,\r\n                    screenResolution: screenResolution,\r\n                    isConstraintsKeywordSupport: isConstraintsKeywordSupport\r\n                }\r\n            }\r\n        }).catch(function (err) {\r\n            if (error) {\r\n                error(err)\r\n            }\r\n        })\r\n    }\r\n\r\n    /***\r\n     * 更新localStorage存储\r\n     * @param deviceInfos 所有的媒体数据\r\n     * @param type ： cameras / microphones / speakers， 更新的类型\r\n     */\r\n    MediaDevice.prototype.updateDeviceInfo = function (deviceInfos, type) {\r\n        var localStorageDeviceInfo = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var deviceInfoList = []\r\n        var storageInfoList = []\r\n\r\n        switch (type) {\r\n            case 'cameras':\r\n                deviceInfoList = deviceInfos.cameras\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.cameras ? localStorageDeviceInfo.cameras : [] : []\r\n                break\r\n            case 'microphones':\r\n                deviceInfoList = deviceInfos.microphones\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.microphones ? localStorageDeviceInfo.microphones : [] : []\r\n                break\r\n            case 'speakers':\r\n                deviceInfoList = deviceInfos.speakers\r\n                storageInfoList = localStorageDeviceInfo ? localStorageDeviceInfo.speakers ? localStorageDeviceInfo.speakers : [] : []\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        /***\r\n         * 判断localStorage中的设备是否有还存在，不存在则设置状态为 unavailable，还存在的置为available\r\n         * @param deviceInfoList\r\n         * @param storageInfoList\r\n         */\r\n        function setDeviceStatus(deviceInfoList, storageInfoList) {\r\n            for (var i = 0; i < storageInfoList.length; i++) {\r\n                for (var j = 0; j < deviceInfoList.length; j++) {\r\n                    if (storageInfoList[i].label === deviceInfoList[j].label) {\r\n                        if (storageInfoList[i].status === 'unavailable') {\r\n                            log.log('set device unavailable to available!')\r\n                            storageInfoList[i].status = 'available'\r\n                        }\r\n                        storageInfoList[i].deviceId = deviceInfoList[j].deviceId\r\n                        storageInfoList[i].groupId = deviceInfoList[j].groupId\r\n                        break\r\n                    }\r\n                    if (storageInfoList[i].label !== deviceInfoList[j].label && j === deviceInfoList.length - 1 && storageInfoList[i].status !== 'unavailable') {\r\n                        log.warn(storageInfoList[i].label + \"   device is unavailable\")\r\n                        storageInfoList[i].status = 'unavailable'\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /***\r\n         * 判断设备是否是新设备，是的话，添加到localStorage中\r\n         * @param deviceInfoList\r\n         * @param storageInfoList\r\n         */\r\n        function addInsertDevice(deviceInfoList, storageInfoList) {\r\n            for (var i = 0; i < deviceInfoList.length; i++) {\r\n                for (var j = 0; j < storageInfoList.length; j++) {\r\n                    if (deviceInfoList[i].label === storageInfoList[j].label) {\r\n                        storageInfoList[j].deviceId = deviceInfoList[i].deviceId\r\n                        storageInfoList[j].groupId = deviceInfoList[i].groupId\r\n                        break\r\n                    }\r\n                    if (deviceInfoList[i].label !== storageInfoList[j].label && j === storageInfoList.length - 1) {\r\n                        log.warn(\"new device has been insert!\")\r\n                        storageInfoList.push(deviceInfoList[i])\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 本地存储没有任何值，直接设置获取的设备列表到localStorage中\r\n        if (deviceInfoList.length && !storageInfoList.length) {\r\n            log.warn(\"set new device info list\")\r\n            localStorage.setItem('mediaDevice', JSON.stringify(deviceInfos, null, '    '))\r\n            return\r\n        }\r\n\r\n        // 未获取当任何有效的设备列表，localStorage保存的设备全部设置为不可用\r\n        if (!deviceInfoList.length && storageInfoList.length) {\r\n            log.warn('set all device to unavailable');\r\n            for (var i = 0; i < storageInfoList.length; i++) {\r\n                storageInfoList[i].status = 'unavailable'\r\n            }\r\n            localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))\r\n            return\r\n        }\r\n\r\n        // 获取到设备列表，且localStorage中有设备存储信息\r\n        setDeviceStatus(deviceInfoList, storageInfoList)\r\n        addInsertDevice(deviceInfoList, storageInfoList)\r\n        log.log('update modified device info into localStorage!')\r\n        localStorage.setItem('mediaDevice', JSON.stringify(localStorageDeviceInfo, null, '    '))\r\n    }\r\n\r\n    /***\r\n     * 清除流\r\n     * @param stream\r\n     */\r\n    MediaDevice.prototype.closeStream = function (stream) {\r\n        try {\r\n            var tracks = stream.getTracks();\r\n            for (var track in tracks) {\r\n                tracks[track].onended = null;\r\n                log.log(\"close stream\");\r\n                tracks[track].stop();\r\n            }\r\n        } catch (e) {\r\n            log.error(e)\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 判断取流是否支持关键字：min/max/exact/ideal\r\n     * 常见：测试一体机不支持关键字\r\n     * @returns {Promise<boolean>}\r\n     */\r\n    MediaDevice.prototype.isConstraintsKeywordSupport = async function () {\r\n        var This = this\r\n        var result = true\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var isKeywordSupport = mediaDevice ? mediaDevice.isConstraintsKeywordSupport : null\r\n\r\n        if (isKeywordSupport !== null) {\r\n            result = isKeywordSupport\r\n        } else {\r\n            var constraints = {\r\n                audio: false,\r\n                video: {\r\n                    width: {ideal: 640},\r\n                    height: {ideal: 360}\r\n                }\r\n            }\r\n\r\n            function onGetUserMediaSuccess(stream){\r\n                log.log('constraints keyWords support')\r\n                result = true\r\n                This.closeStream(stream)\r\n            }\r\n\r\n            function onGetUserMediaFailed(error){\r\n                console.error(error)\r\n                log.log('ideal is not support' + error.message)\r\n                result = false\r\n            }\r\n\r\n            log.log(\"isConstraintsKeywordSupport test constraints: \\n\" + JSON.stringify(constraints, null, '    '));\r\n            try {\r\n                var stream = await navigator.mediaDevices.getUserMedia(constraints)\r\n                onGetUserMediaSuccess(stream)\r\n            }catch(error){\r\n                onGetUserMediaFailed(error)\r\n            }\r\n        }\r\n\r\n        log.info('is constraints Keyword support: ', result)\r\n        return result\r\n    }\r\n\r\n    /***\r\n     * 使用exact关键字取流\r\n     * @returns {Promise<void>}\r\n     */\r\n    MediaDevice.prototype.getStreamWithExactConstraints = async function () {\r\n        var This = this\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var quickScanList = This.getQuickScanList()\r\n        var localStream\r\n        var constraints\r\n\r\n        function onGetUserMediaSuccess(stream) {\r\n            // log.info('applyConstraints success' + JSON.stringify(constraints, null, '    '))\r\n            log.info(\"get Stream Success : \" + quickScanList[i].width + \" x \" + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);\r\n            if(stream){\r\n                localStream = stream\r\n            }\r\n\r\n            capability.push({\r\n                width: quickScanList[i].width,\r\n                height: quickScanList[i].height,\r\n                frameRate: quickScanList[i].frameRate,\r\n                aspectRatio: quickScanList[i].ratio\r\n            })\r\n\r\n            if (j === mediaDevice.cameras.length - 1 && i === quickScanList.length - 1) {\r\n                log.log(\"Resolution scan completed, clear stream.\")\r\n                This.closeStream(localStream)\r\n            }\r\n        }\r\n\r\n        function onGetUserMediaFailed(error) {\r\n            if (error.name === 'ConstraintNotSatisfiedError') {\r\n                log.info('The resolution ' + quickScanList[i].width + 'x' +\r\n                  quickScanList[i].height + ' px and frameRate with ' +  quickScanList[i].frameRate + ' is not supported by your device.');\r\n            } else if (error.name === 'PermissionDeniedError') {\r\n                log.info('Permissions have not been granted to use your camera and ' +\r\n                  'microphone, you need to allow the page access to your devices in ' +\r\n                  'order for the demo to work.');\r\n            }\r\n            // log.error('getUserMedia error: ' + error.name, error);\r\n            log.info(\"fail: mismatch : \" + quickScanList[i].width + \" x \" + quickScanList[i].height + 'px, ' + 'frameRate: ' + quickScanList[i].frameRate);\r\n        }\r\n\r\n        for (var j = 0; j < mediaDevice.cameras.length; j++) {\r\n            // 换摄像头时需要重新取流，避免使用applyConstraints时不换摄像头的场景\r\n            if (localStream) {\r\n                This.closeStream(localStream)\r\n            }\r\n            // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描\r\n            if (mediaDevice.cameras[j].capability && mediaDevice.cameras[j].capability.length > 0) {\r\n                log.warn(\"this device has already get resolution before: \" + mediaDevice.cameras[j].label)\r\n                continue\r\n            }\r\n\r\n            log.warn(\"Current scan device：\", mediaDevice.cameras[j].label)\r\n            var deviceId = mediaDevice.cameras[j].deviceId\r\n            var capability = mediaDevice.cameras[j].capability\r\n\r\n\r\n            // 存在问题：不使用关键字时，applyConstraints和getUserMedia取流都存在不准确问题，比如1920*1080，摄像头不支持该分辨率也能取流成功，因为取的是别的分辨率\r\n            for (var i = 0; i < quickScanList.length; i++) {\r\n                var videoTrack = localStream ? localStream.getVideoTracks()[0] : null\r\n                if (localStream && localStream.active === true && localStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {\r\n                    constraints = {\r\n                        frameRate: {exact: quickScanList[i].frameRate},\r\n                        aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                        width: {exact: quickScanList[i].width},\r\n                        height: {exact: quickScanList[i].height}\r\n                    }\r\n                    try {\r\n                        await videoTrack.applyConstraints(constraints)\r\n                        onGetUserMediaSuccess()\r\n                    }catch (error) {\r\n                        onGetUserMediaFailed(error)\r\n                    }\r\n                } else {\r\n                    constraints = {\r\n                        audio: false,\r\n                        video: {\r\n                            frameRate: {exact: quickScanList[i].frameRate},\r\n                            aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                            width: {\r\n                                max: quickScanList[i].width,\r\n                                exact: quickScanList[i].width\r\n                            },\r\n                            height: {\r\n                                max: quickScanList[i].height,\r\n                                exact: quickScanList[i].height\r\n                            },\r\n                        }\r\n                    }\r\n                    if(deviceId){\r\n                        constraints.video.deviceId = { exact: deviceId}\r\n                    }\r\n\r\n                    try {\r\n                        let stream = await navigator.mediaDevices.getUserMedia(constraints)\r\n                        onGetUserMediaSuccess(stream)\r\n                    }catch (error) {\r\n                        onGetUserMediaFailed(error)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))\r\n    }\r\n\r\n    // 创建video标签\r\n    var cameraPrevVideo = document.createElement('video')\r\n    cameraPrevVideo.onloadedmetadata = MediaDevice.prototype.displayVideoDimensions;\r\n    /***\r\n     * video 元数据加载完成后触发，用于判断取流后的分辨率与实际要求是否一致\r\n     * @param scanListIndex 当前扫描的分辨率列表的索引值\r\n     * @param cameraIndex 当前扫描的摄像头列表值\r\n     */\r\n    MediaDevice.prototype.displayVideoDimensions = function (scanListIndex, cameraIndex) {\r\n        var This = this\r\n        var i = scanListIndex\r\n        var j = cameraIndex\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var capability = mediaDevice.cameras[j].capability\r\n        var quickScanList = This.getQuickScanList()\r\n        log.log(\"Video onloadedmetadata call~~~\");\r\n\r\n        function captureResults(data) {\r\n            if (data.result === true) {\r\n                log.log(\"pass\")\r\n                capability.push({\r\n                    width: quickScanList[i].width,\r\n                    height: quickScanList[i].height,\r\n                    frameRate: quickScanList[i].frameRate,\r\n                    aspectRatio: quickScanList[i].ratio\r\n                })\r\n                localStorage.setItem('mediaDevice', JSON.stringify(mediaDevice, null, '    '))\r\n            } else {\r\n                log.log(\"fail: mismatch\")\r\n            }\r\n\r\n            i++\r\n            if (i < quickScanList.length) {\r\n                log.log('Scan the next resolution')\r\n                window.isScanCameraChange = false\r\n                This.getStreamWithoutConstraintsKeyWords(i, j)\r\n            } else if (j < mediaDevice.cameras.length - 1) {\r\n                log.log('Scan the next camera')\r\n                window.isScanCameraChange = true\r\n                This.closeStream(stream)\r\n                j++;\r\n                i = 0;\r\n                This.getStreamWithoutConstraintsKeyWords(i, j)\r\n            } else {\r\n                This.closeStream(stream)\r\n                log.log(\"All camera capabilities are End of scan ~~\")\r\n                cameraPrevVideo = null\r\n            }\r\n        }\r\n\r\n        if (!cameraPrevVideo.videoWidth) {\r\n            setTimeout(function () {\r\n                This.displayVideoDimensions(scanListIndex, cameraIndex)\r\n            }, 500);  //was 500\r\n        }\r\n\r\n        if (cameraPrevVideo.videoWidth * cameraPrevVideo.videoHeight > 0) {\r\n            log.info(\"Display size for : \" + quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height);\r\n            log.info(\"Stream dimensions for :\" + cameraPrevVideo.videoWidth + \"x\" + cameraPrevVideo.videoHeight);\r\n            if (quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height !== cameraPrevVideo.videoWidth + \"x\" + cameraPrevVideo.videoHeight) {\r\n                log.info(\"fail: mismatch\")\r\n                captureResults({result: false})\r\n            } else {\r\n                log.info(\"pass :\" + quickScanList[scanListIndex].width + \"x\" + quickScanList[scanListIndex].height)\r\n                captureResults({result: true})\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /***\r\n     * 兼容不支持min/max/ideal/exact的情况，使用{audio:false, video: { width: 1280, height: 720}} 格式取流\r\n     * 通过取流后的video实际尺寸判断取流是否成功\r\n     * @param scanListIndex 当前扫描的分辨率列表的索引值\r\n     * @param cameraIndex 当前扫描的摄像头列表值\r\n     * @returns {Promise<void>}\r\n     */\r\n    MediaDevice.prototype.getStreamWithoutConstraintsKeyWords = async function (scanListIndex, cameraIndex) {\r\n        var This = this\r\n        var quickScanList = This.getQuickScanList()\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var i = scanListIndex\r\n        var j = cameraIndex\r\n        var mediaStream = window.stream\r\n        var deviceId = mediaDevice.cameras[j].deviceId\r\n        var capability = mediaDevice.cameras[j].capability\r\n        var constraints;\r\n\r\n        // 当前循环设备之前已经有分辨率扫描的记录，不重新扫描\r\n        if (window.isScanCameraChange === true && capability && capability.length > 0) {\r\n            log.warn(\"this device has already get resolution before: \" + mediaDevice.cameras[j].label)\r\n            cameraIndex++\r\n            if (cameraIndex < mediaDevice.cameras.length) {\r\n                log.warn('Scan the next device')\r\n                This.getStreamWithoutConstraintsKeyWords(scanListIndex, cameraIndex)\r\n            }\r\n            return\r\n        }\r\n        window.isScanCameraChange = false\r\n\r\n        function onGetUserMediaSuccess(stream) {\r\n            log.log('applyConstraints success' + JSON.stringify(constraints, null, '    '))\r\n            log.log(\"Display size for \" + quickScanList[i].label + \": \" + quickScanList[i].width + \"x\" + quickScanList[i].height);\r\n\r\n            if(stream){\r\n                window.stream = stream\r\n                cameraPrevVideo.srcObject = stream\r\n            }\r\n\r\n            setTimeout(function () {\r\n                This.displayVideoDimensions(scanListIndex, cameraIndex)\r\n            }, 2000);\r\n        }\r\n\r\n        function onGetUserMediaFailed(error){\r\n            log.warn('applyConstraints error: ', error.name)\r\n        }\r\n\r\n        log.warn(\"Current scan device：\", mediaDevice.cameras[j].label)\r\n        var videoTrack = mediaStream ? mediaStream.getVideoTracks()[0] : null\r\n        if (mediaStream && mediaStream.active === true && mediaStream.getVideoTracks().length > 0 && videoTrack.applyConstraints) {\r\n            constraints = {\r\n                frameRate: quickScanList[i].frameRate,\r\n                width: quickScanList[i].width,\r\n                height: quickScanList[i].height,\r\n                aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n            }\r\n\r\n           try {\r\n               await videoTrack.applyConstraints(constraints)\r\n               onGetUserMediaSuccess()\r\n           }catch (error) {\r\n               onGetUserMediaFailed(error)\r\n           }\r\n        } else {\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    deviceId: deviceId,\r\n                    frameRate: quickScanList[i].frameRate,\r\n                    width: quickScanList[i].width,\r\n                    height: quickScanList[i].height,\r\n                    aspectRatio: {exact: quickScanList[i].width / quickScanList[i].height},\r\n                }\r\n            }\r\n\r\n           try {\r\n               await navigator.mediaDevices.getUserMedia(constraints)\r\n               onGetUserMediaSuccess(stream)\r\n           }catch (error) {\r\n               onGetUserMediaFailed(error)\r\n           }\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 设置设备所支持的取流能力：frameRate, width, height\r\n     */\r\n    MediaDevice.prototype.setDeviceCapability = async function () {\r\n        log.warn('device capability scanning')\r\n        var This = this\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        // 判断取流是否支持关键字设置\r\n        var isKeywordSupport = await This.isConstraintsKeywordSupport()\r\n        mediaDevice.isConstraintsKeywordSupport = isKeywordSupport\r\n\r\n        if (mediaDevice && mediaDevice.cameras.length > 0) {\r\n            if (isKeywordSupport === true) {\r\n                log.info(\"min/max/ideal/exact keyWord is support\")\r\n                await This.getStreamWithExactConstraints()\r\n            } else {\r\n                log.info(\"min/max/ideal/exact keyWord is  NOT support\")\r\n                window.isScanCameraChange = true\r\n                await This.getStreamWithoutConstraintsKeyWords(0, 0)\r\n            }\r\n        } else {\r\n            log.warn('no cameras need to resolution scan!')\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 检查可用设备列表\r\n     */\r\n    MediaDevice.prototype.checkAvailableDev = function () {\r\n        var This = this\r\n\r\n        This.enumDevices(function (deviceInfo) {\r\n            // log.log(\"get device info success: \\n\", JSON.stringify(deviceInfo))\r\n            function setLabel(devices, type) {\r\n                for (var key = 0; key < devices.length; key++) {\r\n                    if (!devices[key].label) {\r\n                        devices[key].label = type + key\r\n                    }\r\n                    log.log(type + \" \" + devices[key].label)\r\n                }\r\n                return devices\r\n            }\r\n\r\n            if (deviceInfo) {\r\n                if (deviceInfo.cameras) {\r\n                    setLabel(deviceInfo.cameras, 'cameras')\r\n                }\r\n                if (deviceInfo.microphones) {\r\n                    setLabel(deviceInfo.microphones, 'microphones')\r\n                }\r\n                if (deviceInfo.speakers) {\r\n                    setLabel(deviceInfo.speakers, 'speakers')\r\n                }\r\n\r\n                This.updateDeviceInfo(deviceInfo, \"cameras\")\r\n                This.updateDeviceInfo(deviceInfo, \"microphones\")\r\n                This.updateDeviceInfo(deviceInfo, \"speakers\")\r\n            } else {\r\n                log.warn(\"deviceInfo is null\")\r\n            }\r\n\r\n        }, function (error) {\r\n            log.error('enum device error: ' + error.toString())\r\n        })\r\n    }\r\n\r\n    /***\r\n     * 设备定时检查开关\r\n     * @param switchOn: true 开启定时器；  false 关闭定时器\r\n     */\r\n    MediaDevice.prototype.setDeviceCheckInterval = function (switchOn) {\r\n        var This = this\r\n        if (switchOn) {\r\n            clearInterval(This.deviceCheckTimer)\r\n            This.deviceCheckTimer = setInterval(function () {\r\n                This.checkAvailableDev()\r\n            }, 1000)\r\n        } else {\r\n            clearInterval(This.deviceCheckTimer);\r\n            This.deviceCheckTimer = null\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取最接近，最合适的设备支持的分辨率\r\n     * @param expectRes 当前希望获取的分辨率，eg {\r\n     *   deviceId: 4b5305afd805f2d8439eac80dc94b14846799929d44d18c7dd8fc97eda75c046\r\n     *   frameRate: 15,\r\n     *   width: 1080,\r\n     *   height: 720\r\n     * }\r\n     */\r\n    MediaDevice.prototype.getSuitableResolution = function (expectRes) {\r\n        if (!expectRes.deviceId || !expectRes.width || !expectRes.height || !expectRes.frameRate) {\r\n            log.warn('Invalid parameter');\r\n            return\r\n        }\r\n\r\n        var mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        var capability = []\r\n        var sameWidthList = []\r\n        var matchRes = {}\r\n\r\n        if (mediaDevice && mediaDevice.cameras.length > 0) {\r\n            // 获取给定设备支持的取流能力列表\r\n            for (var i = 0; i < mediaDevice.cameras.length; i++) {\r\n                if (mediaDevice.cameras[i].deviceId === expectRes.deviceId) {\r\n                    capability = mediaDevice.cameras[i].capability\r\n                    log.warn(\"capability: \", capability)\r\n                    break\r\n                }\r\n            }\r\n\r\n            // 过滤出相同width的分辨率\r\n            if (capability.length > 0) {\r\n                for (var j = 0; j < capability.length; j++) {\r\n                    if (capability[j].width === expectRes.width) {\r\n                        sameWidthList.push(capability[j])\r\n                    }\r\n                }\r\n                log.warn(\"sameWidthList: \", sameWidthList)\r\n            }\r\n\r\n            // 获取最合适的分辨率\r\n            if (sameWidthList.length > 0) {\r\n                for (var k = 0; k < sameWidthList.length; k++) {\r\n                    // 返回width height frameRate 都相同的分辨率\r\n                    if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {\r\n                        log.warn('Returns the resolution of width height frameRate', sameWidthList[k])\r\n                        matchRes = sameWidthList[k]\r\n                        break\r\n                    }\r\n                }\r\n\r\n                if (JSON.stringify(matchRes) === \"{}\") {\r\n                    for (var k = 0; k < sameWidthList.length; k++) {\r\n                        // 返回width height相同， frameRate 小于期望值的的分辨率\r\n                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height === expectRes.height && sameWidthList[k].frameRate < expectRes.frameRate) {\r\n                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])\r\n                            matchRes = sameWidthList[k]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (JSON.stringify(matchRes) === \"{}\") {\r\n                    for (var k = 0; k < sameWidthList.length; k++) {\r\n                        // 返回width frameRate 相同， height 小于期望值的的分辨率\r\n                        if (sameWidthList[k].width === expectRes.width && sameWidthList[k].height < expectRes.height && sameWidthList[k].frameRate === expectRes.frameRate) {\r\n                            log.warn('Returns the resolution where the width height is the same and the frameRate is less than the expected value. ', sameWidthList[k])\r\n                            matchRes = sameWidthList[k]\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                log.warn(\"no same with resolution exist, get other resolution;\")\r\n                // 返回设备支持的最大的、width比期望值小的分辨率\r\n                for (var j = 0; j < capability.length; j++) {\r\n                    if (capability[j].width < expectRes.width) {\r\n                        log.log('Returns the maximum resolution supported by the device with a smaller width than expected')\r\n                        matchRes = capability[j]\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            return matchRes\r\n        }\r\n        return matchRes\r\n    }\r\n\r\n    /******************************************************************************************************************/\r\n    /******************************************************* 取流 *****************************************************/\r\n    /******************************************************************************************************************/\r\n    /***\r\n     * 取流： audio/video/screenShare\r\n     * @param data {\r\n     *      callback: callback,\r\n        streamType: \"video\",\r\n        constraintsKeyWord: \"exact\",\r\n        constraints: {\r\n            aspectRatio: {min: 1.777, max: 1.778},\r\n            frameRate: 30,\r\n            width: 1280,\r\n            height: 720,\r\n            deviceId: deviceId,\r\n        }\r\n     * }\r\n     * @param constraints\r\n     */\r\n    MediaDevice.prototype.getMedia = async function (data, constraints) {\r\n        log.warn(\"getMedia\")\r\n        var This = this\r\n        if (!constraints) {\r\n            constraints = This.getConstraints(data, true)\r\n        }\r\n\r\n        function onGetStreamSuccess(stream) {\r\n            data.callback({stream: stream})\r\n        }\r\n\r\n        function onGetStreamFailed(error) {\r\n            data.settings = constraints\r\n            data.error = error\r\n            log.error(\"onGetStreamFailed: \", error.name, error.message)\r\n            if(error.name === \"OverconstrainedError\" || error.name === \"ConstraintNotSatisfiedError\"){\r\n                // constraints can not be satisfied by avb.device\r\n                log.warn('constraints can not be satisfied by avb.device')\r\n                This.getMedia(data)\r\n            }else {\r\n                if(error.name === \"NotFoundError\" || error.name === \"DeviceNotFoundError\"){\r\n                    // require track is missing\r\n                    log.warn('require track is missing')\r\n                }else if(error.name === \"NotReadableError\" || error.name === \"TrackStartError\"){\r\n                    // webcam or mic are already in use\r\n                    log.warn('webcam or mic are already in use')\r\n                }else if(error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\" || error.name === \"PermissionDismissedError\" ){\r\n                    // permission denied in browser\r\n                    log.warn('permission denied in browser')\r\n                }else if(error.name === \"TypeError\"){\r\n                    // empty constraints object\r\n                    log.warn('empty constraints object')\r\n                }else {\r\n                    // other errors\r\n                    log.warn('other errors ' + error.name)\r\n                }\r\n                data.callback({error: error})\r\n            }\r\n        }\r\n\r\n        if (data.streamType === 'audio' || data.streamType === 'video') {\r\n            let stream = data.stream\r\n            let videoTrack = null\r\n            if (data.streamType === 'video' && stream && stream.getVideoTracks().length && stream.active === true) {\r\n                videoTrack = stream.getVideoTracks()[0]\r\n                var constraintsOfApply = constraints.video\r\n                if (videoTrack && videoTrack.applyConstraints) {\r\n                    log.warn(\"applyConstraints constraints: \", JSON.stringify(constraintsOfApply, null, '    '))\r\n                    await videoTrack.applyConstraints(constraintsOfApply).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n                }\r\n            } else {\r\n                // audio and video not\r\n                log.warn(\"getUserMedia constraints: \", JSON.stringify(constraints, null, '    '))\r\n                navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            }\r\n        } else if (data.streamType === 'screenShare') {\r\n            if (navigator.getDisplayMedia) {\r\n                navigator.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            } else if (navigator.mediaDevices.getDisplayMedia) {\r\n                navigator.mediaDevices.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed)\r\n            } else {\r\n                log.info('getDisplayMedia is not supported by current browser')\r\n                // 使用插件共享桌面\r\n                alert(\"当前浏览器不支持桌面共享\")\r\n            }\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取分辨率\r\n     * @param data, eg.{\r\n        constraintsKeyWord: \"exact\"\r\n        deviceId: \"8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03\"\r\n        frameRate: 30s\r\n        height: 720\r\n        streamType: \"video\"\r\n        width: 1280\r\n     * }\r\n     * @param reTry: true 取流失败后重新取流， false 第一次取流\r\n     */\r\n    MediaDevice.prototype.getConstraints = function (data, reTry) {\r\n        let This = this\r\n        let constraints = {}\r\n        switch (data.streamType) {\r\n            case 'audio':\r\n                constraints = {\r\n                    audio: data.deviceId ? {deviceId: data.deviceId} : true,\r\n                    video: false\r\n                }\r\n                break;\r\n            case 'video':\r\n                constraints = This.getVideoConstraints(data, reTry)\r\n                break\r\n            case 'screenShare':\r\n                constraints = This.getScreenShareConstraints(data)\r\n                break\r\n            default:\r\n                break\r\n        }\r\n\r\n        return constraints\r\n    }\r\n\r\n    /***\r\n     * 获取video 分辨率\r\n     * @param data 需要得参数\r\n     constraintsKeyWord: \"exact\"\r\n     deviceId: \"8cd24e4d2ff8de04d9170e94899fdb24a10ac7c9d09cb90bbe796e754f768d03\"\r\n     frameRate: 15\r\n     height: 720\r\n     streamType: \"video\"\r\n     width: 1280\r\n     * @param reTry 需要得参数 : true 取流失败重新取流, false 第一次取流\r\n     * @returns {{audio: boolean, video: {frameRate: {exact: number}, width: {exact: number}, aspectRatio: {exact: number}, height: {exact: number}}}}\r\n     */\r\n    MediaDevice.prototype.getVideoConstraints = function (data, reTry) {\r\n        let This = this\r\n        let matchResolution = {}\r\n        let currentLimit = {}\r\n        let deviceId\r\n\r\n        if (reTry) {\r\n            // 这种方式不需要重复获取匹配了\r\n            currentLimit = This.getNextConstraints(data)\r\n            deviceId = currentLimit.deviceId\r\n            matchResolution = currentLimit\r\n        } else {\r\n            // 默认首次取流都使用exact\r\n            deviceId = data.deviceId\r\n            currentLimit = data\r\n            log.info(\"deviceId: \", deviceId)\r\n            if (deviceId) {\r\n                matchResolution = This.getSuitableResolution({\r\n                    frameRate: currentLimit.frameRate ? currentLimit.frameRate : 30,\r\n                    width: currentLimit.width ? currentLimit.width : 640,\r\n                    height: currentLimit.height ? currentLimit.height : 360,\r\n                    deviceId: currentLimit.deviceId\r\n                })\r\n                log.log(\"match constraints: \", matchResolution)\r\n            }\r\n        }\r\n\r\n        log.info(\"currentLimit: \", currentLimit)\r\n        let constraints = {\r\n            audio: false,\r\n            video: {\r\n                frameRate: {\r\n                    exact: matchResolution.frameRate ? matchResolution.frameRate : currentLimit.frameRate ? currentLimit.frameRate : 30\r\n                },\r\n                aspectRatio: {\r\n                    exact: matchResolution.width ? (matchResolution.width / matchResolution.height) : (currentLimit.width / currentLimit.height)\r\n                },\r\n                width: {\r\n                    exact: matchResolution.width ? matchResolution.width : currentLimit.width ? currentLimit.width : 640\r\n                },\r\n                height: {\r\n                    exact: matchResolution.height ? matchResolution.height : currentLimit.height ? currentLimit.height : 360\r\n                }\r\n            }\r\n        }\r\n\r\n        if (deviceId) {\r\n            constraints.video.deviceId = {\r\n                exact: deviceId\r\n            }\r\n        }\r\n\r\n        log.log(\"data.constraintsKeyWord: \", data.constraintsKeyWord)\r\n        if (!data.constraintsKeyWord) {\r\n            log.warn(\"Do not use keyWord limit\")\r\n            constraints.video.frameRate = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio = constraints.video.aspectRatio.exact\r\n            constraints.video.width = constraints.video.width.exact\r\n            constraints.video.height = constraints.video.height.exact\r\n            if (constraints.video.deviceId.exact || constraints.video.deviceId.ideal) {\r\n                constraints.video.deviceId = constraints.video.deviceId.exact ? constraints.video.deviceId.exact : constraints.video.deviceId.ideal\r\n            }\r\n        } else if (data.constraintsKeyWord === 'ideal') {\r\n            log.warn(\"Use ideal limit\")\r\n            constraints.video.frameRate.ideal = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio.ideal = constraints.video.aspectRatio.exact\r\n            constraints.video.width.ideal = constraints.video.width.exact\r\n            constraints.video.height.ideal = constraints.video.height.exact\r\n            // 使用max限制来避免超出要求的能力\r\n            constraints.video.frameRate.max = constraints.video.frameRate.exact\r\n            constraints.video.aspectRatio.max = constraints.video.aspectRatio.exact\r\n            constraints.video.width.max = constraints.video.width.exact\r\n            constraints.video.height.max = constraints.video.height.exact\r\n            if (constraints.video.deviceId.exact) {\r\n                constraints.video.deviceId.ideal = constraints.video.deviceId.exact\r\n            }\r\n            // 删除exact属性\r\n            delete constraints.video.frameRate.exact\r\n            delete constraints.video.aspectRatio.exact\r\n            delete constraints.video.width.exact\r\n            delete constraints.video.height.exact\r\n            delete constraints.video.deviceId.exact\r\n        } else if (data.constraintsKeyWord === 'exact') {\r\n            log.warn(\"Use exact limit\")\r\n        }\r\n\r\n        log.warn(\"get new Video Constraints: \", JSON.stringify(constraints, null, '   '))\r\n        return constraints\r\n    }\r\n\r\n    /***\r\n     * 取流失败后根据设备支持的能力列表获取下一个分辨率\r\n     * @param data = {\r\n     *      callback: ƒ (message)\r\n        constraints: {aspectRatio: {…}, frameRate: 30, width: 1280, height: 720, deviceId: \"5e3722883e2e9337040a4f1ababf85a5bd2f6a36afc815fd391424ac05a84ab0\"}\r\n        constraintsKeyWord: \"ideal\"\r\n        error: OverconstrainedError {name: \"OverconstrainedError\", message: null, constraint: \"frameRate\"}\r\n        settings: {audio: false, video: {…}}\r\n        streamType: \"video\"\r\n     * }\r\n     * @returns {{frameRate: number, streamType: string, width: number, deviceId: (*|number|boolean|string|string[]|ConstrainDOMStringParameters|\"user\"|\"environment\"|\"left\"|\"right\"|VideoFacingModeEnum[]), constraintsKeyWord: (string), height: number}}\r\n     */\r\n    MediaDevice.prototype.getNextConstraints = function (data) {\r\n        let This = this\r\n        // 获取上一次取流失败的分辨率限制\r\n        let lastSettings = data.settings\r\n        let settings = {\r\n            frameRate: lastSettings.video.frameRate.exact ? lastSettings.video.frameRate.exact : lastSettings.video.frameRate.ideal ? lastSettings.video.frameRate.ideal : lastSettings.video.frameRate,\r\n            width: lastSettings.video.width.exact ? lastSettings.video.width.exact : lastSettings.video.width.ideal ? lastSettings.video.width.ideal : lastSettings.video.width,\r\n            height: lastSettings.video.height.exact ? lastSettings.video.height.exact : lastSettings.video.height.ideal ? lastSettings.video.height.ideal : lastSettings.video.height,\r\n            deviceId: lastSettings.video.deviceId.exact ? lastSettings.video.deviceId.exact : lastSettings.video.deviceId.ideal ? lastSettings.video.deviceId.ideal : lastSettings.video.deviceId,\r\n        }\r\n\r\n        // 获取下一个分辨率\r\n        let deviceId = settings.deviceId ? settings.deviceId : data.deviceId\r\n        let capability = This.getCapability(deviceId)\r\n        let nextConstraints\r\n        for (let j = 0; j < capability.length; j++) {\r\n            if (capability[j].width === settings.width && capability[j].height === settings.height && capability[j].frameRate === settings.frameRate) {\r\n                nextConstraints = capability[j + 1]\r\n                break\r\n            }\r\n        }\r\n\r\n        log.log(\"nextConstraints: \", nextConstraints)\r\n        // 如果nextConstraints不存在，说明能力列表全部扫描完成，换其他的限制尝试（exact/ideal/不使用）\r\n        if (!nextConstraints) {\r\n            log.warn(\"Change the restriction condition.\")\r\n            if (data.constraintsKeyWord === 'exact') {\r\n                log.warn(\"Exact has been scanned, using ideals\")\r\n                data.constraintsKeyWord = 'ideal'\r\n            } else if (data.constraintsKeyWord === 'ideal') {\r\n                log.warn(\"The ideal has been scanned. Do not use keywords\")\r\n                data.constraintsKeyWord = ''\r\n            } else {\r\n                // 取流彻底失败，调用回调返回\r\n                log.warn(\"The flow failed completely, and the flow was not taken.\")\r\n                data.callback({error: data.error})\r\n            }\r\n        }\r\n\r\n        return {\r\n            constraintsKeyWord: data.constraintsKeyWord,\r\n            streamType: data.streamType,\r\n            deviceId: settings.deviceId ? settings.deviceId : data.deviceId,\r\n            frameRate: nextConstraints ? nextConstraints.frameRate ? nextConstraints.frameRate : data.constraints.frameRate : data.constraints.frameRate,\r\n            width: nextConstraints ? nextConstraints.width ? nextConstraints.width : data.constraints.width : data.constraints.width,\r\n            height: nextConstraints ? nextConstraints.height ? nextConstraints.height : data.constraints.height : data.constraints.height,\r\n        }\r\n    }\r\n\r\n    /***\r\n     * 获取屏幕共享分辨率\r\n     * @param data\r\n     * @returns {{audio: boolean, video: {frameRate: {max: string}, width: {max: string}, height: {max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, mozMediaSource: *, width: {min: string, max: string}, mediaSource: *, height: {min: string, max: string}}}|{audio: boolean, video: {frameRate: {min: string, max: string}, width: {min: string, max: string}, logicalSurface: boolean, displaySurface: string, height: {min: string, max: string}}}|{audio: boolean, video: {optional: {sourceId: string}[], mandatory: {minFrameRate: number, maxFrameRate: number}}}}\r\n     */\r\n    MediaDevice.prototype.getScreenShareConstraints = function (data) {\r\n        let screenConstraints\r\n        /***\r\n         * for all supported getDisplayMedia browser versions\r\n         */\r\n        if (navigator.mediaDevices.getDisplayMedia) {\r\n            screenConstraints = {\r\n                audio: false,\r\n                video: {\r\n                    width: {max: '1920'},\r\n                    height: {max: '1080'},\r\n                    frameRate: {max: '5'}\r\n                }\r\n            };\r\n        }\r\n\r\n        /***\r\n         * for Firefox\r\n         */\r\n        if (!!navigator.mozGetUserMedia) {\r\n            screenConstraints = {\r\n                audio: false,\r\n                video: {\r\n                    mozMediaSource: source,\r\n                    mediaSource: source,\r\n                    width: {min: '10', max: '1920'},\r\n                    height: {min: '10', max: '1080'},\r\n                    frameRate: {min: '1', max: '5'}\r\n                }\r\n            };\r\n        }\r\n\r\n        /***\r\n         * for Edge\r\n         */\r\n        if (adapter.browserDetails.browser === \"edge\") {\r\n            if (adapter.browserDetails.version >= 17134 && !!navigator.getDisplayMedia) {\r\n                screenConstraints = {\r\n                    audio: false,\r\n                    video: {\r\n                        displaySurface: 'window',\r\n                        logicalSurface: true,\r\n                        width: {min: '10', max: '1920'},\r\n                        height: {min: '10', max: '1080'},\r\n                        frameRate: {min: '1', max: '5'}\r\n                    }\r\n                };\r\n            } else {\r\n                log.warn(\"This version of Edge does not support screen capture feature\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        return screenConstraints\r\n    }\r\n\r\n    /***\r\n     * 根据deviceId 获取当前设备的设备支持能力\r\n     * 设备信息定时更新的，所以deviceId不会存在不匹配问题\r\n     * @param deviceId\r\n     * @returns {Array}\r\n     */\r\n    MediaDevice.prototype.getCapability = function (deviceId) {\r\n        let This = this\r\n        let mediaDevice = JSON.parse(localStorage.getItem('mediaDevice'))\r\n        let capability = []\r\n        let cameras = mediaDevice.cameras\r\n        if (cameras && cameras.length) {\r\n            for (let i = 0; i < cameras.length; i++) {\r\n                if (cameras[i].deviceId === deviceId) {\r\n                    capability = cameras[i].capability\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!capability.length) {\r\n            capability = This.getQuickScanList()\r\n        }\r\n        log.info(\"capability: \", capability)\r\n\r\n        return capability\r\n    }\r\n\r\n    return MediaDevice;\r\n\r\n}));\nvar log = {};\r\nlog.debug = window.debug(\"WEBRTC_API:DEBUG\");\r\nlog.log = window.debug(\"WEBRTC_API:LOG\");\r\nlog.info = window.debug(\"WEBRTC_API:INFO\");\r\nlog.warn = window.debug(\"WEBRTC_API:WARN\");\r\nlog.error = window.debug(\"WEBRTC_API:ERROR\");\r\n/*Log Debug End*/\r\n/**\r\n * 呼叫\r\n * @param wsAddr websocket地址\r\n * @param callback 回调\r\n */\r\nfunction call(wsAddr, callback) {\r\n    let protocol = 'gs-webrtc-json';\r\n    if(!wsAddr){\r\n        log.error('INVALID WEBSOCKET ADDRESS：' + wsAddr)\r\n        gsRTC.trigger(\"error\",{codeType:gsRTC.CODE_TYPE.INVALID_WEBSOCKET_ADDRESS.codeType,message:gsRTC.CODE_TYPE.INVALID_WEBSOCKET_ADDRESS.message})\r\n        return\r\n    }\r\n\r\n    let sipRegisterInfo = {\r\n        protocol: protocol,\r\n        url: wsAddr,\r\n        callback: callback\r\n    }\r\n\r\n    if( !gsRTC.isWFUShareScreenSupport()) {\r\n        log.warn(\"当前浏览器版本不支持屏幕共享\")\r\n        log.warn(\"支持屏幕共享的浏览器版本分别是：Chrome是72版本以上、opera是60版本以上、firefox是60版本以上、edge是79版本以上、Safari是13.1.1版本以上\")\r\n        gsRTC.trigger(\"error\",{codeType:gsRTC.CODE_TYPE.NOT_SUPPORT_SCREEN_SHARE.codeType,message:gsRTC.CODE_TYPE.NOT_SUPPORT_SCREEN_SHARE.message})\r\n    }else {\r\n        function successCallBack() {\r\n            log.info(\"determine whether to create a new webSocket\")\r\n            if(!gsRTC.sokect || !gsRTC.sokect.ws || (gsRTC.sokect && gsRTC.sokect.ws && gsRTC.sokect.ws.readyState !== 1)){\r\n                gsRTC.sokect = new WebSocketInstance(sipRegisterInfo)\r\n            } else {\r\n                gsRTC.inviteCall({callback:sipRegisterInfo.callback});\r\n            }\r\n        }\r\n\r\n        if(gsRTC.getBrowserDetail().browser === 'safari'){\r\n            function safariGetMediaCallBack(event){\r\n                if(event.stream){\r\n                    log.info('get stream success '+ event.stream.id)\r\n                    gsRTC.shareScreenStream = event.stream\r\n                    successCallBack()\r\n                }else{\r\n                    gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.isCallSuccess = 'false'\r\n                    gsRTC.trigger(\"error\",{codeType:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.codeType,message:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.message,isCallSuccess:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.isCallSuccess})\r\n                }\r\n            }\r\n\r\n            let data = {streamType: 'screenShare', callback: safariGetMediaCallBack}\r\n\r\n            gsRTC.getPreImgSize(function(resolution,bitrate,frame) {\r\n                let getWebUIResolution = gsRTC.getResolutionFromWebUI(resolution)\r\n                let newFrame = parseInt(frame)\r\n                let constraints = {\r\n                    audio: false,\r\n                    video: {\r\n                        width: {\r\n                            ideal: getWebUIResolution.width ||1920,\r\n                            max:  getWebUIResolution.width || 1920,\r\n                        },\r\n                        height: {\r\n                            ideal:getWebUIResolution.height || 1080,\r\n                            max: getWebUIResolution.height  || 1080,\r\n                        },\r\n                        frameRate: {\r\n                            ideal:  newFrame || 15,\r\n                            max:  newFrame || 15\r\n                        }\r\n                    }\r\n\r\n                };\r\n                gsRTC.device.getMedia(data, constraints)\r\n            })\r\n        }else{\r\n            successCallBack()\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 开启屏幕共享\r\n * @param callback\r\n */\r\nfunction beginScreen(callback){\r\n    log.info('start present!!')\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n    let data = {\r\n        type: 'slides',\r\n        callback: callback\r\n    }\r\n    let session = gsRTC.RTCSession\r\n\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            if(session.openSharingTimestamp <= 30 ){\r\n                try {\r\n                    log.info('get stream success, ' + event.stream.id)\r\n                    let stream = event.stream\r\n                    let type = 'slides'\r\n\r\n                    if (gsRTC.getBrowserDetail().browser === 'firefox') {\r\n                        let tracks = stream.getVideoTracks();\r\n                        tracks[0].onended = function () {\r\n                            gsRTC.oninactiveStopStream(stream)\r\n                        }\r\n                    }else{\r\n                        stream.oninactive= function () {\r\n                            gsRTC.oninactiveStopStream(stream)\r\n                        }\r\n                    }\r\n                    session.setStream(stream, type, true)\r\n                    data.stream = stream\r\n                    if(session.sharingPermission !== 3){\r\n                        session.sharingPermission = 1\r\n                    }\r\n                    gsRTC.shareScreen(data)\r\n                }catch (e) {\r\n                    console.error(e)\r\n                }\r\n            }else{\r\n                session.openSharingTimestamp = null\r\n                session.stopTrack(event.stream)\r\n                session.sharingPermission = 1\r\n            }\r\n        }else {\r\n            log.error('Get present stream failed: ' + event.error)\r\n            if(gsRTC.getBrowserDetail().browser === 'firefox'){\r\n                gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.rejectAuthorizationTip  = 'true'\r\n            }\r\n\r\n            if(session.sharingPermission === 3){\r\n                session.openSharingTimeoutstartTime = null\r\n                session.openSharingTimestamp = null\r\n                session.sendCtrlPresentation = false\r\n                if(session.timeBox){\r\n                    clearInterval(session.timeBox)\r\n                    session.timeBox = null\r\n                }\r\n                gsRTC.action = 'shareScreenRequest'\r\n                gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON, reqId: session.reqId})\r\n                gsRTC.trigger('error',{codeType:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.codeType,message:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.message,\r\n                    rejectAuthorizationTip: gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.rejectAuthorizationTip})\r\n                session.sharingPermission = 0\r\n\r\n            }else{\r\n                session.sharingPermission = 0\r\n                gsRTC.action = 'shareScreen'\r\n                gsRTC.trigger('error',{codeType:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.codeType,message:gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.message,\r\n                    rejectAuthorizationTip: gsRTC.CODE_TYPE.CANCEL_PRESENT_ON.rejectAuthorizationTip})\r\n            }\r\n        }\r\n    }\r\n\r\n    let gumData = {streamType: 'screenShare', callback: getMediaCallBack}\r\n    let constraints = {\r\n        audio: false,\r\n        video: {\r\n            width: {\r\n                ideal: session.initialResolution && session.initialResolution.width || 1920,\r\n                max:  session.initialResolution && gsRTC.RTCSession.initialResolution.width || 1920\r\n            },\r\n            height: {\r\n                ideal: session.initialResolution && session.initialResolution.height ||1080,\r\n                max: session.initialResolution && session.initialResolution.height || 1080\r\n            },\r\n            frameRate: {\r\n                ideal: session.initialResolution && session.initialResolution.framerate || 15,\r\n                max: session.initialResolution && session.initialResolution.framerate || 15\r\n            }\r\n        }\r\n    };\r\n    log.info(JSON.stringify(constraints, null, ' '))\r\n\r\n    if(gsRTC.shareScreenStream){\r\n        getMediaCallBack({stream: gsRTC.shareScreenStream})\r\n        gsRTC.shareScreenStream = null\r\n    }else{\r\n        if(session.sharingPermission == 3){\r\n            if(session.openSharingTimestamp <= 30){\r\n                gsRTC.device.getMedia(gumData, constraints)\r\n            }\r\n        }else{\r\n            gsRTC.device.getMedia(gumData, constraints)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 暂停屏幕共享\r\n * @param isMute：true 暂停，false 取消暂停\r\n * @param callback\r\n */\r\nfunction pausePresent(isMute, callback){\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    let type = 'slides'\r\n    let stream = gsRTC.RTCSession.getStream(type, true)\r\n    log.info('pause present stream')\r\n    gsRTC.RTCSession.streamMuteSwitch({type: type, stream: stream, mute: isMute})\r\n    if(callback){\r\n        callback(gsRTC.CODE_TYPE.SUCCESS)\r\n    }\r\n}\r\n\r\n/**\r\n * 停止桌面共享\r\n * @param callback\r\n */\r\nfunction stopScreen(callback){\r\n    log.info('stop present!!')\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    if(gsRTC.RTCSession.sharingPermission !==  2){\r\n        gsRTC.RTCSession.sharingPermission = 0\r\n    }\r\n    if(gsRTC.RTCSession.openSharing === false){\r\n        log.info(\"No stream or Reject shareScreen or stopShareScreen request again after replying to the signaling\")\r\n        if(gsRTC.RTCSession.sharingPermission === 2) {\r\n            gsRTC.RTCSession.sendCtrlPresentation = false\r\n            gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet:gsRTC.CODE_TYPE.REJECT_MULTIPLE_REQUESTS, reqId: gsRTC.RTCSession.reqId})\r\n        }\r\n    }else{\r\n        gsRTC.stopShareScreen({callback: callback})\r\n    }\r\n}\r\n\r\n/**\r\n * 开摄像头\r\n * @param data\r\n */\r\nfunction beginVideo(data){\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n    gsRTC.shareVideo(data)\r\n}\r\n\r\n/**\r\n * 关闭摄像头\r\n * @param callback 回调\r\n */\r\nfunction stopVideo(callback){\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    gsRTC.stopShareVideo({callback: callback})\r\n}\r\n\r\n/**\r\n * 挂断\r\n */\r\nfunction hangUP(callback) {\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    if(!gsRTC.sokect){\r\n        log.warn(\"socket is not exist\")\r\n        return\r\n    }\r\n    if(gsRTC.RTCSession.sharingPermission !==  4){\r\n        gsRTC.RTCSession.sharingPermission = 5\r\n    }\r\n    gsRTC.endCall({callback: callback})\r\n}\r\n\r\n/**\r\n * 请求远端开启共享\r\n */\r\nfunction openRemoteControl(callback) {\r\n    log.info(\"Start request open remoteVideo\")\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    if(!gsRTC.sokect){\r\n        log.warn(\"socket is not exist\")\r\n        return\r\n    }\r\n\r\n    gsRTC.openRemoteVideo({callback: callback})\r\n}\r\n\r\n\r\n/**\r\n * 请求远端关闭共享\r\n */\r\nfunction stopRemoteControl(callback){\r\n    log.info(\"Stop request stop remoteVideo\")\r\n    if (!gsRTC) {\r\n        log.warn('gsRTC is not initialized')\r\n        return\r\n    }\r\n    if (!gsRTC.RTCSession) {\r\n        log.warn(\"please call first\")\r\n        return\r\n    }\r\n\r\n    if(!gsRTC.sokect){\r\n        log.warn(\"socket is not exist\")\r\n        return\r\n    }\r\n\r\n    gsRTC.stopRemoteVideo({callback: callback})\r\n}\r\n\r\n\nvar log = {};\r\nlog.debug = window.debug(\"GSRTC_API:DEBUG\");\r\nlog.log = window.debug(\"GSRTC_API:LOG\");\r\nlog.info = window.debug(\"GSRTC_API:INFO\");\r\nlog.warn = window.debug(\"GSRTC_API:WARN\");\r\nlog.error = window.debug(\"GSRTC_API:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * WebRTC API Instance\r\n * @constructor\r\n */\r\nvar GsRTC = function (options) {\r\n    this.sokect = null\r\n    this.RTCSession = null\r\n\r\n    this.EVENTS = []\r\n    // 上层注册事件\r\n    this.handlerFuns = []\r\n\r\n    this.conf = options;\r\n    this.sessionVersion = 0\r\n    this.action = null\r\n    this.serverAction = null\r\n    this.shareScreenStream = null                          // 共享桌面流\r\n\r\n    this.device = new MediaDevice()\r\n    this.eventBindings()\r\n    this.trigger()\r\n}\r\n\r\nwindow.onload = function () {\r\n    var oReadyStateTimer = setInterval(function () {\r\n            if (document.readyState === \"complete\") {\r\n                if(!GsRTC){\r\n                    log.warn(\"ERR_NOT_LOADED: GsRTC not loaded yet.\")\r\n                    return\r\n                }\r\n                clearInterval(oReadyStateTimer);\r\n                // initialize gsRTC\r\n                GsRTC.prototype.preInit()\r\n            }\r\n        },\r\n        500);\r\n}\r\n\r\n/**\r\n * gsRTC init\r\n */\r\nGsRTC.prototype.preInit = function() {\r\n    log.info('create new GsRTC object');\r\n    try {\r\n        let options = {}\r\n        window.gsRTC = new GsRTC(options);\r\n    }catch (e) {\r\n        log.error(e.toString())\r\n    }\r\n}\r\n\r\n/**\r\n * Binding page media elements\r\n * @param args\r\n */\r\nGsRTC.prototype.setHtmlMediaElement = function(args){\r\n    try {\r\n        this.HTML_MEDIA_ELEMENT.localAudio = args.localAudio\r\n        this.HTML_MEDIA_ELEMENT.localVideo = args.localVideo\r\n        this.HTML_MEDIA_ELEMENT.localPresentVideo = args.localPresentVideo\r\n        this.HTML_MEDIA_ELEMENT.localVideoShare = args.localVideoShare\r\n        this.HTML_MEDIA_ELEMENT.remoteAudio = args.remoteAudio\r\n        this.HTML_MEDIA_ELEMENT.remoteVideo = args.remoteVideo\r\n        this.HTML_MEDIA_ELEMENT.remotePresentVideo = args.remotePresentVideo\r\n        this.HTML_MEDIA_ELEMENT.remoteVideoShare = args.remoteVideoShare\r\n    }catch (e) {\r\n        throw new Error(e);\r\n    }\r\n}\r\n\r\n/**\r\n * call and send invite\r\n * @param data\r\n */\r\nGsRTC.prototype.inviteCall = function (data) {\r\n    let This = this\r\n    This.conf = {\r\n        userName: 'webRTC_Client',\r\n    }\r\n    This.action = 'call'\r\n    if(data && data.callback && !This.EVENTS[This.action]){\r\n        This.on(This.action, data.callback)\r\n    }\r\n    This.RTCSession = new PeerConnection(This)\r\n    This.RTCSession.createMultiStreamRTCSession(This.conf)\r\n}\r\n/**\r\n * share local audio\r\n * @param data\r\n * data.stream\r\n * data.deviceId: given deviceId\r\n */\r\nGsRTC.prototype.shareAudio = function(data) {\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('invalid RTCSession parameters! can not share audio')\r\n        return\r\n    }\r\n\r\n    log.info('share local audio: ' + data.deviceId)\r\n    let type = 'audio'\r\n    let stream = This.RTCSession.getStream(type, true)\r\n    if(stream){\r\n        This.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: false})\r\n    }else {\r\n        log.info('getting new stream')\r\n        async function getMediaCallBack(args){\r\n            if(args.stream){\r\n                let stream = args.stream\r\n                log.info('get stream: ' +  stream ? stream.id : null)\r\n                This.RTCSession.setStream(stream, type, true)\r\n                let pc = This.RTCSession.peerConnection\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                await This.RTCSession.doOffer(pc)\r\n            }else if(args.error){\r\n                log.error('Get audio stream failed: ' + args.error)\r\n                if(data.callback){\r\n                    data.callback(This.CODE_TYPE.AUDIO_REFRESH_FAILED)\r\n                }\r\n            }\r\n        }\r\n\r\n        let conf = { streamType: type, callback: getMediaCallBack }\r\n        let constraints = {\r\n            audio: data.deviceId ? { deviceId: data.deviceId }: true,\r\n            video: false\r\n        }\r\n\r\n        This.action = 'audioRefresh'\r\n        if(data && data.callback ){\r\n            This.on(This.action, data.callback)\r\n        }\r\n        This.device.getMedia(conf, constraints)\r\n    }\r\n}\r\n\r\n/**\r\n * 切换音频源\r\n * @param data\r\n * data.callback\r\n * data.deviceId\r\n */\r\nGsRTC.prototype.switchAudioSource = function(data) {\r\n    let This = this\r\n    log.info('switch audio source: ' + data.deviceId)\r\n    if(!this.RTCSession){\r\n        log.error('switchAudioSource: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    let type = data.type\r\n    let previousStream = This.RTCSession.getStream(type, true)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    async function getMediaCallBack(event){\r\n        if(event.stream){\r\n            let stream = event.stream\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                if(data && data.callback){\r\n                    data.callback({codeType: 200})\r\n                }\r\n            }else {\r\n                log.info('clear previous stream')\r\n                This.RTCSession.processRemoveStream(previousStream, pc, type)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                await This.RTCSession.doOffer(pc)\r\n            }\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n        }else {\r\n            log.error(event.error)\r\n            if(data && data.callback ){\r\n                data.callback({error:event.error })\r\n            }\r\n        }\r\n    }\r\n\r\n    let conf = { streamType: type, callback: getMediaCallBack }\r\n    let  constraints = {\r\n        audio: data.deviceId ? { deviceId: data.deviceId } : true,\r\n        video: false\r\n    }\r\n\r\n    This.action =  'switchAudioSource'\r\n    if(data && data.callback){\r\n        This.on(This.action, data.callback)\r\n    }\r\n    This.device.getMedia(conf, constraints)\r\n}\r\n\r\n/**\r\n * stop share local audio\r\n * @param data: callback\r\n */\r\nGsRTC.prototype.stopShareAudio = function(data) {\r\n    let This = this\r\n    if(!this.RTCSession){\r\n        log.error('stopShareAudio: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    try {\r\n        let type = data.type\r\n        let stream = This.RTCSession.getStream(type, true)\r\n        if(stream){\r\n            This.RTCSession.streamMuteSwitch({stream: stream, type: type, mute: true})\r\n            if(data.callback){\r\n                data.callback(This.CODE_TYPE.SUCCESS)\r\n            }\r\n        }else {\r\n            log.info('Audio stream: null')\r\n        }\r\n    }catch (e) {\r\n        log.error(e.toString())\r\n        if(data && data.callback){\r\n            data.callback(This.CODE_TYPE.AUDIO_REFRESH_FAILED)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 开启本地视频\r\n * @param data\r\n * data.stream\r\n * data.type\r\n * data.deviceId\r\n */\r\nGsRTC.prototype.shareVideo = function(data) {\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('shareVideo: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'main'\r\n    let previousStream = This.RTCSession.getStream(type, true)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    let param = {\r\n        streamType: 'video',\r\n        deviceId: data.deviceId,\r\n        frameRate: 30,\r\n        width: 640,\r\n        height: 360,\r\n    }\r\n    let constraints = This.device.getConstraints(param)\r\n\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            log.info('get stream success')\r\n            let stream = event.stream\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                if(data.callback){\r\n                    data.callback({codeType: 200})\r\n                }\r\n            }else {\r\n                log.info('clear previous stream')\r\n                This.RTCSession.processRemoveStream(previousStream, pc, type)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                This.RTCSession.doOffer(pc)\r\n            }\r\n\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n\r\n            /**获取远端流**/\r\n            if(gsRTC.RTCSession.peerConnection.getReceivers()[1].track){\r\n                let streams  = new MediaStream()\r\n                streams.addTrack(gsRTC.RTCSession.peerConnection.getReceivers()[1].track)\r\n                This.RTCSession.setStream(streams, type, false)\r\n            }\r\n\r\n            This.RTCSession.deviceId = data.deviceId  // save deviceId\r\n            This.setVideoResolution({width: param.width, height: param.height}, 'CURRENT_UP_RESOLUTION')\r\n        }else {\r\n            log.info('get stream failed')\r\n            if(data && data.callback ){\r\n                data.callback({error: event.error})\r\n            }\r\n            log.error(event.error)\r\n        }\r\n    }\r\n\r\n    let gumData = { streamType: 'video', callback: getMediaCallBack }\r\n    This.action = 'shareVideo'\r\n    if(data && data.callback ){\r\n        This.on(This.action, data.callback)\r\n    }\r\n    This.device.getMedia(gumData, constraints)\r\n}\r\n\r\n/**\r\n * 关闭本地视频\r\n * @param data\r\n */\r\nGsRTC.prototype.stopShareVideo = function(data) {\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('stopShareVideo: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'main'\r\n    let stream = This.RTCSession.getStream(type, true)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    This.action = 'stopShareVideo'\r\n    if(data && data.callback ){\r\n        This.on(This.action, data.callback)\r\n    }\r\n\r\n    log.info('clear previous stream')\r\n    This.RTCSession.deviceId = null\r\n    This.RTCSession.processRemoveStream(stream, pc, type)\r\n    This.RTCSession.closeStream(stream)\r\n    This.RTCSession.setStream(null, type, true)\r\n    This.RTCSession.setMediaElementStream(null, 'main', 'true')\r\n    // This.RTCSession.doOffer(pc)\r\n\r\n    gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.PRESENT, ctrlPresentation: {value: 0}})\r\n\r\n    if(data && data.callback){\r\n        data.callback(gsRTC.CODE_TYPE.SUCCESS)\r\n    }\r\n}\r\n\r\n/**\r\n * 开启桌面演示\r\n * @param data\r\n * data.stream: 要共享的视频流\r\n * data.callback\r\n */\r\nGsRTC.prototype.shareScreen = function(data) {\r\n    log.info(\"share screen\")\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('shareScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    This.action = 'shareScreen'\r\n\r\n    if(data && data.callback &&  !This.EVENTS[This.action]){\r\n        This.on(This.action, data.callback)\r\n    }\r\n\r\n    log.info('current sharing permission: ' + This.RTCSession.sharingPermission)\r\n    if( This.RTCSession.sharingPermission === 3){\r\n        if(This.RTCSession.timeBox){\r\n            clearInterval(This.RTCSession.timeBox)\r\n            This.RTCSession.timeBox = null\r\n        }\r\n        This.RTCSession.openSharingTimeoutstartTime = null\r\n        This.RTCSession.openSharingTimestamp = null\r\n        This.RTCSession.sendCtrlPresentation = false\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: This.CODE_TYPE.SUCCESS, reqId:  This.RTCSession.reqId})\r\n        This.RTCSession.openSharing = true\r\n        let stream = This.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n        let pc = This.RTCSession.peerConnection\r\n        log.info('prepare do offer!')\r\n        This.RTCSession.processAddStream(stream, pc, 'slides')\r\n        This.RTCSession.doOffer(pc)\r\n    }else{\r\n        This.RTCSession.sharingPermission = 1\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT, ctrlPresentation: { value: This.RTCSession.sharingPermission,reqId: This.RTCSession.reqId}} )\r\n    }\r\n}\r\n\r\n/**\r\n * 切换桌面共享源\r\n * @param data.type 类型：\"window\"/\"screen\"/\"whiteboard\"/\"tab\"\r\n * @param data.callback 回调函数\r\n */\r\nGsRTC.prototype.switchScreenSource = function(data) {\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('switchScreenSource: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'slides'\r\n    let previousStream = This.RTCSession.getStream(type, true)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    This.action = 'switchScreenSource'\r\n    if(data && data.callback ){\r\n        This.on(This.action, data.callback)\r\n    }\r\n    This.RTCSession.setMediaElementStream(null, 'slides', 'true')\r\n\r\n    function getMediaCallBack(event){\r\n        if(event.stream){\r\n            let stream = event.stream\r\n            stream.oninactive = function () {\r\n                log.warn(\"user clicks the bottom share bar to stop sharing.\")\r\n                stopScreen()\r\n            }\r\n            if (gsRTC.getBrowserDetail().browser === 'firefox') {\r\n                let tracks = stream.getVideoTracks();\r\n                tracks[0].onended = function () {\r\n                    log.warn('track: user close share control bar');\r\n                    stopScreen()\r\n                }\r\n            }\r\n\r\n            if(previousStream && This.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n                log.info('use replace track to switch presentation stream')\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n\r\n                if(data &&data.callback){\r\n                    data.callback({codeType: 200})\r\n                }\r\n            }else {\r\n                This.RTCSession.processRemoveStream(previousStream, pc)\r\n                This.RTCSession.processAddStream(stream, pc, type)\r\n                This.RTCSession.doOffer(pc)\r\n            }\r\n\r\n            This.RTCSession.closeStream(previousStream)\r\n            This.RTCSession.setStream(stream, type, true)\r\n        }else {\r\n            log.error(event.error.toString())\r\n            if(data && data.callback){\r\n                data.callback({error: event.error})\r\n            }\r\n        }\r\n    }\r\n\r\n    let gumData = {\r\n        streamType: 'screenShare',\r\n        callback: getMediaCallBack\r\n    }\r\n    This.device.getMedia(gumData, data.constraints)\r\n}\r\n\r\n/**\r\n * 关闭桌面演示\r\n * @param data\r\n */\r\nGsRTC.prototype.stopShareScreen = function(data) {\r\n    let This = this\r\n    if(!this.RTCSession){\r\n        log.error('stopShareScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'slides'\r\n    let stream = This.RTCSession.getStream(type, true)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    This.action = 'stopShareScreen'\r\n    if(data && data.callback && !This.EVENTS[This.action]){\r\n        This.on(This.action, data.callback)\r\n    }\r\n\r\n    log.info('clear previous stream')\r\n    This.RTCSession.processRemoveStream(stream, pc, type)\r\n    This.RTCSession.closeStream(stream)\r\n    This.RTCSession.setStream(null, type, true)\r\n    // This.RTCSession.doOffer(pc)\r\n\r\n    log.info('current sharing permission: ' + This.RTCSession.sharingPermission)\r\n    if(This.RTCSession.sharingPermission === 2){\r\n        This.RTCSession.sendCtrlPresentation = false\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: This.CODE_TYPE.SUCCESS, reqId: This.RTCSession.reqId})\r\n        This.openSharing = false\r\n        This.trigger(This.action, {codeType:This.CODE_TYPE.SUCCESS.codeType});\r\n    }else if(This.RTCSession.sharingPermission === 0){\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT, ctrlPresentation: { value: This.RTCSession.sharingPermission }})\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * 发送DTMF\r\n * @param data.digit 发送的内容\r\n * @param data.callback 回调函数\r\n */\r\nGsRTC.prototype.sendDtmf = function(data){\r\n    log.info('send dtmf digit:  ' + data.digit)\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('sendDtmf: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    let dtmfSender\r\n    if(pc.getSenders){\r\n        let senders = pc.getSenders();\r\n        let audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');\r\n        if (!audioSender) {\r\n            log.warn('No local audio track to send DTMF with');\r\n            return\r\n        }else {\r\n            dtmfSender = audioSender.dtmf;\r\n        }\r\n\r\n        if (dtmfSender && dtmfSender.canInsertDTMF) {\r\n            log.info(\"prepare send digit: \"+ data.digit);\r\n            dtmfSender.insertDTMF(data.digit);\r\n        }else {\r\n            log.warn(\"DTMF function not available\");\r\n        }\r\n    }else {\r\n        log.warn('getSenders is not available by current browser version')\r\n    }\r\n}\r\n\r\n/***\r\n * 调整下行分辨率\r\n * @param data\r\n */\r\nGsRTC.prototype.adjustResolution = function(data){\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('adjustResolution: invalid RTCSession parameters!')\r\n        return\r\n    }\r\n    if(!data || !data.height){\r\n        log.error('adjustResolution: ERR_INVALID_PARAMETER_VALUE')\r\n        return\r\n    }\r\n    log.info('adjust down resolution:  ' + data.height)\r\n\r\n    let pc = This.RTCSession.peerConnection\r\n    This.action = 'adjustResolution'\r\n    if(data && data.callback ){\r\n        This.on(This.action , data.callback)\r\n    }\r\n    This.setVideoResolution(This.getResolutionByHeight(data.height), 'EXPECT_RECV_RESOLUTION')\r\n    This.RTCSession.doOffer(pc)\r\n}\r\n\r\n/**\r\n * end call\r\n * @param data\r\n */\r\nGsRTC.prototype.endCall = function(data){\r\n    let This = this\r\n    This.action = 'hangup'\r\n    if( data && data.callback && !This.EVENTS[This.action] ){\r\n        This.on(This.action , data.callback)\r\n    }\r\n    log.info('current sharing permission: ' + This.RTCSession.sharingPermission)\r\n    if(This.RTCSession.sharingPermission === 4){\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.BYE_RET, destroyMediaSessionRet: This.CODE_TYPE.SUCCESS, reqId: This.RTCSession.reqId})\r\n        This.trigger(This.action, {codeType:This.CODE_TYPE.SUCCESS.codeType});\r\n        This.cleanGsRTC()\r\n\r\n    }else{\r\n        This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.BYE,destroyMediaSession:{ value: This.RTCSession.sharingPermission }})\r\n    }\r\n}\r\n\r\n/**\r\n * Leave the meeting\r\n */\r\nGsRTC.prototype.closePeerConn = function () {\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error(\"RTCSession is not initialized\")\r\n        return\r\n    }\r\n    try {\r\n        // close stream\r\n        for (let key in This.MEDIA_STREAMS) {\r\n            let stream = This.MEDIA_STREAMS[key];\r\n            This.RTCSession.closeStream(stream)\r\n        }\r\n\r\n        let pc = This.RTCSession.peerConnection\r\n        // close peerConnection\r\n        pc.getSenders().forEach(sender => {\r\n            delete sender.track\r\n            sender.replaceTrack(null)\r\n        })\r\n        pc.close()\r\n        This.RTCSession = null\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n/**\r\n * close websocket\r\n */\r\nGsRTC.prototype.cleanGsRTC = function(){\r\n    log.info(\"websocket close\")\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error(\"RTCSession is not initialized\")\r\n        return\r\n    }\r\n    let stream = This.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n    if(stream){\r\n        This.RTCSession.stopTrack(stream)\r\n    }\r\n    if( (This.sokect && This.sokect.ws && This.sokect.ws.readyState === 1)){\r\n        This.sokect.ws.close()\r\n    }\r\n    clearInterval(This.sokect.ws.websocketTimer)\r\n    This.RTCSession.openSharingTimestamp = null\r\n    This.RTCSession.openSharingTimeoutstartTime = null\r\n    This.RTCSession.initialResolution = null\r\n    This.RTCSession.shareScreenStream = null\r\n    This.RTCSession.openSharing = false\r\n    This.RTCSession.isSendReInvite = false\r\n    This.RTCSession.sendCtrlPresentation = false\r\n    This.RTCSession.reqId = null\r\n    This.RTCSession.cancelReqCmd = null\r\n    This.RTCSession.cancelReqId = null\r\n    This.RTCSession.sharingPermission = null\r\n    This.closePeerConn()\r\n}\r\n\r\n/**\r\n * 告知gsPhone开启演示流，web端接受演示流\r\n * @param data\r\n * data.stream: 要共享的视频流\r\n * data.callback\r\n */\r\nGsRTC.prototype.openRemoteVideo = function(data){\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('openRemoteScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    This.action = 'openRemoteControl'\r\n    log.info(\"open remote screen\")\r\n    if(data && data.callback && !This.EVENTS[This.action]){\r\n        This.on(This.action, data.callback)\r\n    }\r\n\r\n    This.RTCSession.isRequestOpenRemoteVideo = true\r\n    This.RTCSession.doOffer(pc)\r\n}\r\n\r\n/**\r\n * 告知gsPhone关闭演示流，web端关闭演示流\r\n * @param data\r\n * data.stream: 要共享的视频流\r\n * data.callback\r\n */\r\nGsRTC.prototype.stopRemoteVideo = function(data){\r\n    let This = this\r\n    if(!This.RTCSession){\r\n        log.error('stopRemoteScreen: invalid RTCSession parameters! ')\r\n        return\r\n    }\r\n\r\n    let type = 'slides'\r\n    let stream = This.RTCSession.getStream(type, false)\r\n    let pc = This.RTCSession.peerConnection\r\n\r\n    This.action = 'stopRemoteControl'\r\n    log.info(\"stop remote screen\")\r\n    if(data && data.callback && !This.EVENTS[This.action]){\r\n        This.on(This.action, data.callback)\r\n    }\r\n\r\n    log.info('clear remote stream')\r\n    This.RTCSession.processRemoveStream(stream, pc, type)\r\n    This.RTCSession.closeStream(stream)\r\n    This.RTCSession.setStream(null, type, false)\r\n\r\n\r\n    This.RTCSession.isRequestOpenRemoteVideo = false\r\n    This.RTCSession.doOffer(pc)\r\n}\nvar log = {};\r\nlog.debug = window.debug(\"GSRTC_COMMON:DEBUG\");\r\nlog.log = window.debug(\"GSRTC_COMMON:LOG\");\r\nlog.info = window.debug(\"GSRTC_COMMON:INFO\");\r\nlog.warn = window.debug(\"GSRTC_COMMON:WARN\");\r\nlog.error = window.debug(\"GSRTC_COMMON:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * Function that subscribes a listener to an event.\r\n * @method on\r\n * @param {String} eventName The event.\r\n * @param {Function} callback The listener.\r\n */\r\nGsRTC.prototype.on = function(eventName, callback) {\r\n    if ('function' === typeof callback) {\r\n        this.EVENTS[eventName] = this.EVENTS[eventName] || [];\r\n        this.EVENTS[eventName].push(callback);\r\n    } else {\r\n        // throw 'Provided parameter is not a function'\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Function that unsubscribes listeners from an event.\r\n * @method off\r\n * @param {String} [eventName] The event.\r\n * - When not provided, all listeners to all events will be unsubscribed.\r\n * @param {Function} [callback] The listener to unsubscribe.\r\n * - When not provided, all listeners associated to the event will be unsubscribed.\r\n */\r\nGsRTC.prototype.off = function(eventName, callback) {\r\n    if (!(eventName && typeof eventName === 'string')) {\r\n        this.EVENTS = {};\r\n    } else {\r\n        if (callback === undefined) {\r\n            this.EVENTS[eventName] = [];\r\n            return;\r\n        }\r\n        let arr = this.EVENTS[eventName] || [];\r\n\r\n        // unsubscribe events that is triggered always\r\n        for (let i = 0; i < arr.length; i++) {\r\n            if (arr[i] === callback) {\r\n                arr.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Function that triggers an event.\r\n * The rest of the parameters after the <code>eventName</code> parameter is considered as the event parameter payloads.\r\n * @method trigger\r\n */\r\nGsRTC.prototype.trigger = function(eventName) {\r\n    //convert the arguments into an array\r\n    let args = Array.prototype.slice.call(arguments);\r\n    let arr = this.EVENTS[eventName];\r\n    args.shift(); //Omit the first argument since it's the event name\r\n    if (arr) {\r\n        // for events subscribed forever\r\n        for (let i = 0; i < arr.length; i++) {\r\n            try {\r\n                if(arr[i].apply(this, args) === false) {\r\n                    break;\r\n                }\r\n            } catch(error) {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Function that Determine whether it is nxx corresponding, such as: isResponseNxx(2, 200) ==> true\r\n * @param i\r\n * @param code Received status code, such 200\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isNxx= function(i, code) {\r\n    return ((i * 100) <= code && code <= ((i * 100) + 99));\r\n}\r\n\r\n/***\r\n * Function that Generate a UUID as the unique identifier of the peer ID\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.generateUUID = function() {\r\n    let d = new Date().getTime();\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        let r = (d + Math.random() * 16) % 16 | 0;\r\n        d = Math.floor(d / 16);\r\n        return (c === 'x' ? r : (r && 0x7 | 0x8)).toString(16);\r\n    });\r\n};\r\n\r\n/***\r\n * get file url\r\n * @param file\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getObjectURL = function(file) {\r\n    let url = null;\r\n    if (window.createObjectURL !== undefined) { // basic\r\n        url = window.createObjectURL(file);\r\n    } else if (window.URL !== undefined) { // mozilla(firefox)\r\n        url = window.URL.createObjectURL(file);\r\n    } else if (window.webkitURL !== undefined) { // webkit or chrome\r\n        url = window.webkitURL.createObjectURL(file);\r\n    }\r\n    return url;\r\n}\r\n\r\n/***\r\n * Function that deep clone an object.\r\n * @param obj\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.objectDeepClone = function(obj) {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    let copy = function (data) {\r\n        let copy = data.constructor();\r\n        for (let attr in data) {\r\n            if (data.hasOwnProperty(attr)) {\r\n                copy[attr] = data[attr];\r\n            }\r\n        }\r\n        return copy;\r\n    };\r\n\r\n    if (typeof obj === 'object' && !Array.isArray(obj)) {\r\n        try {\r\n            return JSON.parse( JSON.stringify(obj) );\r\n        } catch (err) {\r\n            return copy(obj);\r\n        }\r\n    }\r\n\r\n    return copy(obj);\r\n};\r\n\r\n/***\r\n * Function that Depth comparison of two objects is completely equal\r\n * @param x\r\n * @param y\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isObjectXExactlyEqualToY = function(x, y) {\r\n    let i, l, leftChain, rightChain;\r\n\r\n    function compare2Objects(x, y) {\r\n        let p;\r\n\r\n        // remember that NaN === NaN returns false\r\n        // and isNaN(undefined) returns true\r\n        if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\r\n            return true;\r\n        }\r\n\r\n        // Compare primitives and functions.\r\n        // Check if both arguments link to the same object.\r\n        // Especially useful on the step where we compare prototypes\r\n        if (x === y) {\r\n            return true;\r\n        }\r\n\r\n        // Works in case when functions are created in constructor.\r\n        // Comparing dates is a common scenario. Another built-ins?\r\n        // We can even handle functions passed across iframes\r\n        if ((typeof x === 'function' && typeof y === 'function') ||\r\n            (x instanceof Date && y instanceof Date) ||\r\n            (x instanceof RegExp && y instanceof RegExp) ||\r\n            (x instanceof String && y instanceof String) ||\r\n            (x instanceof Number && y instanceof Number)) {\r\n            return x.toString() === y.toString();\r\n        }\r\n\r\n        // At last checking prototypes as good as we can\r\n        if (!(x instanceof Object && y instanceof Object)) {\r\n            return false;\r\n        }\r\n\r\n        if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\r\n            return false;\r\n        }\r\n\r\n        if (x.constructor !== y.constructor) {\r\n            return false;\r\n        }\r\n\r\n        if (x.prototype !== y.prototype) {\r\n            return false;\r\n        }\r\n\r\n        // Check for infinitive linking loops\r\n        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\r\n            return false;\r\n        }\r\n\r\n        // Quick checking of one object being a subset of another.\r\n        // todo: cache the structure of arguments[0] for performance\r\n        for (p in y) {\r\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n                return false;\r\n            } else if (typeof y[p] !== typeof x[p]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (p in x) {\r\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\r\n                return false;\r\n            } else if (typeof y[p] !== typeof x[p]) {\r\n                return false;\r\n            }\r\n\r\n            switch (typeof(x[p])) {\r\n                case 'object':\r\n                case 'function':\r\n\r\n                    leftChain.push(x);\r\n                    rightChain.push(y);\r\n\r\n                    if (!compare2Objects(x[p], y[p])) {\r\n                        return false;\r\n                    }\r\n\r\n                    leftChain.pop();\r\n                    rightChain.pop();\r\n                    break;\r\n\r\n                default:\r\n                    if (x[p] !== y[p]) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    if (arguments.length < 1) {\r\n        log.warn('Need two or more arguments to compare')\r\n        return true;\r\n    }\r\n\r\n    for (i = 1, l = arguments.length; i < l; i++) {\r\n        leftChain = [];\r\n        rightChain = [];\r\n\r\n        if (!compare2Objects(arguments[0], arguments[i])) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Determine if the browser supports ReplaceTrack\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.isReplaceTrackSupport = function() {\r\n    let browserDetails = this.getBrowserDetail()\r\n    let result = false\r\n\r\n    switch (browserDetails.browser) {\r\n        case 'chrome':\r\n            result = browserDetails.version >= 72\r\n            break\r\n        case 'opera':\r\n            result = browserDetails.version >= 59\r\n            break\r\n        case 'firefox':\r\n            result = browserDetails.version >= 59\r\n            break\r\n        case 'safari':\r\n            result = browserDetails.UIVersion >= '12.1.1'\r\n            break\r\n        default:\r\n            break\r\n    }\r\n\r\n    log.info(browserDetails.browser + ' ' + browserDetails.UIVersion +' version support replaceTrack : ' + result)\r\n    return result\r\n}\r\n\r\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\r\nGsRTC.prototype.getBrowserDetail = function () {\r\n    function extractVersion(uastring, expr, pos) {\r\n        let match = uastring.match(expr);\r\n        return match && match.length >= pos && parseInt(match[pos], 10);\r\n    }\r\n\r\n    var navigator = window && window.navigator;\r\n\r\n    // Returned result object.\r\n    var result = {};\r\n    result.browser = null;\r\n    result.version = null;\r\n    result.UIVersion = null;\r\n    result.chromeVersion = null;\r\n\r\n    // Fail early if it's not a browser\r\n    if (typeof window === 'undefined' || !window.navigator) {\r\n        result.browser = 'Not a browser.';\r\n        return result;\r\n    }\r\n\r\n    // Edge.\r\n    if (navigator.mediaDevices &&\r\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\r\n        result.browser = 'edge';\r\n        result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\r\n        result.UIVersion = navigator.userAgent.match(/Edge\\/([\\d.]+)/)[1]; //Edge/16.17017\r\n\r\n    } // IE\r\n    else if (!navigator.mediaDevices && (!!window.ActiveXObject || 'ActiveXObject' in window || navigator.userAgent.match(/MSIE (\\d+)/) || navigator.userAgent.match(/rv:(\\d+)/))) {\r\n        result.browser = 'ie';\r\n        if (navigator.userAgent.match(/MSIE (\\d+)/)) {\r\n            result.version = extractVersion(navigator.userAgent, /MSIE (\\d+).(\\d+)/, 1);\r\n            result.UIVersion = navigator.userAgent.match(/MSIE ([\\d.]+)/)[1]; //MSIE 10.6\r\n\r\n        } else if (navigator.userAgent.match(/rv:(\\d+)/)) {\r\n            /*For IE 11*/\r\n            result.version = extractVersion(navigator.userAgent, /rv:(\\d+).(\\d+)/, 1);\r\n            result.UIVersion = navigator.userAgent.match(/rv:([\\d.]+)/)[1]; //rv:11.0\r\n        }\r\n\r\n        // Firefox.\r\n    } else if (navigator.mozGetUserMedia) {\r\n        result.browser = 'firefox';\r\n        result.version = extractVersion(navigator.userAgent,\r\n            /Firefox\\/(\\d+)\\./, 1);\r\n        result.UIVersion = navigator.userAgent.match(/Firefox\\/([\\d.]+)/)[1]; //Firefox/56.0\r\n\r\n        // all webkit-based browsers\r\n    } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {\r\n        // Chrome, Chromium, Webview, Opera, Vivaldi all use the chrome shim for now\r\n        var isOpera = navigator.userAgent.match(/(OPR|Opera).([\\d.]+)/) ? true : false;\r\n        //var isVivaldi = navigator.userAgent.match(/(Vivaldi).([\\d.]+)/) ? true : false;\r\n        if (isOpera) {\r\n            result.browser = 'opera';\r\n            result.version = extractVersion(navigator.userAgent, /O(PR|pera)\\/(\\d+)\\./, 2);\r\n            result.UIVersion = navigator.userAgent.match(/O(PR|pera)\\/([\\d.]+)/)[2]; //OPR/48.0.2685.39\r\n            if (navigator.userAgent.match(/Chrom(e|ium)\\/([\\d.]+)/)[2]) {\r\n                result.chromeVersion = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n            }\r\n        }/* else if (isVivaldi) {\r\n          result.browser = 'vivaldi';\r\n          result.version = extractVersion(navigator.userAgent,\r\n                                            /(Vivaldi)\\/(\\d+)\\./, 2);\r\n          result.UIVersion = navigator.userAgent.match(/Vivaldi\\/([\\d.]+)/)[1]; //Vivaldi/1.93.955.38\r\n     }*/ else {\r\n            result.browser = 'chrome';\r\n            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\r\n            result.UIVersion = navigator.userAgent.match(/Chrom(e|ium)\\/([\\d.]+)/)[2]; //Chrome/61.0.3163.100\r\n        }\r\n\r\n        // Safari or unknown webkit-based\r\n        // for the time being Safari has support for MediaStreams but not webRTC\r\n        //Safari without webRTC and with partly webRTC support\r\n    } else if ((!navigator.webkitGetUserMedia && navigator.userAgent.match(/AppleWebKit\\/([0-9]+)\\./)) || (navigator.webkitGetUserMedia && !navigator.webkitRTCPeerConnection)) {\r\n        // Safari UA substrings of interest for reference:\r\n        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)\r\n        // - safari UI version:        Version/9.0.3 (unique to Safari)\r\n        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)\r\n        //\r\n        // if the webkit version and safari UI webkit versions are equals,\r\n        // ... this is a stable version.\r\n        //\r\n        // only the internal webkit version is important today to know if\r\n        // media streams are supported\r\n        //\r\n        if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\r\n            result.browser = 'safari';\r\n            result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\r\n            result.UIVersion = navigator.userAgent.match(/Version\\/([\\d.]+)/)[1]; //Version/11.0.1\r\n\r\n\r\n        } else { // unknown webkit-based browser.\r\n            result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.';\r\n            return result;\r\n        }\r\n        // Default fallthrough: not supported.\r\n    } else {\r\n        result.browser = 'Not a supported browser.';\r\n        return result;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Determine if the input string is empty or all spaces\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nGsRTC.prototype.tskStringIsNullOrEmpty = function (str) {\r\n    let result\r\n    if(!str || str === \"\"){\r\n        result = true\r\n    }else {\r\n        let regu = \"^[ ]+$\";\r\n        let re = new RegExp(regu);\r\n        result = re.test(str)\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * 获取屏幕分辨率\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.getScreenResolution = function() {\r\n    if (window.devicePixelRatio === undefined) {\r\n        window.devicePixelRatio = 1;\r\n    }\r\n    let screenResolution = window.screen.height * window.devicePixelRatio * window.screen.width * window.devicePixelRatio\r\n    let InitResolution = {};\r\n    //根据用户屏幕分辨率确定入会初始分辨率\r\n    if (screenResolution <= 1440 * 900) {\r\n        InitResolution = {\r\n            width: 1280,\r\n            height: 720\r\n        }\r\n    } else {\r\n        InitResolution = {\r\n            width: 1920,\r\n            height: 1080\r\n        }\r\n    }\r\n    log.info(\"screen resolution = \" + window.screen.height * window.devicePixelRatio + \" * \" + window.screen.width * window.devicePixelRatio);\r\n    return InitResolution;\r\n}\r\n\r\nGsRTC.prototype.isWFUShareScreenSupport = function() {\r\n    let browserDetails = this.getBrowserDetail()\r\n    let result = true\r\n\r\n    switch (browserDetails.browser) {\r\n        case 'chrome':\r\n            result = browserDetails.version >= 72\r\n            break\r\n        case 'opera':\r\n            result = browserDetails.version >= 60\r\n            break\r\n        case 'firefox':\r\n            result = browserDetails.version >= 60\r\n            break\r\n        case 'edge':\r\n            result = browserDetails.version >= 79\r\n            break\r\n        case 'safari':\r\n            result = browserDetails.UIVersion >= '13.0'\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    return result\r\n}\r\n\n/*Log Debug Start*/\r\nvar log = {};\r\nlog.debug = window.debug(\"GARTC_JSEP:DEBUG\");\r\nlog.log = window.debug(\"GARTC_JSEP:LOG\");\r\nlog.info = window.debug(\"GARTC_JSEP:INFO\");\r\nlog.warn = window.debug(\"GARTC_JSEP:WARN\");\r\nlog.error = window.debug(\"GARTC_JSEP:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * create PeerConnection instance\r\n * @param gsRTC\r\n * @constructor\r\n */\r\nlet PeerConnection = function (gsRTC) {\r\n    // this.gsRTC = gsRTC\r\n    // this.conf = {}\r\n    this.peerConnection = null\r\n    this.isProcessingInvite = false\r\n\r\n    this.isSendReInvite = false            // 判断是否为re-invite\r\n    this.sendCtrlPresentation = false      // 判断是否需要发送ctrlPresentation控制信令\r\n    this.sharingPermission = 0             // 标记共享命令：1开启 0关闭 (webUI) / 2开启 3关闭(遥控器) / 4请求结束通话 5结束通话\r\n    this.mLineOrder = []                   // 记录m行的顺序\r\n    this.initialResolution = null\r\n\r\n    this.replyOpenSharingTimerTime = 35                    // 回复开启演示的时间\r\n    this.openSharingTimeoutstartTime = null                // 开启演示超时\r\n    this.openSharingTimestamp = null                       // 计算时间戳\r\n    this.timeBox = null                                    // shareScreenRequest开启共享定时器 或者 发送ctrlPresentation开启定时器(回复webUI请求信令超时)\r\n    this.openSharing = false                               // 判断是否正在开启演示\r\n\r\n    this.isOpenSharingReceiveReply = false                 // 是否回复开启演示信令\r\n    this.isSendCancelRequest = false                       // 是否发送取消开启演示信令\r\n    this.reqId = null                                      // 某个动作的reqId\r\n    this.cancelReqId = null                                // 取消某个动作对应的reqId，如取消开启演示\r\n    this.cancelReqCmd = null                               // 取消某个动作对应的信令，如ctrlPresentation\r\n    this.isRequestOpenRemoteVideo = false\r\n}\r\n\r\n/**\r\n * create webRTC multiStream Peer connection\r\n * @param conf\r\n */\r\nPeerConnection.prototype.createMultiStreamRTCSession = function(conf){\r\n    log.info('create webRTC multiStream Peer connection')\r\n    try {\r\n        let This = this\r\n        let type = 'multiStreamPeer'\r\n        this.peerConnection = This.createPeerConnection(type, conf)\r\n        let pc = This.peerConnection\r\n\r\n        if(RTCPeerConnection.prototype.addTransceiver){\r\n            log.info('use addTransceiver to add transceiver ');\r\n            // add audio Transceiver to keep audio media first\r\n            pc.addTransceiver('audio')\r\n            pc.addTransceiver('video')\r\n            pc.addTransceiver('video')\r\n        }else {\r\n            log.info('use captureStream to add transceiver ');\r\n            // get two video stream\r\n            let streamArray = This.getCaptureStream(2)\r\n            if(streamArray && streamArray.length){\r\n                for(let i = 0; i<streamArray.length; i++){\r\n                    let stream = streamArray[i]\r\n                    log.info('add stream to peerConnection: ' + stream.id)\r\n                    pc.addStream(stream)\r\n                }\r\n            }else {\r\n                log.warn('Browser is not support captureStream!')\r\n                return\r\n            }\r\n        }\r\n\r\n        This.doOffer(pc)\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n}\r\n\r\n/**\r\n * Listen for stream change events\r\n * @param pc\r\n */\r\nPeerConnection.prototype.subscribeStreamEvents = function (pc) {\r\n    let This = this\r\n    if (gsRTC.isReplaceTrackSupport()) {\r\n            pc.ontrack = function (evt) {\r\n            log.info('__on_add_track')\r\n            let stream = evt.streams ? evt.streams[0] : null\r\n            log.info('__on_add_track: ', stream)\r\n            if (!stream && evt.track) {\r\n                log.info('`stream` is undefined on `ontrack` event in WebRTC', evt.track)\r\n                stream = new MediaStream()\r\n                stream.addTrack(evt.track)\r\n            }\r\n\r\n            if(stream){\r\n                let type = gsRTC.getTypeByMid(evt.transceiver.mid)\r\n                This.setStream(stream, type, false)\r\n\r\n                stream.onremovetrack = function (evt) {\r\n                    log.info('__on_remove_track')\r\n                    This.setStream(null, type, false)\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        pc.onaddstream = function (evt) {\r\n            log.info('__on_add_stream')\r\n            let type = pc.type\r\n            This.setStream(evt.stream, type, false)\r\n        }\r\n        pc.onremovestream = function (evt) {\r\n            log.info('__on_remove_stream')\r\n            let type = This.getTypeByStreamId(evt.currentTarget.id)\r\n            This.setStream(null, type, false)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * create peerConnection\r\n * @param type\r\n * @param conf\r\n * @returns {RTCPeerConnection}\r\n */\r\nPeerConnection.prototype.createPeerConnection = function (type, conf) {\r\n    log.info(\"Create peerConnection : \" + type)\r\n    let This = this\r\n    let pc\r\n    let config = {\r\n        iceTransportPolicy: 'all',\r\n        bundlePolicy: 'max-compat'\r\n    }\r\n    let iceservers = conf.iceServer;\r\n    let RTCpeerConnectionOptional = gsRTC.conf.RTCpeerConnectionOptional;\r\n    // chrome 72 版本默认unified-plan， 65版本开始unified-plan为实验性质标志，通过sdpSemantics: unified-plan 启用\r\n    if (RTCpeerConnectionOptional === null || RTCpeerConnectionOptional === undefined) {\r\n        RTCpeerConnectionOptional = { optional: [ { 'pcName': \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': true } ] };\r\n    }\r\n    else if(RTCpeerConnectionOptional && RTCpeerConnectionOptional.optional && RTCpeerConnectionOptional.optional.length > 0){\r\n        RTCpeerConnectionOptional.optional.push( { 'pcName': \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2) }, { 'googDscp': true }, { 'googIPv6': true });\r\n    }\r\n    // config[\"sdpSemantics\"] = \"unified-plan\";\r\n    if(iceservers === null || iceservers === undefined || iceservers.length === 0){\r\n        log.info('iceServers is null')\r\n    }else {\r\n        log.info('icesServer ' + gsRTC.conf.iceServer)\r\n        config.iceServers = gsRTC.conf.iceServer;\r\n    }\r\n    if(gsRTC.getBrowserDetail().browser !== 'firefox'){\r\n        // firefox not support no need set sdpSemantics config\r\n        config.sdpSemantics = \"unified-plan\";\r\n    }\r\n\r\n    log.warn(\"config: \", config)\r\n    log.warn(\"RTCpeerConnectionOptional: \", RTCpeerConnectionOptional)\r\n\r\n    pc = new window.RTCPeerConnection(config, RTCpeerConnectionOptional)\r\n    pc.type = type;\r\n    pc.pcName = \"PC_\" + type + \"_\" + Math.random().toString(36).substr(2)\r\n    pc.peerId = Math.random().toString(36).substr(2)\r\n    pc.action = null\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = false\r\n    pc.isLocalSdpPending = true;\r\n    This.subscribeStreamEvents(pc)\r\n\r\n\r\n    pc.onicecandidate = function (event) {\r\n        This.onIceCandidate(pc, event);\r\n    };\r\n\r\n    pc.onsignalingstatechange = function () {\r\n        This.onSignalingStateChange(pc)\r\n    }\r\n\r\n    pc.onicegatheringstatechange = function () {\r\n        This.onIceGatheringStateChange(pc)\r\n    }\r\n\r\n    pc.oniceconnectionstatechange = function () {\r\n        This.onIceConnectionStateChange(pc);\r\n    }\r\n\r\n    pc.onconnectionstatechange = function (event) {\r\n        This.onConnectionStateChange(pc, event)\r\n    }\r\n    return pc\r\n}\r\n\r\n/**\r\n * create localDescription: create offer and setLocalDescription\r\n * @param pc\r\n * @returns {Promise<void>}\r\n */\r\nPeerConnection.prototype.doOffer = async function (pc) {\r\n    let This = this\r\n    This.isProcessingInvite = true\r\n    log.info(\"create sdp( PC: \" + pc.type + \" )\");\r\n    // Added checks to ensure that connection object is defined first\r\n    if (!pc) {\r\n        log.info('RTCSessionDescription offer, Dropping of creating of offer as connection does not exists');\r\n        return;\r\n    }\r\n\r\n    // Added checks to ensure that state is \"stable\" if setting local \"offer\"\r\n    if (pc.signalingState !== 'stable') {\r\n        log.warn(\"Dropping of creating of offer as signalingState is not \" + pc.signalingState);\r\n        return;\r\n    }\r\n\r\n    log.info('Creating offer');\r\n    var offerConstraints = {\r\n        offerToReceiveAudio: true,\r\n        offerToReceiveVideo: true\r\n    }\r\n\r\n    async function onCreateOfferSuccess(desc) {\r\n        log.log(`Offer from ` + pc.type + ` \\n${desc.sdp}`);\r\n        log.info('start setLocalDescription');\r\n        try {\r\n            await pc.setLocalDescription(desc);\r\n            This.setLocalDescriptionSuccess(pc);\r\n        } catch (error) {\r\n            This.onSetLocalDescriptionError(error);\r\n        }\r\n    }\r\n\r\n    try {\r\n        log.log(pc.type + ' createOffer start');\r\n        let offer\r\n        if(pc.action === 'iceRestart'){\r\n            offerConstraints.iceRestart = true\r\n            offer = await pc.createOffer(offerConstraints);\r\n        }else{\r\n            offer = await pc.createOffer(offerConstraints );\r\n        }\r\n        await onCreateOfferSuccess(offer);\r\n    } catch (error) {\r\n        This.onCreateLocalDescriptionError(error);\r\n    }\r\n}\r\n\r\n/***\r\n * create localDescription: create answer and setLocalDescription\r\n * @param pc\r\n * @returns {Promise<void>}\r\n */\r\nPeerConnection.prototype.doAnswer = async function (pc) {\r\n    let This = this\r\n    pc.isLocalSdpPending = true\r\n    This.isProcessingInvite = true\r\n    log.info(\"prepare do answer\")\r\n    // Added checks to ensure that connection object is defined first\r\n    if (!pc) {\r\n        log.info('RTCSessionDescription offer Dropping of creating of answer as connection does not exists');\r\n        return;\r\n    }\r\n\r\n    // Added checks to ensure that state is \"stable\" if createAnswer\r\n    if (pc.signalingState !== 'have-remote-offer') {\r\n        log.info(\"Dropping of creating of offer as signalingState is not \" + pc.signalingState);\r\n        return;\r\n    }\r\n\r\n    async function onCreateAnswerSuccess(desc) {\r\n        log.info(pc.type + `createAnswerSuccess`);\r\n        log.info(pc.type + ' setLocalDescription start');\r\n        try {\r\n            await pc.setLocalDescription(desc);\r\n            This.setLocalDescriptionSuccess(pc);\r\n        } catch (e) {\r\n            This.onSetLocalDescriptionError(error);\r\n        }\r\n    }\r\n\r\n    log.info('createAnswer start');\r\n    try {\r\n        const answer = await pc.createAnswer();\r\n        await onCreateAnswerSuccess(answer);\r\n    } catch (e) {\r\n        This.onCreateLocalDescriptionError(e);\r\n    }\r\n}\r\n\r\n/**\r\n * fired when peerConnection set localDescription success\r\n * @returns {boolean}\r\n */\r\nPeerConnection.prototype.setLocalDescriptionSuccess = function (pc) {\r\n    log.info('setLocalDescription success ( ' + pc.type + ')')\r\n    // If you don't recollect the dates, you need to judge here whether you can send invite or 200 ok\r\n    if (pc.iceGatheringState === 'complete' && !pc.isLocalSdpPending) {\r\n        log.info(\"onSetLocalDescriptionSuccess send invite( PC: \" + pc.type + \" )\");\r\n        this.onIceGatheringCompleted();\r\n    }\r\n}\r\n\r\n/**\r\n * fired when peerConnection set localDescription failed\r\n * @param error\r\n */\r\nPeerConnection.prototype.onSetLocalDescriptionError = function (error) {\r\n    log.error(`Failed to set local description: ${error}`);\r\n}\r\n\r\n/**\r\n * fired when peerConnection createOffer or createAnswer failed\r\n * @param error\r\n */\r\nPeerConnection.prototype.onCreateLocalDescriptionError = function (error) {\r\n    log.error(`Failed to create session description: ${error}`);\r\n}\r\n\r\n/**\r\n * setRemoteDescription when answer sdp from the server\r\n * @param sdp\r\n */\r\nPeerConnection.prototype.setRemote = async function (sdp) {\r\n    let This = this\r\n    try {\r\n        let pc = gsRTC.RTCSession.peerConnection\r\n        log.info('setRemoteDescription (' + pc.type + ')')\r\n        log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)\r\n        log.info('setRemote sdp:\\n' + sdp)\r\n        let desc = new window.RTCSessionDescription({type: 'answer', sdp: sdp})\r\n        await pc.setRemoteDescription(desc)\r\n        This.setRemoteDescriptionSuccess(pc)\r\n    } catch (e) {\r\n        This.onSetRemoteDescriptionError(e);\r\n    }\r\n}\r\n\r\n/**\r\n * set remote desc success\r\n * @param pc\r\n */\r\nPeerConnection.prototype.setRemoteDescriptionSuccess = function () {\r\n    let This = this\r\n    log.info('setRemoteDescription success ')\r\n\r\n    if(This.peerConnection.action === 'iceRestart'){\r\n        gsRTC.trigger('onIceReconnect', {codeType: gsRTC.CODE_TYPE.SUCCESS.codeType})\r\n        This.peerConnection.action = null\r\n    }else{\r\n        if(This.sharingPermission === 1 || This.sharingPermission === 3){\r\n            This.openSharing = true\r\n        }\r\n        gsRTC.trigger(gsRTC.action, {codeType: gsRTC.CODE_TYPE.SUCCESS.codeType})\r\n    }\r\n}\r\n\r\n/**\r\n * set remote desc error\r\n * @param error\r\n */\r\nPeerConnection.prototype.onSetRemoteDescriptionError = function (error) {\r\n    log.error(`Failed to set remote description: ${error}`);\r\n    console.error(error)\r\n}\r\n\r\n/**\r\n * close  stream\r\n *@param stream\r\n *  **/\r\n\r\nPeerConnection.prototype.stopTrack = function (stream){\r\n    log.info(\"stop stream and stop track\")\r\n    let tracks = stream.getTracks();\r\n    for (let track in tracks) {\r\n        tracks[track].onended = null;\r\n        tracks[track].stop();\r\n    }\r\n}\r\n\r\n/**\r\n * get codec to enable ExternalEncoder\r\n * @param media\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getExternalEncoder = function(media){\r\n    let codec\r\n    if(media && media.fmtp && media.fmtp.length){\r\n        for(let i = 0; i< media.fmtp.length; i++){\r\n            let config = media.fmtp[i].config\r\n            if(config.indexOf('packetization-mode=1') >= 0 && config.indexOf('profile-level-id=42e0') >= 0) {\r\n                codec = media.fmtp[i].payload\r\n                break;\r\n            }\r\n        }\r\n        if(!codec){\r\n            for(let i = 0; i<media.fmtp.length; i++){\r\n                let config = media.fmtp[i].config\r\n                if(config.indexOf('packetization-mode=1') >= 0 && config.indexOf('profile-level-id=4200') >= 0) {\r\n                    codec = media.fmtp[i].payload\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        log.info('get priority H264 PT ' + codec)\r\n    }\r\n    return codec\r\n}\n\r\n/**\r\n * get local sdp\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.decorateLocalSDP = function () {\r\n    log.info('get local peers combine sdp')\r\n    let This = this\r\n    log.warn(\"decorate multi stream Peer sdp \")\r\n\r\n    let sdp = This.peerConnection.localDescription.sdp\r\n    sdp = gsRTC.adjustOrderOfMLines(sdp)\r\n    sdp = gsRTC.removeSSRC(sdp)\r\n    sdp = gsRTC.modifyMidDirection(sdp)\r\n    sdp = gsRTC.deleteCodeByName(sdp)\r\n\r\n\r\n    log.info('get local sdp:\\n' + sdp.toString())\r\n    return sdp\r\n}\r\n\r\n/**\r\n * decorate remote sdp\r\n * @param sdp\r\n */\r\nPeerConnection.prototype.handleRemoteSDP  = function(sdp){\r\n    log.info('handle remote sdp')\r\n    let This = this\r\n    if(!sdp){\r\n        log.error(\"commonDecorateRo: Invalid Argument\");\r\n        return;\r\n    }\r\n\r\n    sdp = gsRTC.setXgoogleBitrate(sdp, 10240)\r\n    sdp = This.modifiedMidBeforeSetRemoteSDP(sdp)\r\n    sdp = This.modifyProfile(sdp)\r\n    This.setRemote(sdp)\r\n    This.isSendReInvite = true\r\n\r\n}\r\n\r\n/**\r\n * setRemote前，修改mid为原本值\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.modifiedMidBeforeSetRemoteSDP = function (sdp) {\r\n    let This = this\r\n    let mediaArray = []\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    let type\r\n    let mLineOrder = This.mLineOrder\r\n\r\n    // TODO: 要保持m行顺序\r\n    for(let i=0; i< parseSDP.media.length; i++){\r\n        type = parseSDP.media[i].type\r\n        if(parseSDP.media[i].type !== 'audio'){\r\n            if(!parseSDP.media[i].content){\r\n                let mid = parseSDP.media[i].mid\r\n                type = gsRTC.getTypeByMid(mid)\r\n                parseSDP.media[i].content = type\r\n            }else {\r\n                type = parseSDP.media[i].content\r\n            }\r\n            log.info(\"current type: \" + type)\r\n        }\r\n        parseSDP.media[i].mid =  gsRTC.getOriginalMid(type)\r\n\r\n        for(let j in mLineOrder){\r\n            if(type === mLineOrder[j]){\r\n                mediaArray[j] = parseSDP.media[i]\r\n            }\r\n        }\r\n\r\n        if(type=== 'slides' && !This.initialResolution){\r\n            This.initialResolution = {}\r\n            if(parseSDP.media[i].framerate){\r\n                This.initialResolution.framerate = parseSDP.media[i].framerate\r\n            }\r\n            for(let fmtpItem of parseSDP.media[i].fmtp){\r\n                if(fmtpItem.config.indexOf('profile-level-id') >= 0){\r\n                    let levelIdc = fmtpItem.config.substr(21, 2).toLowerCase()\r\n                    let resolution = {}\r\n                    switch (levelIdc) {\r\n                        case '15':\r\n                            resolution = {width: 480, height: 272}\r\n                            break;\r\n                        case '16':\r\n                            resolution = {width: 640, height: 360}\r\n                            break;\r\n                        case '1e':\r\n                            resolution = {width: 848, height: 480}\r\n                            break;\r\n                        case '1f':\r\n                            resolution = {width: 1280, height: 720}\r\n                            break;\r\n                        case '28':\r\n                            resolution = {width: 1920, height: 1080}\r\n                            break;\r\n                        case '33':\r\n                            resolution = {width: 3840, height: 2160}\r\n                            break\r\n                        default:\r\n                            resolution = {width: 640, height: 360}\r\n                            log.info('return default value 640 * 360')\r\n                            log.info(\"getH264ResolutionBySdp: The value is out of the range, \" + levelIdc);\r\n                            break;\r\n                    }\r\n                    This.initialResolution.width = resolution.width\r\n                    This.initialResolution.height = resolution.height\r\n                    log.warn(\"screen resolution = \" , This.initialResolution.width  + \" * \" +  This.initialResolution.height)\r\n\r\n                    break\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    parseSDP.media = mediaArray\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n    return sdp\r\n}\r\n\r\n/**\r\n * decorate remote sdp，修改profile-level-id的值\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.modifyProfile = function(sdp){\r\n    log.info(\"modified profile-level-id\")\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    for(let i=0; i< parseSDP.media.length; i++) {\r\n        for(let fmtpItem of parseSDP.media[i].fmtp) {\r\n            if (fmtpItem.config.indexOf('profile-level-id') >= 0) {\r\n                let index = fmtpItem.config.indexOf('profile-level-id=')\r\n                let levelIdc = fmtpItem.config.substr(index+21, 2)\r\n                let replacement = 'profile-level-id=42e0' + levelIdc\r\n                fmtpItem.config = fmtpItem.config.replace(/profile-level-id=([a-zA-Z0-9]{6})/, replacement);\r\n            }\r\n        }\r\n    }\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n    return sdp\r\n}\nGsRTC.prototype.HTML_MEDIA_ELEMENT = {\r\n    localAudio: null,\r\n    localVideo: null,\r\n    localPresentVideo: null,\r\n    localVideoShare: null,\r\n    remoteAudio: null,\r\n    remoteVideo: null,\r\n    remotePresentVideo: null,\r\n    remoteVideoShare: null,\r\n}\r\n\r\n/**\r\n * save local && remote stream\r\n * @type {{LOCAL_PRESENT_STREAM: null, LOCAL_VIDEO_SHARE_STREAM: null, REMOTE_VIDEO_SHARE_STREAM: null, LOCAL_AUDIO_STREAM: null, REMOTE_PRESENT_STREAM: null, REMOTE_AUDIO_STREAM: null, LOCAL_VIDEO_STREAM: null, REMOTE_VIDEO_STREAM: null}}\r\n */\r\nGsRTC.prototype.MEDIA_STREAMS = {\r\n    LOCAL_AUDIO_STREAM: null,\r\n    REMOTE_AUDIO_STREAM: null,\r\n    LOCAL_VIDEO_STREAM: null,\r\n    REMOTE_VIDEO_STREAM: null,\r\n    LOCAL_PRESENT_STREAM: null,\r\n    REMOTE_PRESENT_STREAM: null,\r\n    LOCAL_VIDEO_SHARE_STREAM : null,\r\n    REMOTE_VIDEO_SHARE_STREAM : null\r\n};\r\n\r\n/**\r\n * Save upstream or downstream resolution\r\n * @type {{EXPECT_RECV_RESOLUTION: {}, CURRENT_UP_RESOLUTION: {}}}\r\n */\r\nGsRTC.prototype.VIDEO_RESOLUTION = {\r\n    CURRENT_UP_RESOLUTION: {},\r\n    EXPECT_RECV_RESOLUTION: {},\r\n}\r\n\r\nGsRTC.prototype.MID_OBJ = {\r\n    AUDIO_MID: { ORIGINAL_MID: null, MODIFIED_MID: null },\r\n    MAIN_MID: { ORIGINAL_MID: null, MODIFIED_MID: null },\r\n    SLIDES_MID: { ORIGINAL_MID: null, MODIFIED_MID: null},\r\n    GUI_MID: { ORIGINAL_MID: null, MODIFIED_MID: null}\r\n}\r\n\r\nGsRTC.prototype.CODE_TYPE = {\r\n    VIDEO_ON_FAILED: { codeType: 101, message: 'failed to video on' },\r\n    AUDIO_REFRESH_FAILED: { codeType: 102, message: 'failed to refresh audio' },\r\n    PRESENT_ON_FAILED: { codeType: 103, message: 'failed to present on' },\r\n\r\n\r\n    /********************重新设置错误（来自webRTC的JS层内部的错误码）*****************************/\r\n    INVALID_WEBSOCKET_ADDRESS: { codeType: 300, message: 'webSocket address is not a valid address' },\r\n    NOT_SUPPORT_SCREEN_SHARE:{codeType:301,message:'The current browser version does not support Screen share'},\r\n    WEBSOCKET_CLOSE:{codeType:302,message:'Websocket automatically disconnected'},\r\n    CANCEL_PRESENT_ON:{codeType:303,message:'cancel shareScreen',rejectAuthorizationTip:'false'},\r\n    SHARE_SCREEN_TIMEOUT:{codeType:308,message:'open shareScreen timeout'},\r\n    SUCCESS:{codeType:200,message:'operate success'},\r\n\r\n    /********************重新设置错误（来自GSphone的错误码）*****************************/\r\n    PRESENT_ON_REJECT: { codeType: 405, message: 'the call in Hold status!' },\r\n    REFUSE_CALL:{codeType:488,message:'Media information ERROR'},\r\n\r\n    /********************重新设置错误（来自webrtc 传给 GSphone的错误码）*****************************/\r\n    PRESENT_ON_SHARING:{codeType: 104, message: 'Share screen is being turned on'},\r\n    PRESENT_OFF_SHARING:{codeType: 105, message: 'Stop Share Screen is being turned on'},\r\n    REJECT_MULTIPLE_REQUESTS:{codeType: 106, message: 'Reject shareScreen or stopShareScreen request again after replying to the signaling'},\r\n    SHARE_SCREEN_REQUEST_REFUSE: { codeType: 403, message: 'Present turn On Request denied'  },\r\n    STOP_SHARE_SCREEN_REQUEST_REFUSE: { codeType: 403, message: 'Present turn Off Request denied'  },\r\n    HANG_UP_REQUEST_REFUSE:{codeType: 403, message: 'hang up Request denied' },\r\n\r\n}\r\n\r\nGsRTC.prototype.SIGNAL_EVENT_TYPE = {\r\n    // (Web发送到GsPhone的信令类型)\r\n    INVITE: { id: 0x01 << 1, name: 'createMediaSession' },                      // 建立会话\r\n    RE_INVITE: { id: 0x01 << 2, name: 'updateMediaSession' },                   // 更新会话信息\r\n\r\n    // (GsPhone发送到Web端的信令类型)\r\n    INVITE_RET: { id: 0x01 << 3, name: 'createMediaSessionRet' },               // 建立会话的回复\r\n    RE_INVITE_RET: { id: 0x01 << 4, name: 'updateMediaSessionRet' },            // 更新会话信息的回复\r\n\r\n    // (Web->GsPhone 和 GsPhone->Web 共有信令类型)\r\n    PRESENT: { id: 0x01 << 5, name: 'ctrlPresentation' },                        // 请求开启演示\r\n    PRESENT_RET: { id: 0x01 << 6, name: 'ctrlPresentationRet' },                 // 收到请求开启演示的回复信令\r\n    MESSAGE: { id: 0x01 << 7, name: 'sendMessageToUser' },                       // 发送消息\r\n    MESSAGE_RET: { id: 0x01 << 8, name: 'sendMessageToUserRet' },                // 收到消息后的回复信令\r\n    UPDATE_USER_INFO: { id: 0x01 << 9, name: 'updateUserInfo' },                 // 更新用户信息\r\n    UPDATE_USER_INFO_RET: { id: 0x01 << 10, name: 'updateUserListRet' },         // 收到更新用户信息后的回复信令\r\n    UPDATE_USER_LIST: { id: 0x01 << 11, name: 'updateUserList' },                 // 更新用户列表\r\n    UPDATE_USER_LIST_RET: { id: 0x01 << 12, name: 'updateUserListRet' },         // 收到更新用户列表后的回复信令\r\n    UPDATE_CANDIDATE_INFO: { id: 0x01 << 13, name: 'updateCandidate' },          // trickle-ice 时用来发送candidate\r\n    UPDATE_CANDIDATE_INFO_RET: { id: 0x01 << 14, name: 'updateCandidateRet' },   // trickle-ice 时收到candidate时的回复信令\r\n    BYE: { id: 0x01 << 15, name: 'destroyMediaSession' },                         // 结束会话\r\n    BYE_RET: { id: 0x01 << 16, name: 'destroyMediaSessionRet' },                  // 结束会话的回复\r\n    CANCEL:  { id: 0x01 << 17, name: 'cancelRequest' },                           // 请求取消开启演示信令\r\n    CANCEL_RET: { id: 0x01 << 18, name: 'cancelRequestRet' },                     // 收到取消开启演示的回复信令\r\n    CLOSE:  { id: 0x01 << 19, name: 'close ' },                                  //  收到请求开启演示的回复信令但已关闭流，即发送gsPhone关闭重置\r\n}\r\n\r\n\r\n\nvar log = {};\r\nlog.debug = window.debug(\"GSRTC_EVENT:DEBUG\");\r\nlog.log = window.debug(\"GSRTC_EVENT:LOG\");\r\nlog.info = window.debug(\"GSRTC_EVENT:INFO\");\r\nlog.warn = window.debug(\"GSRTC_EVENT:WARN\");\r\nlog.error = window.debug(\"GSRTC_EVENT:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/**\r\n * Event registration\r\n */\r\nGsRTC.prototype.eventBindings = function(){\r\n    log.info('event binding.')\r\n    let This = this\r\n}\r\n\r\n/**\r\n * 获得授权后处理\r\n * @param confirm: true 表示同意， false表示拒绝\r\n */\r\nGsRTC.prototype.serverPresentRequest = function (confirm) {\r\n    log.info(\"confirm:\",confirm)\r\n    let This = this\r\n    switch (This.serverAction) {\r\n        case 'shareScreenRequest':\r\n            if(confirm){\r\n                This.RTCSession.sharingPermission = 3\r\n                beginScreen()\r\n            }else {\r\n                This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: This.CODE_TYPE.SHARE_SCREEN_REQUEST_REFUSE, reqId: This.RTCSession.reqId})\r\n                if(This.RTCSession.timeBox){\r\n                    clearInterval(This.RTCSession.timeBox)\r\n                    This.RTCSession.timeBox = null\r\n                }\r\n                This.RTCSession.openSharingTimeoutstartTime = null\r\n                This.RTCSession.openSharingTimestamp = null\r\n                This.RTCSession.sendCtrlPresentation = false\r\n            }\r\n            break\r\n        case 'stopShareScreenRequest':\r\n            if(confirm){\r\n                This.RTCSession.sharingPermission = 2\r\n                stopScreen()\r\n            }else {\r\n                This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: This.CODE_TYPE.STOP_SHARE_SCREEN_REQUEST_REFUSE, reqId: This.RTCSession.reqId})\r\n                This.RTCSession.sendCtrlPresentation = false\r\n            }\r\n            break\r\n        case 'hangupRequest':\r\n            if(confirm){\r\n                This.RTCSession.sharingPermission = 4\r\n                hangUP()\r\n            }else{\r\n                This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.BYE_RET, destroyMediaSessionRet: This.CODE_TYPE.HANG_UP_REQUEST_REFUSE, reqId: This.RTCSession.reqId})\r\n            }\r\n            break\r\n        default:\r\n            break\r\n    }\r\n\r\n    This.serverAction = null\r\n}\r\n/**\r\n * 从发送演示信令到取流的过程中计算时间，查看是否超时（针对远程遥控处理）\r\n *\r\n */\r\nGsRTC.prototype.openSharingTimeout = function(data){\r\n    log.info(\"Whether share desktop time out\")\r\n    let  This = this\r\n    let session = This.RTCSession\r\n    session.timeBox = setInterval(function(){\r\n        session.openSharingTimestamp = Math.round(((new Date()).getTime() - session.openSharingTimeoutstartTime)/1000)\r\n        if(session.openSharingTimestamp > 30){\r\n            if(session.sharingPermission !== 3){\r\n                session.openSharingTimestamp = null\r\n            }\r\n            log.info(\"shareScreen timeout\")\r\n            This.action = 'shareScreenRequest'\r\n            session.reqId = data.reqId\r\n            This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: This.CODE_TYPE.SHARE_SCREEN_TIMEOUT, reqId: session.reqId})\r\n            This.trigger(\"error\",{ codeType: This.CODE_TYPE.SHARE_SCREEN_TIMEOUT.codeType, message: This.CODE_TYPE.SHARE_SCREEN_TIMEOUT.message})\r\n            session.openSharingTimeoutstartTime = null\r\n            session.sendCtrlPresentation = false\r\n            clearInterval(session.timeBox)\r\n        }\r\n    }, 1000)\r\n}\r\n\r\n/**\r\n * 从开始发送演示信令到收到演示信令的回复信令，查看是否超时（针对webUI处理）\r\n */\r\nGsRTC.prototype.replyOpenSharingTimeout = function(){\r\n    let This = this\r\n    let stream = This.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n    This.RTCSession.timeBox = setInterval(function(){\r\n        This.RTCSession.openSharingTimestamp = Math.round(((new Date()).getTime() -  This.RTCSession.openSharingTimeoutstartTime)/1000)\r\n        if( This.RTCSession.openSharingTimestamp >  This.RTCSession.replyOpenSharingTimerTime && stream){\r\n            log.warn(\"timeOut and no receive reply of shareScreen signaling\")\r\n            if(stream){\r\n                This.sendCancel(stream)\r\n            }\r\n        }\r\n    },1000)\r\n}\r\n/**\r\n * 从webui页面获取参数:分辨率\r\n */\r\n\r\nGsRTC.prototype.getResolutionFromWebUI =  function(getPreImgSize){\r\n    log.info(\"get webUI Resolution\")\r\n    getPreImgSize = parseInt(getPreImgSize)\r\n    let resolution = {}\r\n    if(getPreImgSize === 720){\r\n        resolution = {width: 1280, height: 720}\r\n    }else if(getPreImgSize === 1080){\r\n        resolution = {width: 1920, height: 1080}\r\n    }\r\n    log.warn(\"resolution:\",resolution)\r\n    return resolution;\r\n}\r\n\r\n/**\r\n * 清除定时器\r\n * */\r\nGsRTC.prototype.clearTimer = function(){\r\n    let This = this\r\n    if(This.RTCSession.timeBox){\r\n        clearInterval( This.RTCSession.timeBox)\r\n    }\r\n    This.RTCSession.timeBox = null\r\n    This.RTCSession.openSharingTimeoutstartTime = null\r\n    This.RTCSession.openSharingTimestamp = null\r\n}\r\n\r\n\r\n/**\r\n * 发送cancel信令\r\n * */\r\nGsRTC.prototype.sendCancel = function (stream){\r\n    log.info(\"send cancel process\")\r\n    let This = this\r\n    if(stream){\r\n        This.RTCSession.closeStream(stream)\r\n    }\r\n    This.sokect.sendMessage({type: This.SIGNAL_EVENT_TYPE.CANCEL, cancelRequest: { cancelReqCmd: This.RTCSession.cancelReqCmd, value: This.RTCSession.sharingPermission,\r\n            reqId: This.RTCSession.reqId, cancelReqId:This.RTCSession.cancelReqId}} )\r\n    This.clearTimer()\r\n}\n/*Log Debug Start*/\r\nvar log = {};\r\nlog.debug = window.debug(\"GSRTC_STREAM:DEBUG\");\r\nlog.log = window.debug(\"GSRTC_STREAM:LOG\");\r\nlog.info = window.debug(\"GSRTC_STREAM:INFO\");\r\nlog.warn = window.debug(\"GSRTC_STREAM:WARN\");\r\nlog.error = window.debug(\"GSRTC_STREAM:ERROR\");\r\n/*Log Debug End*/\r\n\r\n/***\r\n * Function that clear stream, free resources\r\n * @param stream\r\n */\r\nPeerConnection.prototype.closeStream = function(stream){\r\n    if(!stream){\r\n        log.info('closeStream:stream is null');\r\n        return;\r\n    } else{\r\n        log.info(\"close stream id: \" + stream.id);\r\n    }\r\n\r\n    try {\r\n        stream.oninactive = null;\r\n        gsRTC.RTCSession.stopTrack(stream)\r\n    }\r\n    catch (error) {\r\n        log.info('closeStream: Failed to close stream');\r\n        log.info(error);\r\n    }\r\n    stream = null;\r\n}\r\n/**\r\n * Bind page media elements after streaming successfully\r\n * @param type\r\n * @param stream\r\n * @param isLocal\r\n */\r\nPeerConnection.prototype.setMediaElementStream = function (stream, type, isLocal) {\r\n    log.info('get local/remote stream , ' + type)\r\n    let prefix = isLocal === true ? 'local' : 'remote'\r\n    let identify = null\r\n\r\n    let isVideo = !(type === 'audio')\r\n    switch (type) {\r\n        case 'audio':\r\n            identify = prefix + 'Audio'\r\n            break;\r\n        case 'main':\r\n            identify = prefix + 'Video'\r\n            break;\r\n        case 'slides':\r\n            identify = prefix + 'PresentVideo'\r\n            break;\r\n        case 'localVideoShare':\r\n            identify = prefix + 'VideoShare'\r\n            break\r\n        case 'multiStreamPeer':\r\n            // 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video\r\n            if(stream.getAudioTracks().length > 0){\r\n                identify = prefix + 'Audio'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!gsRTC.HTML_MEDIA_ELEMENT[prefix + 'Video'].srcObject){\r\n                    identify = prefix + 'Video'\r\n                }else if(!gsRTC.HTML_MEDIA_ELEMENT[prefix + 'PresentVideo'].srcObject){\r\n                    identify = prefix + 'PresentVideo'\r\n                }else if(!gsRTC.HTML_MEDIA_ELEMENT[prefix + 'VideoShare'].srcObject){\r\n                    identify = prefix + 'VideoShare'\r\n                }\r\n            }\r\n            break\r\n        default:\r\n            break;\r\n\r\n    }\r\n\r\n\r\n    // Fires when video metadata loading is complete (displays the current video resolution)\r\n    function displayVideoDimensions(e) {\r\n        let className = e.target.id + '_dimensions'\r\n        let dimensions = document.getElementsByClassName(className);\r\n        if(dimensions && dimensions[0] && e.target.videoWidth){\r\n            dimensions[0].innerHTML = e.target.videoWidth + ' x ' + e.target.videoHeight\r\n        }\r\n    }\r\n\r\n    let target = gsRTC.HTML_MEDIA_ELEMENT[identify]\r\n    if (target) {\r\n        target.srcObject = stream;\r\n        log.info('Get ' + identify +' stream');\r\n        if(isVideo){\r\n            log.info('set video _dimensions')\r\n            target.onloadedmetadata = displayVideoDimensions\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get type by stream id\r\n * 不支持addTransceiver的浏览器无法判断收到的流的类型，只能判断是audio还是video\r\n * @param streamId\r\n * @returns {string}\r\n */\r\nPeerConnection.prototype.getTypeByStreamId = function(streamId){\r\n    let type\r\n    for(let key in gsRTC.MEDIA_STREAMS){\r\n        if(gsRTC.MEDIA_STREAMS[key] && gsRTC.MEDIA_STREAMS[key].id === streamId){\r\n            type = key\r\n        }\r\n    }\r\n    if(type){\r\n        type = type.split('_')[1].toLowerCase()\r\n    }\r\n    return type\r\n}\r\n\r\n/**\r\n * get stream from canvas\r\n * @param number\r\n * @returns {Array}\r\n */\r\nPeerConnection.prototype.getCaptureStream = function(number){\r\n    let captureStreamArray = []\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.id = 'canvasForCaptureStream'\r\n    canvas.style.cssText = \"display: none\"\r\n\r\n    function gum() {\r\n        let stream = null\r\n        if(canvas.captureStream){\r\n            stream = canvas.captureStream(5);\r\n        }else if(canvas.mozCaptureStream){\r\n            stream = canvas.mozCaptureStream(5);\r\n        }else {\r\n            log.warn('Current browser does not support captureStream!!')\r\n            return\r\n        }\r\n        log.info(\"get captureStream: \", stream)\r\n        return stream\r\n    }\r\n\r\n    for(let i = 0; i<number; i++){\r\n        let stream = gum();\r\n        captureStreamArray.push(stream)\r\n    }\r\n    canvas = null\r\n    return captureStreamArray\r\n}\r\n\r\n/**\r\n * get stream type\r\n * @param type audio/main/slides/localVideo\r\n * @param isLocal\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getStreamType = function(type, isLocal){\r\n\r\n    let streamType = null\r\n    if(isLocal){\r\n        switch (type) {\r\n            case 'audio':\r\n                streamType = 'LOCAL_AUDIO_STREAM'\r\n                break\r\n            case 'main':\r\n                streamType = 'LOCAL_VIDEO_STREAM'\r\n                break\r\n            case 'slides':\r\n                streamType = 'LOCAL_PRESENT_STREAM'\r\n                break\r\n            case 'localVideoShare':\r\n                streamType = 'LOCAL_VIDEO_SHARE_STREAM'\r\n                break\r\n            default:\r\n                log.info('no match type: '+ type)\r\n                break\r\n        }\r\n    }else {\r\n        switch (type) {\r\n            case 'audio':\r\n                streamType = 'REMOTE_AUDIO_STREAM'\r\n                break\r\n            case 'main':\r\n                streamType = 'REMOTE_VIDEO_STREAM'\r\n                break\r\n            case 'slides':\r\n                streamType = 'REMOTE_PRESENT_STREAM'\r\n                break\r\n            case 'localVideoShare':\r\n                streamType = 'REMOTE_VIDEO_SHARE_STREAM'\r\n                break\r\n            default:\r\n                log.info('no match type: '+ type)\r\n                break\r\n        }\r\n    }\r\n    return streamType\r\n}\r\n\r\n/**\r\n * set stream\r\n * @param stream\r\n * @param type: audio, main, slides, localVideoShare\r\n * @param isLocal :true for the local stream and false for the accepted remote stream\r\n */\r\nPeerConnection.prototype.setStream = function(stream, type, isLocal){\r\n    if (!type){\r\n        log.warn(\"setStream: Invalid parameter!\");\r\n        return\r\n    }\r\n\r\n    let streamId = stream ? stream.id : null\r\n    let streamType = this.getStreamType(type, isLocal)\r\n    // multiStream: Browsers that do not support replaceTrack can only be judged by the type of stream\r\n    if(!streamType && stream){\r\n        if(isLocal){\r\n            if(stream.getAudioTracks().length > 0){\r\n                streamType = 'LOCAL_AUDIO_STREAM'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!gsRTC.MEDIA_STREAMS['LOCAL_VIDEO_STREAM']){\r\n                    streamType = 'LOCAL_VIDEO_STREAM'\r\n                }else {\r\n                    streamType = 'LOCAL_PRESENT_STREAM'\r\n                }\r\n            }\r\n        }else {\r\n            if(stream.getAudioTracks().length > 0){\r\n                streamType = 'REMOTE_AUDIO_STREAM'\r\n            }else if(stream.getVideoTracks().length > 0){\r\n                if(!gsRTC.MEDIA_STREAMS['REMOTE_VIDEO_STREAM']){\r\n                    streamType = 'REMOTE_VIDEO_STREAM'\r\n                }else {\r\n                    streamType = 'REMOTE_PRESENT_STREAM'\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    log.info('set ' + streamType + ' stream id: ' + streamId)\r\n    gsRTC.MEDIA_STREAMS[streamType] = stream\r\n\r\n    if(stream){\r\n        this.setMediaElementStream(stream, type, isLocal)\r\n    }\r\n}\r\n\r\n/***\r\n * get stream\r\n * @param isLocal: true for the local stream and false for the accepted remote stream\r\n * @param type audio, main, slides, localVideoShare\r\n * @returns {*}\r\n */\r\nPeerConnection.prototype.getStream = function(type, isLocal){\r\n    if (!type){\r\n        log.warn(\"getStream: Invalid parameter!\");\r\n        return\r\n    }\r\n\r\n    let streamType = this.getStreamType(type, isLocal)\r\n    let stream = gsRTC.MEDIA_STREAMS[streamType]\r\n\r\n    if(stream){\r\n        log.info('get ' + streamType + ' stream id :' + stream.id)\r\n    }else {\r\n        log.info('stream null')\r\n    }\r\n    return stream\r\n}\r\n\r\n/***\r\n * Function that stream mute and unmute switch\r\n * @param data 示例{\r\n *\t\tstream: stream\r\n *\t  type: 'audio'\r\n *\t  mute: true\r\n * }\r\n */\r\nPeerConnection.prototype.streamMuteSwitch = function(data){\r\n    if(data.stream){\r\n        log.info(\"MuteStream: stream id = \" + data.stream.id);\r\n    }else {\r\n        log.warn(\"stream is not exist!\")\r\n        return\r\n    }\r\n\r\n    if ( data && data.stream && data.type === 'audio' && data.stream.getAudioTracks().length > 0 ){\r\n        for ( let i = 0; i < data.stream.getAudioTracks().length; i++ ) {\r\n            if (data.mute){\r\n                if ( data.stream.getAudioTracks()[i].enabled === true ) {\r\n                    log.info(\"MuteStream exec mute audio\");\r\n                    data.stream.getAudioTracks()[i].enabled = false;\r\n                }\r\n            }\r\n            else{\r\n                if ( data.stream.getAudioTracks()[i].enabled === false ) {\r\n                    log.info(\"MuteStream exec unmute audio\");\r\n                    data.stream.getAudioTracks()[i].enabled = true;\r\n                }\r\n            }\r\n        }\r\n    } else if( (data.type === 'video' || data.type === 'slides' ) && data.stream.getVideoTracks().length > 0 ){\r\n        for ( let j = 0; j < data.stream.getVideoTracks().length; j++ ) {\r\n            if (data.mute){\r\n                if ( data.stream.getVideoTracks()[j].enabled === true ) {\r\n                    log.info(\"MuteStream exec mute video/slides\");\r\n                    data.stream.getVideoTracks()[j].enabled = false;\r\n                }\r\n            }\r\n            else{\r\n                if ( data.stream.getVideoTracks()[j].enabled === false ) {\r\n                    log.info(\"MuteStream exec unmute video/slides\");\r\n                    data.stream.getVideoTracks()[j].enabled = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/***\r\n * Function that add stream\r\n * @param stream\r\n * @param pc\r\n * @param type\r\n */\r\nPeerConnection.prototype.processAddStream = function (stream, pc, type) {\r\n    log.info('process add stream')\r\n    let This = this\r\n    let mid =  gsRTC.getOriginalMid(type)\r\n    let transceiverTarget\r\n    pc.getTransceivers().map(function (item) {\r\n        if(item.mid == mid){\r\n            transceiverTarget = item\r\n        }\r\n    })\r\n\r\n    if(gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n        if (!RTCRtpTransceiver.prototype.setDirection){\r\n            /** Direction setting occasionally does not trigger onnegotiationneeded */\r\n            transceiverTarget.direction = 'sendonly';\r\n            transceiverTarget.direction = 'inactive';\r\n            let track = (type === 'audio') ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0]\r\n            transceiverTarget.sender.replaceTrack(track)\r\n                .then(function () {\r\n                    log.info('use replaceTrack to add stream ');\r\n                })\r\n                .catch(function (error) {\r\n                    console.error(error)\r\n                    log.error(error.toString());\r\n                });\r\n            transceiverTarget.direction = 'sendrecv';\r\n        }else{\r\n            log.info('use replaceTrack to add stream ');\r\n            transceiverTarget.setDirection('sendrecv');\r\n        }\r\n    }else {\r\n        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */\r\n        let browserDetail = gsRTC.getBrowserDetail()\r\n        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === \"11.0.2\" || browserDetail.UIVersion === \"11.1.2\" ) && transceiverTarget){\r\n            transceiverTarget.sender.replaceTrack(stream.getTracks()[0])\r\n                .then(function () {\r\n                    log.info('use replaceTrack to add stream ');\r\n                })\r\n                .catch(function (error) {\r\n                    log.error(error.toString());\r\n                });\r\n        }else if(stream){\r\n            log.info('use addStream to add stream.');\r\n            pc.addStream(stream);\r\n        }\r\n    }\r\n}\r\n\r\n/***\r\n * Function that remove stream\r\n * @param stream\r\n * @param pc\r\n * @param type\r\n */\r\nPeerConnection.prototype.processRemoveStream = function (stream, pc, type) {\r\n    let This = this\r\n    log.info('process remove stream')\r\n\r\n    let mid = gsRTC.getOriginalMid(type)\r\n    let transceiverTarget\r\n    pc.getTransceivers().forEach(function (item) {\r\n        if(mid == item.mid){\r\n            transceiverTarget = item\r\n        }\r\n    })\r\n\r\n    if(gsRTC.isReplaceTrackSupport() && pc.getTransceivers().length > 0){\r\n        if (!RTCRtpTransceiver.prototype.setDirection){\r\n            /** Direction setting occasionally does not trigger onnegotiationneeded */\r\n            transceiverTarget.direction = 'sendonly';\r\n            transceiverTarget.direction = 'inactive';\r\n\r\n            transceiverTarget.direction = 'recvonly';\r\n            transceiverTarget.sender.replaceTrack(null)\r\n                .then(function () {\r\n                    log.info('use replaceTrack to add stream ');\r\n                })\r\n                .catch(function (error) {\r\n                    log.error(error.toString());\r\n                })\r\n        }else{\r\n            log.info('use replaceTrack to remove stream.');\r\n            transceiverTarget.setDirection('recvonly');\r\n        }\r\n    }else {\r\n        /** see bug 137445 for safari 11.0.2 and 11.1.2 * */\r\n        let browserDetail = gsRTC.getBrowserDetail()\r\n        if(browserDetail.browser === 'safari' && (browserDetail.UIVersion === \"11.0.2\" || browserDetail.UIVersion === \"11.1.2\" ) && transceiverTarget){\r\n            transceiverTarget.sender.track.enabled = false;\r\n        }else if(stream){\r\n            pc.removeStream(stream);\r\n        }\r\n        log.info('use removeStream to remove stream ');\r\n    }\r\n}\r\n\r\n// 针对stream.inactive 处理（关闭流）\r\nGsRTC.prototype.oninactiveStopStream = function(stream){\r\n    if(!stream){\r\n       log.warn(\"no stream\")\r\n        return\r\n    }\r\n    let This = this\r\n    if( This.RTCSession.sharingPermission === 1){\r\n        if( This.RTCSession.isOpenSharingReceiveReply === false){\r\n            log.info('do not receive reply of shareScreen signaling: user trigger  bar close stream')\r\n            if( This.RTCSession.isSendCancelRequest === false){\r\n                log.info('be ready to execute the cancel process ')\r\n                This.RTCSession.isSendCancelRequest = true\r\n                This.sendCancel(stream)\r\n            }else{\r\n                log.warn('reply cancelRequest')\r\n                //此场景暂时没有  如果有，则根据前端的传下来的参数关闭流即可\r\n            }\r\n        }else{\r\n            //gsphone 回复了开启演示信令\r\n            log.info('receive reply of shareScreen signaling: user  trigger  bar close stream')\r\n            if( This.RTCSession.isSendCancelRequest === false){\r\n                if( This.RTCSession.openSharing === false){\r\n                    This.RTCSession.isSendCancelRequest = true\r\n                    log.warn(\"be ready to execute the cancel process \")\r\n                    This.sendCancel(stream)\r\n                }else{\r\n                    log.info(\"user clicks the bottom share bar to stop sharing\")\r\n                    stopScreen()\r\n                }\r\n            }else{\r\n                if(This.RTCSession.openSharing === false){\r\n                    log.info(\"reply cancelRequest\")\r\n                    //发送cancel 此场景暂时没有；如果有，则根据前端的传下来的参数关闭流即可\r\n                }else{\r\n                    log.info(\"user clicks the bottom share bar to stop sharing\")\r\n                    stopScreen()\r\n                }\r\n            }\r\n        }\r\n    }else{\r\n        log.info(\"开启演示为: \"+This.RTCSession.sharingPermission + \" ,user clicks the bottom share bar to stop sharing\")\r\n        stopScreen()\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n\r\nPeerConnection.prototype.onConnectionStateChange = function(pc){\r\n    log.info('onConnectionStateChange type: ' + pc.type + ', connectionState: ' + pc.connectionState)\r\n    let browserDetails = gsRTC.getBrowserDetail()\r\n    if(pc.connectionState === 'failed' && ((browserDetails.browser === 'chrome' && browserDetails.version >= 76) || (browserDetails.browser === 'opera' &&browserDetails.chromeVersion >= 76))){\r\n        this.iceConnectFailed(pc);\r\n    }\r\n\r\n}\r\n\r\nPeerConnection.prototype.onIceConnectionStateChange = function(pc){\r\n    if (!pc) {\r\n        log.warn('Ignoring of ICE candidate event as Peer connection does not exists ->');\r\n        return\r\n    }\r\n\r\n    let iceState =  pc.iceConnectionState\r\n    log.info(\"onIceConnectionStateChange this type: \" + pc.type + \", iceConnectionState: \" + iceState);\r\n    switch (iceState) {\r\n        case 'new':\r\n        case 'starting':\r\n        case 'checking':\r\n            break\r\n        case 'connected':\r\n            if(pc.isIceFailed){\r\n                log.info(\"iceRestartSuccess alter web\");\r\n                this.onIceRestartSuccess(pc)\r\n            }\r\n            break\r\n        case 'failed':\r\n            this.iceConnectFailed(pc)\r\n            break\r\n        case 'completed':\r\n        case 'closed':\r\n        case 'disconnected':\r\n            break\r\n        default:\r\n            break\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onSignalingStateChange = function(pc){\r\n    if (!pc) {\r\n        log.info('PeerConnection is null: unexpected')\r\n        return\r\n    }\r\n    log.info('onSignalingStateChange type: ' + pc.type + ', signalingState: ' + pc.signalingState)\r\n}\r\n\r\nPeerConnection.prototype.onIceGatheringStateChange = function(pc){\r\n    if (!pc) {\r\n        log.info('PeerConnection is null: unexpected')\r\n        return\r\n    }\r\n\r\n    log.info('onicegatheringstatechange type: ' + pc.type + ', iceGatheringState: ' + pc.iceGatheringState)\r\n}\r\n\r\nPeerConnection.prototype.iceConnectFailed = function(pc){\r\n    log.warn(\"iceConnectFailed, o_failure_num: \" + pc.iceFailureNum + \"  (PC:\" + pc.type + \")\");\r\n    pc.action = 'iceRestart'\r\n    // Re-connected three times without success is considered a failure\r\n    if(pc.iceFailureNum >= 3){\r\n        log.error(\"Failed to do ice restart(PC: \" + pc.type + \")\");\r\n        if(!pc.isIceFailed){\r\n            pc.isIceFailed = true\r\n        }\r\n        this.onIceRestartFailed(pc);\r\n    }else {\r\n        log.info('Prepare start do ice restart！')\r\n        pc.isIceFailed = true\r\n        pc.isLocalSdpPending = true\r\n        this.doOffer(pc)\r\n        pc.iceFailureNum ++\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceRestartSuccess = function (pc) {\r\n    log.info(\"ice restart success\" + \"  (PC:\" + pc.type + \")\")\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = false\r\n}\r\n\r\nPeerConnection.prototype.onIceRestartFailed = function (pc) {\r\n    log.error(\"ice restart failed\")\r\n    pc.iceFailureNum = 0\r\n    pc.isIceFailed = true\r\n    log.info('close peer')\r\n    // close peerConnection\r\n    pc.getSenders().forEach(sender => {\r\n        delete sender.track\r\n        sender.replaceTrack(null)\r\n    })\r\n    pc.close()\r\n}\r\n\r\nPeerConnection.prototype.onIceCandidate = function (pc, event) {\r\n    let iceState = pc.iceGatheringState\r\n    if(iceState === \"completed\" || iceState === \"complete\" || (event && !event.candidate)){\r\n        log.warn(\"onIceCandidate: ICE GATHERING COMPLETED( PC: \" + pc.type + \")\");\r\n        pc.isLocalSdpPending = false\r\n        this.onIceGatheringCompleted();\r\n    }else {\r\n        log.info(`ICE candidate:\\n${event.candidate ? event.candidate.candidate : '(null)'}`);\r\n    }\r\n}\r\n\r\nPeerConnection.prototype.onIceGatheringCompleted = function () {\r\n    let This = this\r\n    if(!This.isProcessingInvite){\r\n        return\r\n    }\r\n\r\n    let pc = gsRTC.RTCSession.peerConnection\r\n    if(pc.isLocalSdpPending === true){\r\n        log.info('MyOnIceGatheringCompleted not ready ')\r\n        return false;\r\n    }\r\n    log.warn(\"__MyOnIceGatheringCompleted be ready to send INVITE or 200OK\");\r\n\r\n    This.isProcessingInvite = false\r\n    let sdp = This.decorateLocalSDP()\r\n    gsRTC.saveSDPSessionVersion(sdp)\r\n    let data = {\r\n        type: This.isSendReInvite ? gsRTC.SIGNAL_EVENT_TYPE.RE_INVITE : gsRTC.SIGNAL_EVENT_TYPE.INVITE,\r\n        mediaSession: sdp\r\n    }\r\n    gsRTC.sokect.sendMessage(data)\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\r\n/**\r\n * set sdp session version\r\n * @param sdp\r\n */\r\nGsRTC.prototype.saveSDPSessionVersion = function (sdp) {\r\n    log.info('set local sdp session version value')\r\n    if(!sdp){\r\n        log.warn('invalid parameters local sdp!')\r\n        return\r\n    }\r\n\r\n    let parseSdp = SDPTools.parseSDP(sdp)\r\n    this.sessionVersion = parseSdp.origin.sessionVersion\r\n}\r\n\r\n/**\r\n * get resolution bu given level idc\r\n * @param levelIdc\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByLevelIdc = function(levelIdc){\r\n    if(!levelIdc){\r\n        log.warn('getResolutionByLevelIdc: levelIdc is null')\r\n        return null\r\n    }\r\n    let resolution\r\n    switch (levelIdc) {\r\n        case '33':\r\n            log.info('levelIdc ' + levelIdc + ', 3840 * 2160 ')\r\n            resolution = { width: 3840, height: 2160 }\r\n            break\r\n        case '28':\r\n            log.info('levelIdc ' + levelIdc + ', 1920 * 1080 ')\r\n            resolution = { width: 1920, height: 1080 }\r\n            break\r\n        case '1f':\r\n            log.info('levelIdc ' + levelIdc + ', 1280 * 720 ')\r\n            resolution = { width: 1280, height: 720 }\r\n            break\r\n        case '1e':\r\n            log.info('levelIdc ' + levelIdc + ', 848 * 480 ')\r\n            resolution = { width: 848, height: 480 }\r\n            break\r\n        case '16':\r\n            log.info('levelIdc ' + levelIdc + ', 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n        case '15':\r\n            log.info('levelIdc ' + levelIdc + ', 480 * 272 ')\r\n            resolution = { width: 480, height: 272 }\r\n            break\r\n        default:\r\n            log.info('levelIdc ' + levelIdc + ', get default 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get resolution bu given max-fs\r\n * @param maxFs\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByMaxfs = function(maxFs){\r\n    if(!maxFs){\r\n        log.warn('getResolutionByMaxfs: maxFs is null')\r\n        return null\r\n    }\r\n    let resolution\r\n\r\n    maxFs = parseInt(maxFs)\r\n    switch (maxFs) {\r\n        case 32400:\r\n            log.info('maxFs ' + maxFs + ', 3840 * 2160 ')\r\n            resolution = { width: 3840, height: 2160 }\r\n            break\r\n        case 8160:\r\n            log.info('maxFs ' + maxFs + ', 1920 * 1080 ')\r\n            resolution = { width: 1920, height: 1080 }\r\n            break\r\n        case 3600:\r\n            log.info('maxFs ' + maxFs + ', 1280 * 720 ')\r\n            resolution = { width: 1280, height: 720 }\r\n            break\r\n        case 1590:\r\n            log.info('maxFs ' + maxFs + ', 848 * 480 ')\r\n            resolution = { width: 848, height: 480 }\r\n            break\r\n        case 920:\r\n            log.info('maxFs ' + maxFs + ', 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n        case 510:\r\n            log.info('maxFs ' + maxFs + ', 480 * 272 ')\r\n            resolution = { width: 480, height: 272 }\r\n            break\r\n        default:\r\n            log.info('maxFs ' + maxFs + ', get default 640 * 360 ')\r\n            resolution = { width: 640, height: 360 }\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n *  get resolution by given height\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getResolutionByHeight = function(height){\r\n    if(!height){\r\n        log.warn('getResolutionByHeight: height is null')\r\n        return null\r\n    }\r\n    let resolution\r\n\r\n    height = parseInt(height)\r\n    switch (height) {\r\n        case 2160:\r\n            log.info('3840 * 2160')\r\n            resolution = {width: 3840, height: 2160}\r\n            break\r\n        case 1080:\r\n            log.info('1920 * 1080')\r\n            resolution = {width: 1920, height: 1080}\r\n            break\r\n        case 720:\r\n            log.info('1280 * 720')\r\n            resolution = {width: 1280, height: 720}\r\n            break;\r\n        case 480:\r\n            log.info('848 * 480')\r\n            resolution= {width: 848, height: 480}\r\n            break;\r\n        case 360:\r\n            log.info('640 * 360')\r\n            resolution= {width: 640, height: 360}\r\n            break;\r\n        default:\r\n            log.info(' Unknown resolution ' + height + ', default 640 * 360')\r\n            resolution = {width: 640, height: 360}\r\n            break;\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * save video resolution\r\n * @param resolution\r\n * @param type\r\n */\r\nGsRTC.prototype.setVideoResolution = function (resolution, type) {\r\n    if(!resolution || !type){\r\n        log.warn('setVideoResolution: INVALID PARAMETERS')\r\n        return\r\n    }\r\n    let This = this\r\n\r\n    switch (type) {\r\n        case 'EXPECT_RECV_RESOLUTION':\r\n            log.info('save expect receive resolution ' + resolution.height)\r\n            This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION = resolution\r\n            break\r\n        case 'CURRENT_UP_RESOLUTION':\r\n            log.info('save current up resolution ' + resolution.height)\r\n            This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION = resolution\r\n            break\r\n        default:\r\n            log.info('unknown resolution: ' + type)\r\n          break\r\n    }\r\n}\r\n\r\n/**\r\n * get saved video resolution\r\n * @param type\r\n * @returns {*|GsRTC.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION|{}|GsRTC.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION}\r\n */\r\nGsRTC.prototype.getVideoResolution = function (type) {\r\n    if(!type){\r\n        log.warn('getVideoResolution: INVALID PARAMETER')\r\n        return\r\n    }\r\n    let This = this\r\n    let resolution\r\n\r\n    switch (type) {\r\n        case 'EXPECT_RECV_RESOLUTION':\r\n            resolution = This.VIDEO_RESOLUTION.EXPECT_RECV_RESOLUTION\r\n            log.info('get expect receive resolution')\r\n            break\r\n        case 'CURRENT_UP_RESOLUTION':\r\n            resolution = This.VIDEO_RESOLUTION.CURRENT_UP_RESOLUTION\r\n            log.info('get current up resolution')\r\n            break\r\n        default:\r\n            log.info('unknown resolution :' + type)\r\n            break\r\n    }\r\n\r\n    return resolution\r\n}\r\n\n\r\n/**\r\n * Get the codec name corresponding to the highest priority PT in the sdp\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getPriorityCodecBySdp = function(sdp){\r\n    let codec = null\r\n   try {\r\n       if(sdp.media && sdp.media[0] && sdp.media[0].rtp){\r\n           let rtp = sdp.media[0].rtp\r\n           if(rtp && rtp.length > 0){\r\n               codec = rtp[0].codec\r\n           }\r\n       }\r\n   }catch (e) {\r\n       log.error(e.toString())\r\n   }\r\n    log.info('get priority payload, ' + codec)\r\n    return codec\r\n}\r\n\r\n/**\r\n * get framerate\r\n * order: framerate first, max-fr second\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getFramerateBySdp = function (sdp) {\r\n    let framerate = null\r\n    if(sdp.media && sdp.media[0]){\r\n        if(sdp.media[0].framerate){\r\n            framerate = sdp.media[0].framerate\r\n            log.info('framerate, ' + framerate)\r\n        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){\r\n            let fmtp = sdp.media[0].fmtp\r\n            for(let i = 0; i<fmtp.length; i++){\r\n                let pos_max_fr = fmtp[i].config.indexOf('max-fr')\r\n                if (pos_max_fr >= 0) {\r\n                    var max_fr = fmtp[i].config.substring(pos_max_fr + 7);\r\n                    var end = max_fr.indexOf(';');\r\n                    if (end >= 0) {\r\n                        max_fr = max_fr.substring(0, end);\r\n                    }\r\n                    log.info('max-fr, ' + max_fr)\r\n                    framerate =  parseInt(max_fr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    log.info('get framerate, ' + framerate)\r\n    return framerate\r\n}\r\n\r\n/**\r\n * get resolution from profile-level-id\r\n * @param sdp: parseSDP\r\n */\r\nGsRTC.prototype.getH264ResolutionBySdp = function(sdp){\r\n    if(!sdp){\r\n        log.warn('getH264ResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    let subSDP = SDPTools.writeSDP(sdp)\r\n    let index = subSDP.indexOf('profile-level-id')\r\n    let resolution = {}\r\n    if(index >= 0){\r\n        let levelIdc = subSDP.substr(index + 21, 2)\r\n        levelIdc = levelIdc.toLocaleLowerCase()\r\n        switch (levelIdc) {\r\n            case '15':\r\n                resolution = { width: 480, height: 272 }\r\n                break;\r\n            case '16':\r\n                resolution = { width: 640, height: 360 }\r\n                break;\r\n            case '1e':\r\n                resolution = { width: 848, height: 480 }\r\n                break;\r\n            case '1f':\r\n                resolution = { width: 1280, height: 720 }\r\n                break;\r\n            case '28':\r\n                resolution = { width: 1920, height: 1080 }\r\n                break;\r\n            case '33':\r\n                resolution = { width: 3840, height: 2160 }\r\n                break\r\n            default:\r\n                resolution = { width: 640, height: 360 }\r\n                log.info('return default value 640 * 360')\r\n                log.info(\"getH264ResolutionBySdp: The value is out of the range, \" + levelIdc);\r\n                break;\r\n        }\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)\r\n    }else {\r\n        log.info('get resolution {}')\r\n    }\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get vp8 resolution from max-fs\r\n * @param sdp: parseSDP\r\n */\r\nGsRTC.prototype.getVp8ResolutionBySdp = function(sdp){\r\n    if(!sdp){\r\n        log.warn('getVp8ResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    let subSDP = SDPTools.writeSDP(sdp)\r\n    let index = subSDP.indexOf('max-fs')\r\n    let resolution  = {}\r\n    if(index >= 0){\r\n        let maxFs = subSDP.substring(index + 7)\r\n        maxFs = parseInt(maxFs.substring(0,maxFs.indexOf(';')))\r\n        log.info('VP8, ' + maxFs)\r\n        switch (maxFs) {\r\n            case 520:\r\n                resolution = { width: 480, height: 272 }\r\n                break;\r\n            case  920:\r\n            case  900:\r\n                resolution = { width: 640, height: 360 }\r\n                break;\r\n            case 1596:\r\n                resolution = { width: 848, height: 480 }\r\n                break;\r\n            case 3600:\r\n                resolution = { width: 1280, height: 720 }\r\n                break;\r\n            case 8192:\r\n            case 8160:\r\n            case 8100:\r\n                resolution = { width: 1920, height: 1080 }\r\n                break;\r\n            case 32400:\r\n                resolution = { width: 3840, height: 2160 }\r\n                break\r\n            default:\r\n                resolution = { width: 640, height: 360 }\r\n                log.info('return default value 640 * 360')\r\n                log.info(\"get_vp8_resolution: The value is out of the range or invalid, \" + maxFs);\r\n                break;\r\n        }\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('get resolution ' + resolution.width + ' * ' + resolution.height)\r\n    }else {\r\n        log.info('get resolution {}')\r\n    }\r\n    return resolution\r\n}\r\n\r\n/**\r\n * get resolution\r\n * @param sdp : parseSDP\r\n */\r\nGsRTC.prototype.getResolutionBySdp = function (sdp) {\r\n    log.info('get resolution')\r\n    if(!sdp){\r\n        log.warn('getResolutionBySdp: Invalid argument!')\r\n        return\r\n    }\r\n    let codec = this.getPriorityCodecBySdp(sdp)\r\n    let resolution = {}\r\n\r\n    if(codec === 'H264'){\r\n        resolution = this.getH264ResolutionBySdp(sdp)\r\n    }\r\n    if(codec === 'VP8'){\r\n        resolution = this.getVp8ResolutionBySdp(sdp)\r\n    }\r\n\r\n    if(resolution && resolution.width && resolution.height){\r\n        log.info('resolution ' + resolution.width + \" * \" + resolution.height)\r\n    }else {\r\n        log.info('resolution {}')\r\n    }\r\n\r\n    return resolution\r\n}\r\n\r\n/**\r\n * set frameRate of sdp\r\n * order: framerate first ,max-fr second\r\n * @param sdp: parseSDP\r\n * @param framerate\r\n */\r\nGsRTC.prototype.setFrameRateOfSdp = function(sdp, framerate){\r\n    if(!sdp || !framerate){\r\n        log.warn('setFrameRate: Invalid argument!')\r\n        return\r\n    }\r\n\r\n    if(sdp.media && sdp.media[0]){\r\n        if(sdp.media[0].framerate){\r\n            log.info('change framerate ' + sdp.media[0].framerate + ' to ' + framerate)\r\n            sdp.media[0].framerate = framerate\r\n        }else if(sdp.media[0].fmtp && sdp.media[0].fmtp.length > 0){\r\n            let fmtp = sdp.media[0].fmtp\r\n            for(let i = 0; i<fmtp.length; i++){\r\n                let index = fmtp[i].config.indexOf('max-fr')\r\n                if (index >= 0) {\r\n                    let replacement =  'max-fr=' + framerate ;\r\n                    fmtp[i].config = fmtp[i].config.replace(/max-fr=([a-zA-Z0-9]{1,2})/, replacement);\r\n                    log.info('change max-fr to ' + framerate)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * Modify level-idc of sdp\r\n * @param sdp: parseSDP\r\n * @param width\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setH264ResolutionOfSdp = function(sdp, width, height){\r\n    if(!sdp || !width || !height){\r\n        log.warn('setH264ResolutionOfSdp: Invalid argument!')\r\n        return\r\n    }\r\n    let levelIdc = null\r\n    switch (height) {\r\n        case 2160:\r\n            levelIdc = '33'\r\n            break\r\n        case 1080:\r\n            levelIdc = '28'\r\n            break\r\n        case 720:\r\n            levelIdc = '1f'\r\n            break\r\n        case 480:\r\n            levelIdc = '1e'\r\n            break\r\n        case 360:\r\n            levelIdc = '16'\r\n            break\r\n        case 272:\r\n            levelIdc = '15'\r\n            break\r\n        default:\r\n            levelIdc = 16\r\n            log.info('set default levelIdc, ' + levelIdc)\r\n            break\r\n    }\r\n\r\n    log.info('set levelId of local sdp ' + levelIdc)\r\n\r\n    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp){\r\n        let fmtp = sdp.media[0].fmtp\r\n        if(fmtp.length > 0){\r\n            for(let i = 0; i < fmtp.length; i++){\r\n                let index  = fmtp[i].config.indexOf('profile-level-id')\r\n                if(index >= 0){\r\n                    let str = fmtp[i].config.substr(index, 21);\r\n                    let replacement =  str + levelIdc ;\r\n                    fmtp[i].config = fmtp[i].config.replace(/profile-level-id=([a-zA-Z0-9]{6})/, replacement);\r\n                }\r\n            }\r\n        }\r\n    }else {\r\n        log.info('profile-level-id fmtp filed has not been find')\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * Modify max-fs of sdp\r\n * @param sdp: parseSDP\r\n * @param width\r\n * @param height\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setVp8ResolutionOfSdp = function(sdp, width, height){\r\n    if(!sdp || !width || !height){\r\n        log.warn('setVp8ResolutionOfSdp: Invalid argument!')\r\n        return\r\n    }\r\n    let mbWidth = (parseInt(width, 10) + 15) / 16;\r\n    let mbHeight = (parseInt(height, 10) + 15) / 16;\r\n    let maxFs = Math.floor(mbWidth) * Math.floor(mbHeight);\r\n    log.info('set mas-fs ,' + maxFs)\r\n\r\n    if(sdp.media && sdp.media[0] && sdp.media[0].fmtp) {\r\n        let fmtp = sdp.media[0].fmtp\r\n        for (let i = 0; i < fmtp.length; i++) {\r\n            let index = fmtp[i].config.indexOf('max-fs')\r\n            if (index >= 0) {\r\n                let replacement = 'max-fs=' + maxFs;\r\n                fmtp[i].config = fmtp[i].config.replace(/max-fs=([a-zA-Z0-9]{3,5})/, replacement);\r\n            }\r\n        }\r\n    }else {\r\n        log.warn('max-fs fmtp filed has not been find')\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n *  Use the standard b=AS:BITRATE (Chrome) or b=TIAS:BITRATE (Firefox) attributes in the SDP for the audio or video channel\r\n * @param sdp\r\n * @param media\r\n * @param ASBitrate\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setMaxBitrate = function(sdp, media, ASBitrate) {\r\n    ASBitrate = ASBitrate ? ASBitrate : localStorage.getItem('maxBitRate') ? localStorage.getItem('maxBitRate') : ''\r\n    if(!ASBitrate){\r\n        log.warn('No bitrate has been set')\r\n        return sdp\r\n    }\r\n\r\n    // find m line place\r\n    var line = sdp.indexOf('m=' + media)\r\n    if(line === -1){\r\n        log.warn('Could not find the m line for ' + media)\r\n        return sdp\r\n    }\r\n    log.info('Find the m line for ' + media + ' at line ' + line)\r\n\r\n    // add a new b line\r\n    function addNewLine(_sdp, type, bitrate) {\r\n        var lines = _sdp.split(\"\\n\")\r\n        var mline = -1\r\n\r\n        // find m line place\r\n        for(var i = 0; i<lines.length; i++){\r\n            if(lines[i].indexOf('m=' + media) >= 0){\r\n                mline = i\r\n                break\r\n            }\r\n        }\r\n\r\n        // pass the m line\r\n        mline++\r\n\r\n        // Ship i and c lines\r\n        while (lines[mline].indexOf('i=') >= 0 || lines[mline].indexOf('c=') >= 0){\r\n            log.info(' Ship i and c lines')\r\n            mline++\r\n        }\r\n\r\n        // add a new b=AS or b=TIAS line\r\n        // log.warn('Adding new b line before line ' + mline)\r\n        var newLines = lines.slice(0, mline)\r\n        newLines.push('b=' + type + ':' + bitrate)\r\n        newLines = newLines.concat(lines.slice(mline, lines.length))\r\n\r\n        return newLines.join('\\n')\r\n    }\r\n\r\n    var replacement\r\n    if(sdp.indexOf('b=AS') >= 0){\r\n        log.warn('Replaced b=AS line at line '+ line)\r\n        replacement = \"b=AS:\" + ASBitrate\r\n        sdp = sdp.replace(/b=AS:([a-zA-Z0-9]{3,4})/, replacement);\r\n    }else {\r\n        sdp = addNewLine(sdp, 'AS', ASBitrate)\r\n    }\r\n\r\n    var TIASBitrate = ASBitrate * 1000\r\n    if(sdp.indexOf('b=TIAS') >= 0){\r\n        log.warn('Replaced b=TIAS line at line '+ line)\r\n        replacement = \"b=TIAS:\" + TIASBitrate\r\n        sdp = sdp.replace(/b=TIAS:([a-zA-Z0-9]{6,7})/, replacement);\r\n\r\n    }else {\r\n        sdp = addNewLine(sdp, 'TIAS', TIASBitrate)\r\n    }\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * set x-google-xxx-bitrate\r\n * @param sdp\r\n * @param bitrate\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.setXgoogleBitrate = function(sdp, bitrate) {\r\n    var lines = sdp.split(\"\\n\")\r\n    var replacement\r\n\r\n    // get all pt number, except rtx\\red\\ulpfec\r\n    var ptArr = []\r\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\r\n    sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(line) {\r\n        if(line.indexOf('a=rtpmap') >= 0 && line.indexOf('rtx') < 0 && line.indexOf('red') < 0 && line.indexOf('ulpfec') < 0){\r\n            var pt =line.split(\" \")[0].split(\":\")[1]\r\n            ptArr.push(pt)\r\n        }\r\n    });\r\n\r\n\r\n    // add new a=fmtp line if rtpmap is not have a=fmtp line\r\n    for(var j = 0; j<ptArr.length; j++){\r\n        if(sdp.indexOf('a=fmtp:' + ptArr[j]) < 0){\r\n            for(var k = 0; k<lines.length; k++){\r\n                if(lines[k].indexOf('a=rtpmap:' + ptArr[j]) >= 0){\r\n                    // Skip a=rtpmap lines for encoding\r\n                    k++\r\n                    var newLines = lines.slice(0, k)\r\n                    newLines.push('a=fmtp:' + ptArr[j])\r\n                    lines = newLines.concat(lines.slice(k, lines.length))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 考虑：a=fmtp:100 这种形式，添加时首个不要分号，要空格\r\n    // 有的PT没有x-google-min-bitrate=1024;x-google-start-bitrate=1536;x-google-max-bitrate=2048字段： 有则修改，没有则添加\r\n    for(var i = 0; i<lines.length; i++){\r\n        if(lines[i].indexOf('a=fmtp:') >= 0){\r\n            // filter rtx and ulpfec\r\n            if(lines[i].indexOf('apt=') >= 0 || lines[i].indexOf('ulpfec') >= 0){\r\n                continue\r\n            }\r\n\r\n            // filter a=fmtp:100 format\r\n            lines[i] = lines[i].trim()\r\n            if(lines[i].split(' ').length === 1){\r\n                replacement = \" x-google-min-bitrate=\" + bitrate + \";x-google-start-bitrate=\" + bitrate + \";x-google-max-bitrate=\" + bitrate\r\n                lines[i] = lines[i] + replacement\r\n            }else {\r\n                if(lines[i].indexOf('x-google-min-bitrate') >= 0){\r\n                    replacement = \"x-google-min-bitrate=\" + bitrate\r\n                    lines[i] = lines[i].replace(/x-google-min-bitrate=([a-zA-Z0-9]{1,8})/, replacement);\r\n                }else {\r\n                    replacement = \";x-google-min-bitrate=\" + bitrate\r\n                    lines[i] = lines[i] + replacement\r\n                }\r\n\r\n                if(lines[i].indexOf('x-google-start-bitrate') >= 0){\r\n                    replacement = \"x-google-start-bitrate=\" + bitrate\r\n                    lines[i] = lines[i].replace(/x-google-start-bitrate=([a-zA-Z0-9]{1,8})/, replacement);\r\n                }else {\r\n                    replacement = \";x-google-start-bitrate=\" + bitrate\r\n                    lines[i] = lines[i] + replacement\r\n                }\r\n\r\n                if(lines[i].indexOf('x-google-max-bitrate') >= 0){\r\n                    replacement = \"x-google-max-bitrate=\" + bitrate\r\n                    lines[i] = lines[i].replace(/x-google-max-bitrate=([a-zA-Z0-9]{1,8})/, replacement);\r\n                }else {\r\n                    replacement = \";x-google-max-bitrate=\" + bitrate\r\n                    lines[i] = lines[i] + replacement\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * remove REMB Negotiation\r\n * @param sdp\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.removeREMBField = function(sdp){\r\n    var lines = sdp.split(\"\\n\")\r\n\r\n    for(var i = 0; i<lines.length; i++){\r\n        if (lines[i].indexOf('goog-remb') >= 0 || lines[i].indexOf('transport-cc') >= 0) {\r\n            log.info('remove goog-remb or transport-cc filed')\r\n            lines.splice(i, 1)\r\n            i--\r\n        }\r\n    }\r\n    return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * 删除level-asymmetry-allowed\r\n * @param sdp\r\n * @returns {string}\r\n */\r\nGsRTC.prototype.removeLevel = function(sdp){\r\n    var lines = sdp.split(\"\\n\")\r\n    for(var i = 0; i<lines.length; i++){\r\n        if (lines[i].indexOf('level-asymmetry-allowed') >= 0 ) {\r\n            log.info('remove level-asymmetry-allowed')\r\n            lines.splice(i, 1)\r\n            i--\r\n        }\r\n    }\r\n    return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * save original and modified mid before send invites\r\n * @param type 类型\r\n * @param mid 原本的mid\r\n */\r\nGsRTC.prototype.saveMid = function(type, mid){\r\n    log.info('save mid')\r\n    let This = this\r\n\r\n    switch (type) {\r\n        case 'audio':\r\n            This.MID_OBJ.AUDIO_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.AUDIO_MID.MODIFIED_MID = This.getModifiedMid(type)\r\n            break\r\n        case 'main':\r\n            This.MID_OBJ.MAIN_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.MAIN_MID.MODIFIED_MID = This.getModifiedMid(type)\r\n            break\r\n        case 'slides':\r\n            This.MID_OBJ.SLIDES_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.SLIDES_MID.MODIFIED_MID = This.getModifiedMid(type)\r\n            break\r\n        case 'gui':\r\n            This.MID_OBJ.GUI_MID.ORIGINAL_MID = mid\r\n            This.MID_OBJ.GUI_MID.MODIFIED_MID = This.getModifiedMid(type)\r\n            break\r\n        default:\r\n            break\r\n    }\r\n}\r\n\r\n/**\r\n * get modified mid before set remote\r\n * @param type\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getModifiedMid = function(type){\r\n    let This = this\r\n    let mid;\r\n    if(type === \"audio\"){\r\n        mid = This.MID_OBJ.AUDIO_MID.MODIFIED_MID ? This.MID_OBJ.AUDIO_MID.MODIFIED_MID : 0;\r\n    }else if(type === \"main\"){\r\n        mid = This.MID_OBJ.MAIN_MID.MODIFIED_MID ? This.MID_OBJ.MAIN_MID.MODIFIED_MID : 1;\r\n    }else if(type === \"slides\"){\r\n        mid = This.MID_OBJ.SLIDES_MID.MODIFIED_MID ? This.MID_OBJ.SLIDES_MID.MODIFIED_MID : 2;\r\n    }else if(type === \"gui\"){\r\n        mid = This.MID_OBJ.GUI_MID.MODIFIED_MID ? This.MID_OBJ.GUI_MID.MODIFIED_MID : 3;\r\n    }\r\n    log.info('get ' + type + ' mid of ' + mid)\r\n    return mid;\r\n}\r\n\r\n/**\r\n * 获取原本的mid\r\n * @param type\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.getOriginalMid = function(type){\r\n    let This = this\r\n    let mid;\r\n    if(type === \"audio\"){\r\n        mid = This.MID_OBJ.AUDIO_MID.ORIGINAL_MID\r\n    }else if(type === \"main\"){\r\n        mid = This.MID_OBJ.MAIN_MID.ORIGINAL_MID\r\n    }else if(type === \"slides\"){\r\n        mid = This.MID_OBJ.SLIDES_MID.ORIGINAL_MID\r\n    }else if(type === \"gui\"){\r\n        mid = This.MID_OBJ.GUI_MID.ORIGINAL_MID\r\n    }\r\n    log.info('get ' + type + ' mid of ' + mid)\r\n    return mid;\r\n}\r\n\r\n/**\r\n * change resolution of sdp\r\n * @param width\r\n * @param height\r\n * @param sdp: parseSDP\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.setResolutionOfSdp = function (sdp, width, height) {\r\n    if (!sdp || !width || !height) {\r\n        log.error(\"Invalid argument\");\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        sdp = this.setH264ResolutionOfSdp(sdp, width, height)\r\n        sdp = this.setVp8ResolutionOfSdp(sdp, width, height)\r\n    }catch (e) {\r\n        log.error(e)\r\n    }\r\n    return sdp\r\n}\r\n\r\n/**\r\n * get type by transceiver mid\r\n * @param mid\r\n */\r\nGsRTC.prototype.getTypeByMid = function(mid){\r\n    let type\r\n    mid = parseInt(mid)\r\n    switch (mid) {\r\n        case 0:\r\n            type = 'audio'\r\n            break\r\n        case 1:\r\n            type = 'main'\r\n            break\r\n        case 2:\r\n            type = 'slides'\r\n            break\r\n        case 3:\r\n            type = 'gui '\r\n            break\r\n        default:\r\n            break\r\n    }\r\n    log.info('get type by transceiver mid ' + type)\r\n\r\n    return type\r\n}\r\n\r\n/**\r\n * 调整m行顺序，使用getCaptureStream创建多个m行时，audio会在最后面\r\n * 根据m行数量，修改 a=group:BUNDLE 和a=msid-semantic:\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.adjustOrderOfMLines = function (sdp) {\r\n    log.info('Adjust the order of m lines')\r\n    let This = this\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    let audioArray\r\n    let videoArray = []\r\n    let videoMid = 1\r\n    let type = ''\r\n    let originalMid\r\n    parseSDP.msidSemantics = []\r\n    parseSDP.groups = [{type: \"BUNDLE\", mids: 0}]\r\n\r\n    for(let i=0; i< parseSDP.media.length; i++){\r\n        originalMid = parseSDP.media[i].mid\r\n        if(parseSDP.media[i].type === 'audio'){\r\n            type = 'audio'\r\n            parseSDP.media[i].mid = This.getModifiedMid('audio')\r\n            audioArray = parseSDP.media[i]\r\n        }else {\r\n            type = This.getTypeByMid(videoMid)\r\n            parseSDP.media[i].mid = videoMid\r\n            parseSDP.media[i].content = type\r\n            parseSDP.groups.push({type: \"BUNDLE\", mids: parseSDP.media[i].mid})\r\n            videoArray.push(parseSDP.media[i])\r\n            videoMid ++\r\n        }\r\n        parseSDP.msidSemantics.push( {semantic: \"\", token: \"WMS\"})\r\n        This.saveMid(type, originalMid)\r\n        This.RTCSession.mLineOrder.push(type)\r\n    }\r\n    This.RTCSession.mLineOrder = [...new Set(This.RTCSession.mLineOrder)];\r\n\r\n    parseSDP.media = [audioArray]\r\n    parseSDP.media = parseSDP.media.concat(videoArray)\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n\r\n    return sdp\r\n}\r\n\r\n/**\r\n * 删除ssrc字段\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.removeSSRC = function (sdp) {\r\n    log.info('remove ssrc')\r\n    let This = this\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    let stream\r\n    for(let i=0; i< parseSDP.media.length; i++){\r\n        let type = This.getTypeByMid(parseSDP.media[i].mid)\r\n        stream = This.RTCSession.getStream(type, true)\r\n        if(!stream){\r\n            log.info('deleted stream info')\r\n            delete parseSDP.media[i].ssrcGroups\r\n            delete parseSDP.media[i].ssrcs\r\n            parseSDP.media[i].direction = 'recvonly'\r\n        }\r\n    }\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n\r\n    return sdp\r\n}\r\n\r\nGsRTC.prototype.modifyMidDirection = function(sdp){\r\n    log.info(\"modify mid direction\")\r\n    let This = this\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    for(let i =0; i < parseSDP.media.length; i++){\r\n        let media = parseSDP.media[i]\r\n        if(media.type === 'audio'){\r\n            media.direction = \"inactive\"\r\n        }else if(media.content === 'main'){\r\n            if(This.RTCSession.isRequestOpenRemoteVideo){\r\n                media.direction = 'recvonly'\r\n            }\r\n            if(This.action === 'stopRemoteControl'){\r\n                media.direction = 'inactive'\r\n            }\r\n        } else if(media.content === 'slides'){\r\n\r\n            if(This.RTCSession.sharingPermission === 1 || This.RTCSession.sharingPermission === 3){\r\n                media.direction = 'sendonly'\r\n            }else if(This.RTCSession.sharingPermission === 0 || This.RTCSession.sharingPermission === 2){\r\n                media.direction = 'inactive'\r\n            }\r\n        }\r\n    }\r\n\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n    return sdp\r\n}\r\n\r\n/**\r\n * 根据编解码名称删除编解码\r\n * @param sdp\r\n * @returns {*}\r\n */\r\nGsRTC.prototype.removeCodeByName = function (sdp) {\r\n    log.info('remove ssrc')\r\n    let lines = sdp.split('\\n')\r\n    let removePayloads = [97,106, 105, 13, 110, 112, 113, 98, 99, 127, 121, 125, 107, 108, 109, 124, 120, 123 ,119, 114, 115 ,116]\r\n\r\n    function getMLinePosition(lines){\r\n        // 获取所有m行的位置\r\n        let arr = []\r\n        for(let index in lines){\r\n            if(lines[index].indexOf('m=') >= 0){\r\n                arr.push(parseInt(index))\r\n            }\r\n        }\r\n        arr.push(lines.length)\r\n        return arr\r\n    }\r\n\r\n    function getPtNumber(arr){\r\n        arr = arr.split('\\n')\r\n        let deleteCodeArray = []\r\n        for(let j in arr){\r\n            if(arr[j].indexOf('a=rtpmap') >=0 && (arr[j].indexOf(deleteCodeName[0]) >=0 || arr[j].indexOf(deleteCodeName[1]) >=0 )){\r\n                let pt = arr[j].substr(9, 3);\r\n                deleteCodeArray.push(pt)\r\n            }\r\n        }\r\n        return deleteCodeArray\r\n    }\r\n\r\n    function codecRemove(sdpLine){\r\n        let deletePt = getPtNumber(sdpLine)\r\n        let parseSDP = SDPTools.parseSDP(sdpLine)\r\n        deletePt = deletePt.concat(removePayloads)\r\n        SDPTools.removeCodecByPayload(parseSDP, 0, deletePt)\r\n        sdpLine = SDPTools.writeSDP(parseSDP)\r\n        return sdpLine\r\n    }\r\n\r\n    function deleteHead(sdp) {\r\n        let lines = sdp.split('\\n')\r\n        for(var k = 0; k<lines.length; k++){\r\n            if(lines[k].indexOf('m=') >= 0){\r\n                sdpArray[0] = lines.slice(0, k)\r\n                sdp = lines.slice(k, lines.length).join('\\n')\r\n            }\r\n        }\r\n        return sdp\r\n    }\r\n\r\n    let positions = getMLinePosition(lines)\r\n    let deleteCodeName = ['VP8', 'VP9']\r\n    // 根据m行位置分割sdp数组\r\n    let sdpArray = []\r\n    let nextIndex = 0\r\n    let head = lines.slice(0, positions[0])\r\n    for(let i = 0;i<positions.length; i++){\r\n        nextIndex = i +1\r\n        if(positions[nextIndex]){\r\n            let arr = lines.slice(positions[i], positions[nextIndex])\r\n            arr = head.concat(arr).join('\\n')\r\n            arr = codecRemove(arr)\r\n            sdpArray.push(arr)\r\n        }\r\n    }\r\n\r\n    let result = head.join('\\n') + '\\n'\r\n    for(let item of sdpArray){\r\n        item = deleteHead(item)\r\n        result = result + item\r\n    }\r\n    return result\r\n}\r\n\r\n\r\nGsRTC.prototype.deleteCodeByName = function(sdp){\r\n    log.info(\"delete codec\")\r\n    let parseSDP = SDPTools.parseSDP(sdp)\r\n    if(parseSDP.media && parseSDP.media.length){\r\n        for(let i = 0;i < parseSDP.media.length;i++){\r\n            let media = parseSDP.media[i]\r\n            let codec = ['vp8','vp9']\r\n            if(media.type === \"audio\"){\r\n                codec = ['G722', 'opus', 'PCMU', 'PCMA']     // only keep ['G722', 'opus', 'PCMU', 'PCMA']\r\n                SDPTools.removeCodecByName(parseSDP, i, codec, true)\r\n            }else{\r\n                // move red_ulpfec\r\n                if(localStorage.getItem(\"test_red_ulpfec_enabled\") !== 'true'){\r\n                    codec.push('red', 'ulpfec')\r\n                }\r\n                // handle H264 codec\r\n                parseSDP = gsRTC.trimCodec(parseSDP, i)\r\n                SDPTools.removeCodecByName(parseSDP, i, codec)\r\n            }\r\n        }\r\n    }\r\n    sdp = SDPTools.writeSDP(parseSDP)\r\n    return sdp\r\n}\r\n\r\nGsRTC.prototype.trimCodec = function (parseSDP, index){\r\n    let media = parseSDP.media[index]\r\n    let priorityCodec = gsRTC.RTCSession.getExternalEncoder(media)\r\n    let h264Codec = SDPTools.getCodecByName(parseSDP, index,['H264','VP8','VP9'])\r\n    if(h264Codec && h264Codec.length){\r\n        let removeList = []\r\n        if(!priorityCodec){\r\n            let topPriorityCodec = h264Codec.splice(1, h264Codec.length)\r\n            removeList.push(topPriorityCodec)\r\n            // If profile-level-id does not exist, set to 42e028\r\n            for(let i = 0; i<media.fmtp.length; i++){\r\n                if( media.fmtp[i].payload === topPriorityCodec){\r\n                    let config = media.fmtp[i].config\r\n                    if(config.indexOf('profile-level-id') < 0){\r\n                        config = config + ';profile-level-id=42e028';\r\n                    }\r\n                }\r\n            }\r\n        }else {\r\n            h264Codec.forEach(function (pt) {\r\n                if(pt !== priorityCodec){\r\n                    removeList.push(pt)\r\n                }\r\n            })\r\n        }\r\n        SDPTools.removeCodecByPayload(parseSDP, index, removeList)\r\n    }\r\n\r\n    return parseSDP\r\n}\n/*Log Debug Start*/\r\nvar log = {\r\n    debug: window.debug(\"WebSocket:DEBUG\"),\r\n    log: window.debug(\"WebSocket:LOG\"),\r\n    info: window.debug(\"WebSocket:INFO\"),\r\n    warn: window.debug(\"WebSocket:WARN\"),\r\n    error: window.debug(\"WebSocket:ERROR\")\r\n};\r\n/*Log Debug End*/\r\n\r\n\r\n/**\r\n * create webSocket instance\r\n * @param data\r\n * @returns {WebSocket|*}\r\n * @constructor\r\n */\r\nlet WebSocketInstance = function (data) {\r\n    log.info('create new webSocket.')\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(data.url)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" + data.url + \"' is not valid as webSocket url value\");\r\n    }\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(data.protocol)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" + data.protocol + \"' is not valid as protocol value\");\r\n    }\r\n\r\n    if(this instanceof WebSocketInstance){\r\n        this.ws = this.createWebSocket(data)\r\n    }else {\r\n        return new WebSocketInstance(data)\r\n    }\r\n}\r\n\r\n/**\r\n * create new webSocket\r\n * @param data\r\n * @returns {WebSocket}\r\n */\r\nWebSocketInstance.prototype.createWebSocket = function(data){\r\n    log.info('create webSocket')\r\n    if (GsRTC.prototype.tskStringIsNullOrEmpty(data.url)) {\r\n        throw new Error(\"ERR_INVALID_PARAMETER_VALUE: '\" +data. url + \"' is not valid as webSocket url value\");\r\n    }\r\n\r\n    let This = this\r\n    log.info('Connecting to \\'' + data.url);\r\n    let ws = new WebSocket(data.url, data.protocol)\r\n\r\n    ws.onopen = function (event) {\r\n        log.info('websocket onopen, prepare call...')\r\n        gsRTC.sokect.ws.websocketTimer = setInterval(function(){\r\n            if(gsRTC.sokect.ws.readyState == 1){\r\n                let wsData = \"\\r\\n\"\r\n                gsRTC.sokect.ws.send(wsData)\r\n            }else{\r\n               log.info(\"websocket 建立失败\")\r\n            }\r\n        },5000)\r\n        This.isChannelOpen = true;\r\n        gsRTC.inviteCall({callback: data.callback});\r\n    }\r\n\r\n    ws.onmessage = function (event) {\r\n        if(event.data !== \"\\r\\n\\r\\n\"){\r\n            This.handleIncomingMessage(event.data)\r\n        }\r\n    }\r\n\r\n    ws.onclose = function (event) {\r\n        log.info('websocket onclose')\r\n        This.isChannelOpen = false\r\n        if(gsRTC && gsRTC.RTCSession && (gsRTC.RTCSession.sharingPermission !== 4  && gsRTC.RTCSession.sharingPermission !== 5)){\r\n            log.warn(\"同步按钮状态\")\r\n            gsRTC.trigger(\"error\", {\r\n                codeType: gsRTC.CODE_TYPE.WEBSOCKET_CLOSE.codeType,\r\n                message: gsRTC.CODE_TYPE.WEBSOCKET_CLOSE\r\n            });\r\n            gsRTC.cleanGsRTC()\r\n        }\r\n\r\n    }\r\n\r\n    ws.onerror =function(error) {\r\n        log.info('websocket onerror:',error)\r\n    }\r\n    return ws\r\n}\r\n\r\n/**\r\n * 处理收到的 webSocket消息\r\n * @param message\r\n */\r\nWebSocketInstance.prototype.handleIncomingMessage = function(message){\r\n    let This = this\r\n    let code = null\r\n    let showCode = null\r\n    let messageObj = JSON.parse(message)\r\n    let action = Object.keys(messageObj)[0]\r\n    log.info('handleIncomingMessage of: ' + action)\r\n\r\n    let data = messageObj[action]\r\n    if(data.rspInfo) {\r\n        code = data.rspInfo.rspCode;\r\n    }\r\n    if(data.rspInfo){\r\n        showCode = data.rspInfo.showCode\r\n    }\r\n\r\n    if(action === 'ctrlPresentation'){\r\n        if(data.sendPermission === 3){\r\n            gsRTC.RTCSession.openSharingTimeoutstartTime = (new Date()).getTime()\r\n        }\r\n        log.info(\"receive \"+ action +\" message:\",JSON.stringify(messageObj, null, '  '))\r\n    } else{\r\n        if(action === 'ctrlPresentationRet'){\r\n            gsRTC.RTCSession.isOpenSharingReceiveReply = true\r\n            gsRTC.clearTimer()\r\n        } else if(action === 'cancelRequest'){\r\n            //暂时没有\r\n        } else if(action === 'updateMediaSessionRet'){\r\n            gsRTC.RTCSession.cancelReqCmd = null\r\n            gsRTC.RTCSession.cancelReqId = null\r\n            gsRTC.RTCSession.reqId = null\r\n        }\r\n        log.info(\"receive \"+ action +\" message:\",JSON.stringify(data.rspInfo, null, '  '))\r\n    }\r\n\r\n    switch (action) {\r\n        case gsRTC.SIGNAL_EVENT_TYPE.INVITE_RET.name:\r\n        case gsRTC.SIGNAL_EVENT_TYPE.RE_INVITE_RET.name:\r\n            if (gsRTC.isNxx(2, code)) {\r\n                let sdp = data.sdp.data\r\n                log.info(gsRTC.action + ' success')\r\n                gsRTC.RTCSession.handleRemoteSDP(sdp)\r\n            } else if (gsRTC.isNxx(4, code)) {\r\n                let stream = gsRTC.shareScreenStream\r\n                if (gsRTC.getBrowserDetail().browser === 'safari') {\r\n                    gsRTC.RTCSession.stopTrack(stream)\r\n                } else {\r\n                    stream = null\r\n                }\r\n                gsRTC.RTCSession.peerConnection.close()\r\n                gsRTC.CODE_TYPE.REFUSE_CALL.isCallSuccess = 'false'\r\n                log.error(code + ', ' + data.rspInfo.rspMsg)\r\n                gsRTC.trigger('error', {\r\n                    codeType: code,\r\n                    message: data.rspInfo.rspMsg,\r\n                    showCode: showCode,\r\n                    isCallSuccess: gsRTC.CODE_TYPE.REFUSE_CALL.isCallSuccess\r\n                });\r\n            }\r\n            break;\r\n        case gsRTC.SIGNAL_EVENT_TYPE.PRESENT.name:\r\n            // gs_phone请求开演示\r\n            gsRTC.RTCSession.reqId = data.reqId\r\n            if (data.sendPermission === 2) {\r\n                if(gsRTC.RTCSession.sendCtrlPresentation === true){\r\n                    log.info(\"Stop Share Screen is being turned on\")\r\n                    gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: gsRTC.CODE_TYPE.PRESENT_OFF_SHARING, reqId: gsRTC.RTCSession.reqId})\r\n                }else{\r\n                    log.warn('receive request to turn off desktop sharing')\r\n                    gsRTC.RTCSession.sendCtrlPresentation = true\r\n                    gsRTC.serverAction = 'stopShareScreenRequest'\r\n                    gsRTC.trigger('stopShareScreenRequest', gsRTC.serverPresentRequest)\r\n                }\r\n\r\n            } else if (data.sendPermission === 3) {\r\n                if( gsRTC.RTCSession.sendCtrlPresentation === true ){\r\n                    log.info(\"Share Screen is being turned on\")\r\n                    gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.PRESENT_RET, ctrlPresentationRet: gsRTC.CODE_TYPE.PRESENT_ON_SHARING, reqId: gsRTC.RTCSession.reqId})\r\n                }else{\r\n                    log.warn('receive request to turn on desktop sharing')\r\n                    gsRTC.RTCSession.sendCtrlPresentation = true\r\n                    gsRTC.openSharingTimeout(data)\r\n                    gsRTC.serverAction = 'shareScreenRequest'\r\n                    gsRTC.trigger('shareScreenRequest', gsRTC.serverPresentRequest)\r\n                }\r\n            }\r\n            break\r\n        case gsRTC.SIGNAL_EVENT_TYPE.PRESENT_RET.name:\r\n            if (gsRTC.isNxx(2, code)) {\r\n                if (gsRTC.RTCSession.sharingPermission === 1) {\r\n                    log.info('present on request ' + code)\r\n                    if(gsRTC.RTCSession.isSendCancelRequest){\r\n                        let stream = gsRTC.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n                        if(stream){\r\n                            gsRTC.RTCSession.closeStream(stream)\r\n                        }\r\n                        gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.CLOSE, close: { value: gsRTC.sharingPermission, reqId: gsRTC.reqId}})\r\n                        gsRTC.RTCSession.isOpenSharingReceiveReply = false\r\n                        gsRTC.RTCSession.isSendCancelRequest = false\r\n                        gsRTC.RTCSession.sharingPermission = 0\r\n                        gsRTC.RTCSession.reqId = null\r\n                    }else{\r\n                        gsRTC.RTCSession.openSharing = true\r\n                        gsRTC.RTCSession.reqId = null\r\n                        log.info('get Present stream success ')\r\n                        let stream = gsRTC.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n                        let pc = gsRTC.RTCSession.peerConnection\r\n                        log.info('prepare do offer!')\r\n                        gsRTC.RTCSession.processAddStream(stream, pc, 'slides')\r\n                        gsRTC.RTCSession.doOffer(pc)\r\n                    }\r\n                } else {\r\n                    if(gsRTC.RTCSession.sharingPermission === 0){\r\n                        gsRTC.RTCSession.openSharing = false\r\n                    }\r\n                    log.info('present off request ' + code)\r\n                    log.info('codeType:', code + ', ' + 'message:', data.rspInfo.rspMsg)\r\n                    gsRTC.trigger(gsRTC.action, {\r\n                        codeType: code,\r\n                        message: data.rspInfo.rspMsg,\r\n                        showCode: showCode,\r\n                    });\r\n                }\r\n            } else if (gsRTC.isNxx(4, code)) {\r\n                let stream = gsRTC.MEDIA_STREAMS.LOCAL_PRESENT_STREAM\r\n                if(stream){\r\n                    gsRTC.RTCSession.closeStream(stream)\r\n                }\r\n                gsRTC.RTCSession.cancelReqCmd = null\r\n                gsRTC.RTCSession.cancelReqId = null\r\n                gsRTC.RTCSession.openSharing = false\r\n                if(code === 408 ||code === 489){\r\n                    log.error(code + ', ' + data.rspInfo.rspMsg)\r\n                    if(gsRTC.RTCSession.isSendCancelRequest){\r\n                        gsRTC.RTCSession.sharingPermission = 0\r\n                        gsRTC.RTCSession.isSendCancelRequest = false\r\n                        gsRTC.RTCSession.isOpenSharingReceiveReply = false\r\n                        gsRTC.RTCSession.reqId = null\r\n                    }\r\n                }\r\n                gsRTC.trigger('error', {\r\n                    codeType: code,\r\n                    message: data.rspInfo.rspMsg,\r\n                    showCode: showCode,\r\n                });\r\n            }\r\n            break\r\n        case gsRTC.SIGNAL_EVENT_TYPE.CANCEL.name:\r\n            gsRTC.RTCSession.reqId = data.reqId\r\n            gsRTC.RTCSession.sharingPermission = 0\r\n            gsRTC.RTCSession.reqId = null\r\n            log.info(\"cancel:\" + code + ', ' + data.rspInfo.rspMsg)\r\n            if(gsRTC.isNxx(2, code)){\r\n                gsRTC.sokect.sendMessage({type: gsRTC.SIGNAL_EVENT_TYPE.CANCEL_RET, cancelRequestRet: code, reqId: data.reqId})\r\n            }\r\n            break\r\n        case gsRTC.SIGNAL_EVENT_TYPE.CANCEL_RET.name:\r\n            gsRTC.RTCSession.reqId = data.reqId\r\n            gsRTC.RTCSession.cancelReqId = null\r\n            gsRTC.RTCSession.cancelReqCmd = null\r\n            gsRTC.RTCSession.sharingPermission = 0\r\n            gsRTC.RTCSession.isOpenSharingReceiveReply = false\r\n            gsRTC.RTCSession.reqId = null\r\n            log.info(\"cancel_ret:\" + code + ', ' + data.rspInfo.rspMsg)\r\n            break\r\n        case gsRTC.SIGNAL_EVENT_TYPE.BYE.name:\r\n            if(gsRTC.isNxx(5, code)){\r\n                gsRTC.trigger('error', {\r\n                    codeType:code,\r\n                    message: data.rspInfo.rspMsg,\r\n                    showCode: showCode\r\n                })\r\n            }\r\n            //gs_phone 请求挂断\r\n            gsRTC.reqId = data.reqId\r\n            log.warn('receive request to hangup')\r\n            gsRTC.RTCSession.openSharingTimeoutstartTime = null\r\n            gsRTC.serverAction = 'hangupRequest'\r\n            gsRTC.trigger('hangupRequest', gsRTC.serverPresentRequest)\r\n            break\r\n        case gsRTC.SIGNAL_EVENT_TYPE.BYE_RET.name:\r\n            gsRTC.cleanGsRTC()\r\n            gsRTC.trigger(gsRTC.action, {\r\n                codeType: code,\r\n                message: data.rspInfo.rspMsg,\r\n                showCode: showCode\r\n            });\r\n            break\r\n        default:\r\n            break\r\n    }\r\n}\r\n\r\n/**\r\n * 根据交互设计协议，发送不同结构体信息\r\n * @param data\r\n */\r\nWebSocketInstance.prototype.sendMessage = function (data) {\r\n    let This = this\r\n    if(!This.ws){\r\n        log.warn('websocket has not been created yet to send message')\r\n        return\r\n    }\r\n\r\n    let reqId = parseInt(Math.round(Math.random()*100));\r\n    let info = {\r\n        userName: gsRTC.conf.userName,\r\n        reqId: data.reqId ? data.reqId : reqId,\r\n    }\r\n    let signalType = data.type.name\r\n    let message = {}\r\n    message[signalType] = info\r\n    if(data.mediaSession){\r\n        info.sdp = {\r\n            length: data.mediaSession.length,\r\n            data: data.mediaSession,\r\n        }\r\n        log.info('Establish or update a session')\r\n    }else if(data.ctrlPresentation){\r\n        info.sendPermission = data.ctrlPresentation.value\r\n        if(data.ctrlPresentation.value === 1){\r\n            gsRTC.RTCSession.cancelReqCmd = signalType\r\n            gsRTC.RTCSession.cancelReqId = info.reqId\r\n        }\r\n        log.info('send present control message: \\n' + JSON.stringify(info))\r\n    }else if(data.ctrlPresentationRet) {\r\n        info.rspInfo = {\r\n            rspCode: data.ctrlPresentationRet.codeType,\r\n            rspMsg: data.ctrlPresentationRet.message\r\n        }\r\n        gsRTC.RTCSession.reqId = null\r\n        log.info('send present control response message: \\n' + JSON.stringify(info))\r\n    }else if(data.cancelRequest){\r\n        info.sendPermission = data.cancelRequest.value\r\n        info.cancelReqId =  gsRTC.RTCSession.cancelReqId\r\n        info.cancelReqCmd =  gsRTC.RTCSession.cancelReqCmd\r\n        log.info('send cancel shareScreen signaling message: \\n' + JSON.stringify(info))\r\n    }else if(data.cancelRequestRet){\r\n        info.rspInfo = {\r\n            rspCode: data.cancelRequestRet.codeType,\r\n            rspMsg: data.cancelRequestRet.message\r\n        }\r\n        gsRTC.RTCSession.reqId = null\r\n        log.info('send cancel shareScreen signaling response message: \\n' + JSON.stringify(info))\r\n    }else if(data.destroyMediaSession){\r\n        info.sdp = {\r\n            length: data.destroyMediaSession.length,\r\n            data: data.destroyMediaSession,\r\n        }\r\n        log.info('send hangup control message: \\n' + JSON.stringify(info))\r\n    }else if(data.destroyMediaSessionRet){\r\n        info.rspInfo = {\r\n            rspCode: data.destroyMediaSessionRet.codeType,\r\n            rspMsg: data.destroyMediaSessionRet.message\r\n        }\r\n        gsRTC.RTCSession.reqId = null\r\n        log.info('send hangup control response message: \\n' + JSON.stringify(info))\r\n    }\r\n\r\n    log.warn(\"ws send message\");\r\n\r\n    This.ws.send(JSON.stringify(message))\r\n    if(data.ctrlPresentation && data.ctrlPresentation.value === 1){\r\n        gsRTC.RTCSession.openSharingTimeoutstartTime = (new Date()).getTime()\r\n        gsRTC.replyOpenSharingTimeout()\r\n    }\r\n}\r\n\r\n"],"file":"gsRTC.min.js"}